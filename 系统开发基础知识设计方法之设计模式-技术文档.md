# Design Patterns - Comprehensive Technical Documentation

# 系统开发基础知识设计方法之设计模式 - 完整技术文档

---

## Table of Contents | 目录

1. [Introduction | 概述](#introduction--概述)
2. [Design Patterns Overview | 设计模式概述](#design-patterns-overview--设计模式概述)
3. [Object-Oriented Design Principles | 面向对象设计原则](#object-oriented-design-principles--面向对象设计原则)
4. [Creational Patterns | 创建型模式](#creational-patterns--创建型模式)
5. [Structural Patterns | 结构型模式](#structural-patterns--结构型模式)
6. [Behavioral Patterns | 行为型模式](#behavioral-patterns--行为型模式)
7. [Pattern Selection and Application | 模式选择与应用](#pattern-selection-and-application--模式选择与应用)
8. [Exam Focus Points | 考试要点](#exam-focus-points--考试要点)
9. [Best Practices | 最佳实践](#best-practices--最佳实践)

---

## Introduction | 概述

### What are Design Patterns? | 什么是设计模式?

**English:**

**Design Patterns** are reusable solutions to commonly occurring problems in software design. They represent best practices evolved over time by experienced software developers and provide a standard terminology and a common understanding of design problems and their solutions.

**Key Characteristics | 关键特征**:
- **Proven Solutions**: Battle-tested approaches from real-world projects
- **Reusability**: Applicable across different contexts and domains
- **Expressiveness**: Provide a shared vocabulary for designers
- **Flexibility**: Can be adapted to specific requirements
- **Best Practices**: Encapsulate design expertise and experience

**History and Origin | 历史与起源**:

The concept originated from Christopher Alexander's work on architectural patterns in the 1970s. In 1994, the "Gang of Four" (Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides) published the seminal book:

**"Design Patterns: Elements of Reusable Object-Oriented Software"**

This book cataloged **23 fundamental design patterns** that became the foundation of modern software design.

**中文:**

**设计模式**是软件设计中常见问题的可重用解决方案。它们代表了经验丰富的软件开发人员经过时间演化而来的最佳实践，并为设计问题及其解决方案提供了标准术语和共同理解。

**历史与起源**:

该概念源于Christopher Alexander在20世纪70年代关于建筑模式的工作。1994年，"四人帮"（Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides）出版了开创性著作：

**《设计模式：可复用面向对象软件的基础》**

该书编目了**23种基本设计模式**，成为现代软件设计的基础。

### Why Design Patterns Matter | 设计模式的重要性

**English:**

**For Software Development | 对软件开发**:
1. **Accelerate Development**: Reuse proven solutions rather than reinventing
2. **Improve Communication**: Common vocabulary reduces misunderstandings
3. **Enhance Maintainability**: Well-structured code is easier to modify
4. **Increase Flexibility**: Patterns facilitate change and extension
5. **Reduce Bugs**: Proven solutions minimize design errors

**For System Architects Exam | 对系统架构设计师考试**:
- **Core Topic**: Design patterns account for 15-20% of exam content
- **Case Analysis**: Pattern selection justification in architecture scenarios
- **Code Reading**: Recognize patterns in given code snippets
- **Design Choices**: Explain trade-offs between different patterns

**中文:**

**对软件开发**:
1. **加速开发**: 重用经过验证的解决方案而非重新发明
2. **改善沟通**: 通用词汇减少误解
3. **增强可维护性**: 结构良好的代码更易于修改
4. **提高灵活性**: 模式促进变更和扩展
5. **减少缺陷**: 经过验证的解决方案最小化设计错误

**对系统架构设计师考试**:
- **核心主题**: 设计模式占考试内容的15-20%
- **案例分析**: 架构场景中的模式选择论证
- **代码阅读**: 识别给定代码片段中的模式
- **设计选择**: 解释不同模式之间的权衡

---

## Design Patterns Overview | 设计模式概述

### 1.1 Definition and Elements | 定义与要素

**English:**

**Design Pattern Definition | 设计模式定义**:

A design pattern has four essential elements:

1. **Pattern Name | 模式名称**
   - A handle to describe a design problem, solutions, and consequences
   - Example: "Singleton", "Observer", "Factory Method"

2. **Problem | 问题**
   - Describes when to apply the pattern
   - Explains the problem and its context
   - Example: "How to ensure a class has only one instance?"

3. **Solution | 解决方案**
   - Describes the elements (classes, objects) that make up the design
   - Includes relationships, responsibilities, and collaborations
   - Abstract enough to be applicable in different situations

4. **Consequences | 效果**
   - Results and trade-offs of applying the pattern
   - Impacts on flexibility, extensibility, and performance
   - Both benefits and liabilities

**中文:**

设计模式有四个基本要素：

1. **模式名称**: 用于描述设计问题、解决方案和效果的句柄
2. **问题**: 描述何时应用模式，解释问题及其上下文
3. **解决方案**: 描述组成设计的元素（类、对象）、关系、职责和协作
4. **效果**: 应用模式的结果和权衡，包括对灵活性、可扩展性和性能的影响

### 1.2 Classification of Design Patterns | 设计模式分类

**English:**

The 23 GoF design patterns are classified into three categories based on their purpose:

#### Creational Patterns | 创建型模式 (5 patterns)

**Purpose**: Deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.

**Patterns**:
1. **Singleton** - Ensure a class has only one instance
2. **Factory Method** - Define an interface for creating objects
3. **Abstract Factory** - Create families of related objects
4. **Builder** - Construct complex objects step by step
5. **Prototype** - Create objects by cloning existing instances

**Key Benefit**: Increase flexibility in **what** gets created, **who** creates it, **how** it gets created, and **when**.

#### Structural Patterns | 结构型模式 (7 patterns)

**Purpose**: Deal with object composition, creating relationships between objects to form larger structures.

**Patterns**:
1. **Adapter** - Convert interface of a class to another interface
2. **Bridge** - Decouple abstraction from implementation
3. **Composite** - Compose objects into tree structures
4. **Decorator** - Add responsibilities to objects dynamically
5. **Facade** - Provide unified interface to a subsystem
6. **Flyweight** - Share objects to support large numbers efficiently
7. **Proxy** - Provide surrogate or placeholder for another object

**Key Benefit**: Ensure that if one part of a system changes, the entire system doesn't need to change.

#### Behavioral Patterns | 行为型模式 (11 patterns)

**Purpose**: Deal with communication between objects, how objects interact and distribute responsibility.

**Patterns**:
1. **Chain of Responsibility** - Pass request along chain of handlers
2. **Command** - Encapsulate request as object
3. **Interpreter** - Define grammar and interpret sentences
4. **Iterator** - Access elements sequentially without exposing structure
5. **Mediator** - Define object that encapsulates how objects interact
6. **Memento** - Capture and restore object's internal state
7. **Observer** - Define one-to-many dependency between objects
8. **State** - Alter behavior when internal state changes
9. **Strategy** - Define family of algorithms, make them interchangeable
10. **Template Method** - Define skeleton of algorithm, defer steps to subclasses
11. **Visitor** - Define new operation without changing classes of elements

**Key Benefit**: Increase flexibility in carrying out communication between objects.

**中文:**

GoF的23种设计模式根据目的分为三类：

- **创建型模式(5种)**: 处理对象创建机制，以适合情况的方式创建对象
- **结构型模式(7种)**: 处理对象组合，创建对象间关系以形成更大结构
- **行为型模式(11种)**: 处理对象间通信，对象如何交互和分配职责

### 1.3 Pattern Relationships | 模式关系

**English:**

Design patterns are not isolated; they often work together and have relationships:

```
Pattern Relationship Map | 模式关系图:

Creational Patterns:
  Singleton ←→ Factory Method (Factory can enforce Singleton)
  Abstract Factory → Factory Method (uses)
  Builder → Composite (builds)
  Prototype → Memento (stores state)

Structural Patterns:
  Adapter ←→ Bridge (similar intent, different structure)
  Decorator ←→ Composite (similar structure)
  Facade → Adapter (uses)
  Proxy ←→ Decorator (similar implementation)

Behavioral Patterns:
  Observer ←→ Mediator (both manage communication)
  Command → Memento (undo/redo)
  Strategy ←→ State (similar structure)
  Template Method ←→ Strategy (alternative approaches)
  Chain of Responsibility → Composite (both use recursive composition)
```

**Pattern Combinations | 模式组合**:

| Combination<br/>组合                      | Purpose<br/>目的                                                 | Example<br/>示例                         |
| ----------------------------------------- | ---------------------------------------------------------------- | ---------------------------------------- |
| **Singleton + Factory<br/>单例+工厂**     | Ensure single factory instance<br/>确保单一工厂实例              | Configuration factory<br/>配置工厂       |
| **Adapter + Facade<br/>适配器+外观**      | Simplify and adapt subsystem<br/>简化和适配子系统                | Legacy system wrapper<br/>遗留系统包装器 |
| **Observer + Mediator<br/>观察者+中介者** | Complex notification system<br/>复杂通知系统                     | UI event handling<br/>UI事件处理         |
| **Decorator + Strategy<br/>装饰器+策略**  | Add behavior with switchable algorithms<br/>添加行为与可切换算法 | Stream processing<br/>流处理             |
| **Command + Memento<br/>命令+备忘录**     | Undo/redo functionality<br/>撤销/重做功能                        | Text editor<br/>文本编辑器               |

**中文:**

设计模式不是孤立的，它们经常一起工作并具有关系。

**[Exam Focus | 考试重点]**: Understand pattern relationships and when to combine patterns. Common exam question: "Which pattern works well with Pattern X to solve Problem Y?"

---

## Object-Oriented Design Principles | 面向对象设计原则

### 2.1 SOLID Principles | SOLID原则

**English:**

SOLID is an acronym for five design principles intended to make software designs more understandable, flexible, and maintainable.

#### 2.1.1 Single Responsibility Principle (SRP) | 单一职责原则

**Definition**:
A class should have only one reason to change.

**一个类应该只有一个引起它变化的原因。**

**Explanation**:
Each class should have responsibility for a single part of the functionality, and that responsibility should be entirely encapsulated by the class.

**Example - Violation | 违反示例**:
```java
// BAD: Class has multiple responsibilities
class Employee {
    private String name;
    private double salary;
    
    // Responsibility 1: Employee data management
    public void setName(String name) { this.name = name; }
    public void setSalary(double salary) { this.salary = salary; }
    
    // Responsibility 2: Salary calculation
    public double calculatePay() { /* complex calculation */ }
    
    // Responsibility 3: Database persistence
    public void save() { /* save to database */ }
    
    // Responsibility 4: Reporting
    public String generateReport() { /* generate report */ }
}
```

**Example - Correct | 正确示例**:
```java
// GOOD: Each class has single responsibility
class Employee {
    private String name;
    private double salary;
    
    public void setName(String name) { this.name = name; }
    public void setSalary(double salary) { this.salary = salary; }
}

class PayrollCalculator {
    public double calculatePay(Employee employee) { 
        /* calculation logic */ 
    }
}

class EmployeeRepository {
    public void save(Employee employee) { 
        /* database logic */ 
    }
}

class EmployeeReporter {
    public String generateReport(Employee employee) { 
        /* reporting logic */ 
    }
}
```

**Benefits | 好处**:
- ✅ Easier to understand and maintain
- ✅ Reduces coupling
- ✅ Easier to test
- ✅ Reduces risk of breaking existing functionality

**中文:**

一个类应该只有一个引起它变化的原因。每个类应该对功能的单一部分负责。

#### 2.1.2 Open-Closed Principle (OCP) | 开闭原则

**Definition**:
Software entities should be open for extension but closed for modification.

**软件实体应该对扩展开放，对修改关闭。**

**Explanation**:
You should be able to add new functionality without changing existing code.

**Example - Violation | 违反示例**:
```java
// BAD: Need to modify class to add new shape
class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return Math.PI * circle.radius * circle.radius;
        } else if (shape instanceof Rectangle) {
            Rectangle rect = (Rectangle) shape;
            return rect.width * rect.height;
        }
        // Need to modify this method to add Triangle!
        return 0;
    }
}
```

**Example - Correct | 正确示例**:
```java
// GOOD: Use abstraction to allow extension
interface Shape {
    double calculateArea();
}

class Circle implements Shape {
    private double radius;
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle implements Shape {
    private double width;
    private double height;
    
    @Override
    public double calculateArea() {
        return width * height;
    }
}

// Add new shape without modifying existing code
class Triangle implements Shape {
    private double base;
    private double height;
    
    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
}

class AreaCalculator {
    public double calculateTotalArea(List<Shape> shapes) {
        return shapes.stream()
                     .mapToDouble(Shape::calculateArea)
                     .sum();
    }
}
```

**Benefits | 好处**:
- ✅ Reduces risk of breaking existing code
- ✅ Promotes code reuse
- ✅ Improves maintainability
- ✅ Facilitates testing

**中文:**

软件实体应该对扩展开放，对修改关闭。应该能够在不更改现有代码的情况下添加新功能。

#### 2.1.3 Liskov Substitution Principle (LSP) | 里氏替换原则

**Definition**:
Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.

**超类的对象应该可以被子类的对象替换，而不影响程序的正确性。**

**Explanation**:
Subtypes must be substitutable for their base types. A subclass should extend, not replace, the behavior of the base class.

**Example - Violation | 违反示例**:
```java
// BAD: Square violates LSP
class Rectangle {
    protected int width;
    protected int height;
    
    public void setWidth(int width) { this.width = width; }
    public void setHeight(int height) { this.height = height; }
    
    public int getArea() { return width * height; }
}

class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width; // Forces height = width
    }
    
    @Override
    public void setHeight(int height) {
        this.width = height;  // Forces width = height
        this.height = height;
    }
}

// Problem:
void testRectangle(Rectangle rect) {
    rect.setWidth(5);
    rect.setHeight(4);
    assert rect.getArea() == 20; // Fails for Square!
}
```

**Example - Correct | 正确示例**:
```java
// GOOD: Use composition instead of inheritance
interface Shape {
    int getArea();
}

class Rectangle implements Shape {
    private int width;
    private int height;
    
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public int getArea() { return width * height; }
}

class Square implements Shape {
    private int side;
    
    public Square(int side) {
        this.side = side;
    }
    
    @Override
    public int getArea() { return side * side; }
}
```

**Benefits | 好处**:
- ✅ Ensures correct polymorphic behavior
- ✅ Prevents subtle bugs
- ✅ Improves code reliability
- ✅ Makes inheritance hierarchies more robust

**中文:**

超类的对象应该可以被子类的对象替换，而不影响程序的正确性。子类应该扩展而不是替换基类的行为。

#### 2.1.4 Interface Segregation Principle (ISP) | 接口隔离原则

**Definition**:
Clients should not be forced to depend on interfaces they do not use.

**客户端不应该被迫依赖它不使用的接口。**

**Explanation**:
Many client-specific interfaces are better than one general-purpose interface.

**Example - Violation | 违反示例**:
```java
// BAD: Fat interface forces unnecessary dependencies
interface Worker {
    void work();
    void eat();
    void sleep();
}

class HumanWorker implements Worker {
    @Override
    public void work() { /* work */ }
    @Override
    public void eat() { /* eat */ }
    @Override
    public void sleep() { /* sleep */ }
}

class RobotWorker implements Worker {
    @Override
    public void work() { /* work */ }
    @Override
    public void eat() { /* robot doesn't eat! */ }
    @Override
    public void sleep() { /* robot doesn't sleep! */ }
}
```

**Example - Correct | 正确示例**:
```java
// GOOD: Segregated interfaces
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

interface Sleepable {
    void sleep();
}

class HumanWorker implements Workable, Eatable, Sleepable {
    @Override
    public void work() { /* work */ }
    @Override
    public void eat() { /* eat */ }
    @Override
    public void sleep() { /* sleep */ }
}

class RobotWorker implements Workable {
    @Override
    public void work() { /* work */ }
}
```

**Benefits | 好处**:
- ✅ Reduces coupling
- ✅ Improves code clarity
- ✅ Easier to refactor
- ✅ Better separation of concerns

**中文:**

客户端不应该被迫依赖它不使用的接口。多个特定客户端接口优于一个通用接口。

#### 2.1.5 Dependency Inversion Principle (DIP) | 依赖倒置原则

**Definition**:
- High-level modules should not depend on low-level modules. Both should depend on abstractions.
- Abstractions should not depend on details. Details should depend on abstractions.

**高层模块不应该依赖低层模块。两者都应该依赖抽象。抽象不应该依赖细节。细节应该依赖抽象。**

**Example - Violation | 违反示例**:
```java
// BAD: High-level class depends on low-level concrete class
class MySQLDatabase {
    public void connect() { /* MySQL connection */ }
    public void query(String sql) { /* execute query */ }
}

class UserService {
    private MySQLDatabase database; // Tight coupling!
    
    public UserService() {
        this.database = new MySQLDatabase();
    }
    
    public void getUser(int id) {
        database.connect();
        database.query("SELECT * FROM users WHERE id=" + id);
    }
}
```

**Example - Correct | 正确示例**:
```java
// GOOD: Both depend on abstraction
interface Database {
    void connect();
    void query(String sql);
}

class MySQLDatabase implements Database {
    @Override
    public void connect() { /* MySQL connection */ }
    @Override
    public void query(String sql) { /* execute query */ }
}

class PostgreSQLDatabase implements Database {
    @Override
    public void connect() { /* PostgreSQL connection */ }
    @Override
    public void query(String sql) { /* execute query */ }
}

class UserService {
    private Database database; // Depend on abstraction
    
    public UserService(Database database) {
        this.database = database; // Dependency injection
    }
    
    public void getUser(int id) {
        database.connect();
        database.query("SELECT * FROM users WHERE id=" + id);
    }
}

// Usage:
Database db = new MySQLDatabase();
UserService service = new UserService(db);
```

**Benefits | 好处**:
- ✅ Reduces coupling
- ✅ Improves flexibility
- ✅ Easier to test (mocking)
- ✅ Facilitates dependency injection

**中文:**

高层模块不应该依赖低层模块，两者都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。

**SOLID Principles Summary | SOLID原则总结**:

| Principle<br/>原则    | Abbreviation<br/>缩写 | Key Idea<br/>核心思想                         | Pattern Example<br/>模式示例 |
| --------------------- | --------------------- | --------------------------------------------- | ---------------------------- |
| Single Responsibility | SRP                   | One reason to change<br/>一个变化原因         | Facade, Proxy                |
| Open-Closed           | OCP                   | Open for extension<br/>对扩展开放             | Strategy, Decorator          |
| Liskov Substitution   | LSP                   | Substitutable subtypes<br/>可替换的子类型     | All inheritance              |
| Interface Segregation | ISP                   | Client-specific interfaces<br/>特定客户端接口 | Adapter, Bridge              |
| Dependency Inversion  | DIP                   | Depend on abstractions<br/>依赖抽象           | Factory, Abstract Factory    |

**[Exam Focus | 考试重点]**: 
- Identify which SOLID principle is violated in code examples
- Explain how a specific design pattern supports a SOLID principle
- Refactor code to comply with SOLID principles

### 2.2 Other Important Principles | 其他重要原则

**English:**

#### Law of Demeter (LoD) | 迪米特法则

**Also known as**: Principle of Least Knowledge

**Definition**:
An object should only communicate with its immediate friends, not with strangers.

**规则**:
- A method M of object O can call methods of:
  1. O itself
  2. M's parameters
  3. Objects created within M
  4. O's direct component objects

**Example - Violation | 违反示例**:
```java
// BAD: Violates LoD (train wreck)
class Customer {
    public void purchase(Item item) {
        double price = item.getPrice();
        Wallet wallet = getWallet();
        if (wallet.getMoney().getAmount() >= price) {
            wallet.getMoney().subtract(price); // Talks to stranger!
        }
    }
}
```

**Example - Correct | 正确示例**:
```java
// GOOD: Tell, don't ask
class Customer {
    private Wallet wallet;
    
    public void purchase(Item item) {
        wallet.pay(item.getPrice()); // Delegate to immediate friend
    }
}

class Wallet {
    private Money money;
    
    public void pay(double amount) {
        if (money.isEnough(amount)) {
            money.subtract(amount);
        }
    }
}
```

#### Composite Reuse Principle (CRP) | 合成复用原则

**Definition**:
Favor object composition over class inheritance.

**优先使用对象组合而非类继承。**

**Rationale**:
- Inheritance is **white-box reuse**: Internal details visible to subclasses
- Composition is **black-box reuse**: Internal details hidden

**Example**:
```java
// PREFER THIS (Composition):
class Car {
    private Engine engine; // HAS-A relationship
    
    public void start() {
        engine.start();
    }
}

// OVER THIS (Inheritance):
class Car extends Engine { // IS-A relationship
    @Override
    public void start() {
        super.start();
    }
}
```

**中文:**

优先使用对象组合而非类继承。组合提供更大的灵活性和更好的封装。

**[Exam Focus | 考试重点]**: Understand when to use inheritance vs. composition. Recognize that many patterns (Decorator, Strategy, Proxy) use composition.

---

## Creational Patterns | 创建型模式

### 3.1 Singleton Pattern | 单例模式

**English:**

**Intent | 意图**:
Ensure a class has only one instance and provide a global point of access to it.

**确保一个类只有一个实例，并提供一个全局访问点。**

**Motivation | 动机**:
Some objects we only need one of: thread pools, caches, dialog boxes, objects that handle preferences and registry settings, logging, device drivers.

**Structure | 结构** (UML):
```
┌───────────────────┐
│    Singleton      │
├───────────────────┤
│ - instance        │◄──── static
├───────────────────┤
│ + getInstance()   │◄──── static
│ - Singleton()     │◄──── private constructor
└───────────────────┘
```

**Participants | 参与者**:
- **Singleton**: Defines getInstance() operation that lets clients access its unique instance

**Implementation Variants | 实现变体**:

**1. Eager Initialization | 饿汉式**:
```java
public class Singleton {
    // Instance created at class loading
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {
        // Private constructor
    }
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```

**Pros | 优点**: Thread-safe, simple  
**Cons | 缺点**: Instance created even if not used

**2. Lazy Initialization | 懒汉式 (Not Thread-Safe)**:
```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**Pros | 优点**: Lazy loading  
**Cons | 缺点**: Not thread-safe!

**3. Thread-Safe Lazy (Double-Checked Locking) | 双重检查锁定**:
```java
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) { // First check (no locking)
            synchronized (Singleton.class) {
                if (instance == null) { // Second check (with locking)
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**Pros | 优点**: Thread-safe, lazy loading, good performance  
**Cons | 缺点**: Complex, requires volatile keyword

**4. Bill Pugh Singleton (Initialization-on-demand) | 静态内部类**:
```java
public class Singleton {
    private Singleton() {}
    
    private static class SingletonHelper {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return SingletonHelper.INSTANCE;
    }
}
```

**Pros | 优点**: Thread-safe, lazy loading, no synchronization overhead, simple  
**Cons | 缺点**: Cannot pass parameters to constructor

**5. Enum Singleton (Recommended) | 枚举单例**:
```java
public enum Singleton {
    INSTANCE;
    
    public void doSomething() {
        // Business logic
    }
}

// Usage:
Singleton.INSTANCE.doSomething();
```

**Pros | 优点**: 
- ✅ Thread-safe
- ✅ Serialization-safe
- ✅ Prevents reflection attacks
- ✅ Simplest implementation

**Applicability | 适用性**:

Use Singleton when:
- ✅ There must be exactly one instance of a class
- ✅ The instance must be accessible from a well-known access point
- ✅ The sole instance should be extensible by subclassing

**Advantages | 优点**:
- ✓ Controlled access to sole instance
- ✓ Reduced namespace pollution
- ✓ Permits refinement of operations and representation
- ✓ Can be extended to control number of instances (e.g., object pool)

**Disadvantages | 缺点**:
- ✗ Violates Single Responsibility Principle
- ✗ Difficult to unit test (global state)
- ✗ Can mask poor design (overused as global variable)
- ✗ Multithreading issues if not implemented correctly

**Real-World Examples | 实际案例**:

```java
// Logger
public class Logger {
    private static volatile Logger instance;
    
    private Logger() {}
    
    public static Logger getInstance() {
        if (instance == null) {
            synchronized (Logger.class) {
                if (instance == null) {
                    instance = new Logger();
                }
            }
        }
        return instance;
    }
    
    public void log(String message) {
        System.out.println("[" + new Date() + "] " + message);
    }
}

// Usage:
Logger.getInstance().log("Application started");

// Configuration Manager
public class ConfigurationManager {
    private static ConfigurationManager instance;
    private Properties properties;
    
    private ConfigurationManager() {
        properties = new Properties();
        loadConfiguration();
    }
    
    public static synchronized ConfigurationManager getInstance() {
        if (instance == null) {
            instance = new ConfigurationManager();
        }
        return instance;
    }
    
    public String getProperty(String key) {
        return properties.getProperty(key);
    }
    
    private void loadConfiguration() {
        // Load from config file
    }
}
```

**Python Implementation | Python实现**:
```python
class Singleton:
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

# Or use metaclass:
class SingletonMeta(type):
    _instances = {}
    _lock = threading.Lock()
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            with cls._lock:
                if cls not in cls._instances:
                    instance = super().__call__(*args, **kwargs)
                    cls._instances[cls] = instance
        return cls._instances[cls]

class Singleton(metaclass=SingletonMeta):
    pass
```

**中文:**

**意图**: 确保一个类只有一个实例，并提供一个全局访问点。

**动机**: 某些对象我们只需要一个：线程池、缓存、对话框、处理偏好设置和注册表设置的对象、日志、设备驱动程序。

**[Exam Focus | 考试重点]**:
- Identify different Singleton implementations and their thread-safety
- Understand Double-Checked Locking and why `volatile` is needed
- Know when Singleton is appropriate vs. anti-pattern
- Recognize Singleton in code snippets
- Explain how to make Singleton serialization-safe

---

### 3.2 Factory Method Pattern | 工厂方法模式

**English:**

**Intent | 意图**:
Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

**定义一个用于创建对象的接口，但让子类决定实例化哪个类。工厂方法让类将实例化延迟到子类。**

**Motivation | 动机**:
Frameworks use abstract classes to define relationships between objects, but delegate the creation of specific objects to subclasses.

**Structure | 结构** (UML):
```
┌──────────────┐                    ┌──────────────┐
│   Creator    │                    │   Product    │
├──────────────┤                    ├──────────────┤
│ + operation()│                    │ + method()   │
│ + factoryMethod()│◄────creates────│              │
└──────┬───────┘                    └──────▲───────┘
       │                                   │
       │ creates                           │
       │                                   │
┌──────▼───────┐                    ┌──────┴───────┐
│ConcreteCreator│                   │ConcreteProduct│
├──────────────┤                    ├──────────────┤
│+factoryMethod()│────creates───────►│              │
└──────────────┘                    └──────────────┘
```

**Participants | 参与者**:
- **Product**: Interface for objects the factory method creates
- **ConcreteProduct**: Implements the Product interface
- **Creator**: Declares the factory method
- **ConcreteCreator**: Overrides factory method to return ConcreteProduct

**Implementation | 实现**:

```java
// Product interface
interface Document {
    void open();
    void close();
    void save();
}

// Concrete Products
class WordDocument implements Document {
    @Override
    public void open() { System.out.println("Opening Word document"); }
    @Override
    public void close() { System.out.println("Closing Word document"); }
    @Override
    public void save() { System.out.println("Saving Word document"); }
}

class PDFDocument implements Document {
    @Override
    public void open() { System.out.println("Opening PDF document"); }
    @Override
    public void close() { System.out.println("Closing PDF document"); }
    @Override
    public void save() { System.out.println("Saving PDF document"); }
}

// Creator
abstract class Application {
    // Factory method
    public abstract Document createDocument();
    
    public void newDocument() {
        Document doc = createDocument(); // Uses factory method
        doc.open();
        // Work with document
    }
}

// Concrete Creators
class WordApplication extends Application {
    @Override
    public Document createDocument() {
        return new WordDocument();
    }
}

class PDFApplication extends Application {
    @Override
    public Document createDocument() {
        return new PDFDocument();
    }
}

// Client code
public class Client {
    public static void main(String[] args) {
        Application app;
        
        // Decide which application to use
        String documentType = "word";
        
        if (documentType.equals(\"word\")) {
            app = new WordApplication();
        } else {
            app = new PDFApplication();
        }
        
        app.newDocument(); // Uses appropriate factory method
    }
}
```

**Applicability | 适用性**:

Use Factory Method when:
- ✅ A class can't anticipate the class of objects it must create
- ✅ A class wants its subclasses to specify the objects it creates
- ✅ Classes delegate responsibility to one of several helper subclasses

**Advantages | 优点**:
- ✓ Eliminates need to bind application-specific classes into code
- ✓ Provides hooks for subclasses (Template Method connection)
- ✓ Connects parallel class hierarchies

**Disadvantages | 缺点**:
- ✗ Requires creating subclass just to instantiate particular concrete class
- ✗ Can lead to class explosion

**Comparison: Factory Method vs. Simple Factory | 对比：工厂方法vs简单工厂**:

```java
// Simple Factory (NOT a pattern, but common technique)
class SimpleDocumentFactory {
    public static Document createDocument(String type) {
        if (type.equals(\"word\")) {
            return new WordDocument();
        } else if (type.equals(\"pdf\")) {
            return new PDFDocument();
        }
        throw new IllegalArgumentException(\"Unknown document type\");
    }
}

// Usage:
Document doc = SimpleDocumentFactory.createDocument(\"word\");
```

| Aspect<br/>方面                | Simple Factory<br/>简单工厂  | Factory Method<br/>工厂方法 |
| ------------------------------ | ---------------------------- | --------------------------- |
| **Complexity<br/>复杂度**      | Simple<br/>简单              | More complex<br/>更复杂     |
| **Flexibility<br/>灵活性**     | Less flexible<br/>灵活性较低 | More flexible<br/>更灵活    |
| **Extension<br/>扩展性**       | Modify factory<br/>修改工厂  | Add subclass<br/>添加子类   |
| **OCP Compliance<br/>OCP遵守** | Violates<br/>违反            | Complies<br/>遵守           |

**Real-World Example | 实际案例**:

```java
// Database connection factory
interface DatabaseConnection {
    void connect();
    void disconnect();
    void executeQuery(String sql);
}

class MySQLConnection implements DatabaseConnection {
    @Override
    public void connect() { /* MySQL connect */ }
    @Override
    public void disconnect() { /* MySQL disconnect */ }
    @Override
    public void executeQuery(String sql) { /* Execute in MySQL */ }
}

class PostgreSQLConnection implements DatabaseConnection {
    @Override
    public void connect() { /* PostgreSQL connect */ }
    @Override
    public void disconnect() { /* PostgreSQL disconnect */ }
    @Override
    public void executeQuery(String sql) { /* Execute in PostgreSQL */ }
}

abstract class DatabaseService {
    public abstract DatabaseConnection createConnection();
    
    public void performDatabaseOperation(String sql) {
        DatabaseConnection conn = createConnection();
        conn.connect();
        conn.executeQuery(sql);
        conn.disconnect();
    }
}

class MySQLService extends DatabaseService {
    @Override
    public DatabaseConnection createConnection() {
        return new MySQLConnection();
    }
}

class PostgreSQLService extends DatabaseService {
    @Override
    public DatabaseConnection createConnection() {
        return new PostgreSQLConnection();
    }
}
```

**中文:**

**意图**: 定义一个用于创建对象的接口，但让子类决定实例化哪个类。

**动机**: 框架使用抽象类定义对象间关系，但将特定对象的创建委托给子类。

**[Exam Focus | 考试重点]**:
- Distinguish Factory Method from Simple Factory and Abstract Factory
- Understand the relationship with Template Method pattern
- Identify when to use Factory Method vs. direct instantiation
- Recognize the pattern in frameworks (e.g., Java Collections, Spring Framework)

---

### 3.3 Abstract Factory Pattern | 抽象工厂模式

**English:**

**Intent | 意图**:
Provide an interface for creating families of related or dependent objects without specifying their concrete classes.

**提供一个接口用于创建相关或相互依赖的对象族，而无需指定它们的具体类。**

**Motivation | 动机**:
A GUI toolkit should support multiple look-and-feel standards (Windows, Mac, Linux). Different look-and-feels define different presentations and behaviors for widgets like scroll bars, windows, and buttons.

**Structure | 结构** (UML):
```
┌──────────────────┐         ┌────────────┐
│AbstractFactory   │         │AbstractProductA│
├──────────────────┤         └─────▲──────┘
│+createProductA() │               │
│+createProductB() │         ┌─────┴──────┐
└────────▲─────────┘         │ProductA1   │
         │                   └────────────┘
         │                   ┌────────────┐
┌────────┴─────────┐         │ProductA2   │
│ConcreteFactory1  │         └────────────┘
├──────────────────┤
│+createProductA() │────►    ┌────────────┐
│+createProductB() │         │AbstractProductB│
└──────────────────┘         └─────▲──────┘
┌──────────────────┐               │
│ConcreteFactory2  │         ┌─────┴──────┐
├──────────────────┤         │ProductB1   │
│+createProductA() │         └────────────┘
│+createProductB() │         ┌────────────┐
└──────────────────┘         │ProductB2   │
                             └────────────┘
```

**Participants | 参与者**:
- **AbstractFactory**: Declares interface for creating abstract products
- **ConcreteFactory**: Implements operations to create concrete products
- **AbstractProduct**: Declares interface for a type of product
- **ConcreteProduct**: Defines product to be created by corresponding concrete factory
- **Client**: Uses only interfaces declared by AbstractFactory and AbstractProduct

**Implementation | 实现**:

```java
// Abstract Products
interface Button {
    void paint();
}

interface Checkbox {
    void paint();
}

// Concrete Products - Windows family
class WindowsButton implements Button {
    @Override
    public void paint() {
        System.out.println(\"Rendering Windows button\");
    }
}

class WindowsCheckbox implements Checkbox {
    @Override
    public void paint() {
        System.out.println(\"Rendering Windows checkbox\");
    }
}

// Concrete Products - Mac family
class MacButton implements Button {
    @Override
    public void paint() {
        System.out.println(\"Rendering Mac button\");
    }
}

class MacCheckbox implements Checkbox {
    @Override
    public void paint() {
        System.out.println(\"Rendering Mac checkbox\");
    }
}

// Abstract Factory
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Concrete Factories
class WindowsFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }
    
    @Override
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

class MacFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacButton();
    }
    
    @Override
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}

// Client
class Application {
    private Button button;
    private Checkbox checkbox;
    
    public Application(GUIFactory factory) {
        button = factory.createButton();
        checkbox = factory.createCheckbox();
    }
    
    public void paint() {
        button.paint();
        checkbox.paint();
    }
}

// Usage
public class Demo {
    private static Application configureApplication() {
        Application app;
        GUIFactory factory;
        
        String osName = System.getProperty(\"os.name\").toLowerCase();
        if (osName.contains(\"mac\")) {
            factory = new MacFactory();
        } else {
            factory = new WindowsFactory();
        }
        
        app = new Application(factory);
        return app;
    }
    
    public static void main(String[] args) {
        Application app = configureApplication();
        app.paint();
    }
}
```

**Applicability | 适用性**:

Use Abstract Factory when:
- ✅ System should be independent of how its products are created
- ✅ System should be configured with one of multiple families of products
- ✅ Family of related products is designed to be used together
- ✅ You want to provide a class library and reveal only interfaces, not implementations

**Advantages | 优点**:
- ✓ Isolates concrete classes
- ✓ Makes exchanging product families easy
- ✓ Promotes consistency among products

**Disadvantages | 缺点**:
- ✗ Supporting new kinds of products is difficult (violates OCP)
- ✗ Increased complexity

**Real-World Example | 实际案例**:

```java
// Database factory for different vendors
interface Connection {
    void connect();
    void disconnect();
}

interface Command {
    void execute(String sql);
}

interface DataReader {
    void read();
}

// Abstract Factory
interface DatabaseFactory {
    Connection createConnection();
    Command createCommand();
    DataReader createDataReader();
}

// SQL Server family
class SqlServerConnection implements Connection {
    public void connect() { /* SQL Server connect */ }
    public void disconnect() { /* SQL Server disconnect */ }
}

class SqlServerCommand implements Command {
    public void execute(String sql) { /* Execute in SQL Server */ }
}

class SqlServerDataReader implements DataReader {
    public void read() { /* Read from SQL Server */ }
}

class SqlServerFactory implements DatabaseFactory {
    public Connection createConnection() {
        return new SqlServerConnection();
    }
    public Command createCommand() {
        return new SqlServerCommand();
    }
    public DataReader createDataReader() {
        return new SqlServerDataReader();
    }
}

// Oracle family
class OracleConnection implements Connection {
    public void connect() { /* Oracle connect */ }
    public void disconnect() { /* Oracle disconnect */ }
}

class OracleCommand implements Command {
    public void execute(String sql) { /* Execute in Oracle */ }
}

class OracleDataReader implements DataReader {
    public void read() { /* Read from Oracle */ }
}

class OracleFactory implements DatabaseFactory {
    public Connection createConnection() {
        return new OracleConnection();
    }
    public Command createCommand() {
        return new OracleCommand();
    }
    public DataReader createDataReader() {
        return new OracleDataReader();
    }
}

// Client
class DatabaseClient {
    private Connection connection;
    private Command command;
    private DataReader reader;
    
    public DatabaseClient(DatabaseFactory factory) {
        connection = factory.createConnection();
        command = factory.createCommand();
        reader = factory.createDataReader();
    }
    
    public void performOperation(String sql) {
        connection.connect();
        command.execute(sql);
        reader.read();
        connection.disconnect();
    }
}
```

**中文:**

**意图**: 提供一个接口用于创建相关或相互依赖的对象族，而无需指定它们的具体类。

**动机**: GUI工具包应支持多种外观标准（Windows、Mac、Linux）。不同的外观为滚动条、窗口和按钮等组件定义不同的呈现和行为。

**[Exam Focus | 考试重点]**:
- Distinguish Abstract Factory from Factory Method
- Understand \"family of products\" concept
- Recognize when to use Abstract Factory (multiple product dimensions)
- Identify the trade-off: difficult to add new products but easy to switch families

---

(由于篇幅限制,我将继续生成剩余的设计模式内容...)
