# System Reliability Metrics and Evaluation (系统可靠性指标与评估)

## 1. Fundamentals of Reliability (可靠性基础概念)

### 1.1 Definition and Importance (定义与重要性)

**Reliability** is the probability that a system or component will perform its required functions under stated conditions for a specified period of time.

**可靠性**是系统或组件在规定条件下、在规定时间内完成要求功能的概率。

**Mathematical Definition (数学定义):**

```
R(t) = P(T > t)

Where:
  R(t) = Reliability at time t (t时刻的可靠度)
  T = Time to failure (故障前时间)
  t = Specified time period (规定时间)
  P = Probability (概率)
```

**Key Characteristics (关键特征):**

1. **Probability-based (基于概率):**
   - 0 ≤ R(t) ≤ 1
   - R(0) = 1 (initially working - 初始工作状态)
   - R(∞) = 0 (eventually fails - 最终失效)

2. **Time-dependent (时间相关):**
   - Reliability decreases over time
   - 可靠性随时间递减

3. **Condition-specific (条件特定):**
   - Operating environment (工作环境)
   - Usage patterns (使用模式)
   - Maintenance practices (维护实践)

**Importance (重要性):**

```
Business Impact (业务影响):
┌─────────────────────────────────────────────────┐
│ • Customer satisfaction (客户满意度)            │
│ • Revenue loss from downtime (停机收入损失)     │
│ • Brand reputation (品牌声誉)                   │
│ • Regulatory compliance (法规合规)              │
│ • Safety and security (安全性)                  │
│ • Maintenance costs (维护成本)                  │
└─────────────────────────────────────────────────┘

Cost of Failure (故障成本):
- Direct costs: Repair, replacement (维修、更换)
- Indirect costs: Downtime, lost productivity
  间接成本：停机、生产力损失
- Consequential costs: Penalties, lawsuits
  后果成本：罚款、诉讼
```

### 1.2 Failure, Fault, and Error (故障、失效和错误)

**Terminology Clarification (术语澄清):**

```
┌──────────────────────────────────────────────────┐
│ Fault (故障) → Error (错误) → Failure (失效)     │
└──────────────────────────────────────────────────┘

Fault (故障):
- Defect or flaw in the system (系统中的缺陷或瑕疵)
- Cause of error (错误的原因)
- May be latent (dormant) (可能是潜在的)
- Example: Software bug, hardware defect
  示例：软件缺陷、硬件缺陷

Error (错误):
- Incorrect internal state (错误的内部状态)
- Manifestation of fault (故障的表现)
- May or may not lead to failure (可能导致或不导致失效)
- Example: Wrong calculation, corrupted data
  示例：错误计算、损坏数据

Failure (失效):
- Deviation from required function (偏离要求功能)
- Observable to user (用户可观察到的)
- Impact on service (影响服务)
- Example: System crash, incorrect output
  示例：系统崩溃、输出错误
```

**Failure Classification (失效分类):**

| Type                     | Description                 | Example       |
| ------------------------ | --------------------------- | ------------- |
| **Complete Failure**     | Total loss of function      | 系统完全崩溃  |
| **Partial Failure**      | Degraded performance        | 性能降低      |
| **Intermittent Failure** | Occasional malfunction      | 间歇性故障    |
| **Permanent Failure**    | Requires repair/replacement | 需要维修/更换 |

### 1.3 Reliability vs Other Quality Attributes (可靠性与其他质量属性)

**1. Reliability vs Availability (可靠性 vs 可用性):**

```
Reliability (可靠性):
- Probability of no failure (无故障概率)
- Decreases over time (随时间递减)
- R(t) = e^(-λt)

Availability (可用性):
- Probability of being operational (运行概率)
- Steady-state metric (稳态指标)
- A = MTBF / (MTBF + MTTR)

Relationship (关系):
High Reliability → High Availability (generally)
高可靠性 → 高可用性（通常）

But: High Availability ≠ High Reliability
但是：高可用性 ≠ 高可靠性
(Fast repair can mask poor reliability)
(快速修复可以掩盖低可靠性)
```

**2. Reliability vs Safety (可靠性 vs 安全性):**

```
Reliability (可靠性):
- Focus: Avoiding failures (避免故障)
- Metric: MTBF, R(t)
- Concern: All failures (所有故障)

Safety (安全性):
- Focus: Avoiding hazardous failures (避免危险故障)
- Metric: PFD (Probability of Failure on Demand)
  按需失效概率
- Concern: Safety-critical failures only
  仅关注安全关键故障

Overlap (重叠):
Reliable system is safer (more predictable)
可靠的系统更安全（更可预测）

Difference (差异):
Safe system may fail often (fail-safe design)
安全系统可能经常失效（故障安全设计）
```

**3. Reliability vs Maintainability (可靠性 vs 可维护性):**

```
Reliability (可靠性):
- Time between failures (故障间隔时间)
- Design quality (设计质量)
- MTBF metric (MTBF指标)

Maintainability (可维护性):
- Time to restore function (恢复功能时间)
- Serviceability (可维修性)
- MTTR metric (MTTR指标)

Combined Impact (综合影响):
Availability = f(Reliability, Maintainability)
可用性 = f(可靠性, 可维护性)

Trade-off (权衡):
High reliability may reduce maintainability
高可靠性可能降低可维护性
(Complex redundancy, hard to diagnose)
(复杂冗余，难以诊断)
```

### 1.4 Bathtub Curve (浴盆曲线)

**Failure Rate Over Time (失效率随时间变化):**

```
Failure Rate λ(t) (失效率)
    ↑
    │
    │ ╲                                  ╱
    │  ╲                                ╱
    │   ╲                              ╱
    │    ╲____________________________╱
    │     Early    │    Useful    │  Wear-out
    │    Failure   │     Life     │   Period
    │    早期失效  │  有效寿命期  │  耗损期
    │              │              │
    └──────────────┴──────────────┴──────────→ Time (t)
        Burn-in    │   Constant   │  Aging
        磨合期     │   失效率     │  老化
```

**Three Periods (三个阶段):**

**1. Early Failure Period (Infant Mortality) (早期失效期):**

```
Characteristics (特征):
- Decreasing failure rate (失效率递减)
- λ(t) decreases with time
- Duration: Days to months (持续时间：天到月)

Causes (原因):
✗ Design flaws (设计缺陷)
✗ Manufacturing defects (制造缺陷)
✗ Installation errors (安装错误)
✗ Inadequate quality control (质量控制不足)
✗ Contamination (污染)

Mitigation (缓解措施):
✓ Burn-in testing (老化测试)
✓ Environmental Stress Screening (ESS)
  环境应力筛选
✓ Improved quality control (改进质量控制)
✓ Better manufacturing processes
  更好的制造工艺
✓ Design reviews (设计评审)

Mathematical Model (数学模型):
λ(t) = α × β × t^(β-1)
where β < 1 (其中 β < 1)
```

**2. Useful Life Period (Random Failure) (有效寿命期):**

```
Characteristics (特征):
- Constant failure rate (恒定失效率)
- λ(t) = λ (constant)
- Duration: Years (持续时间：年)
- Exponential distribution (指数分布)

Causes (原因):
• Random events (随机事件)
• External stresses (外部应力)
• Operating errors (操作错误)
• Unpredictable failures (不可预测的故障)

Mitigation (缓解措施):
✓ Redundancy design (冗余设计)
✓ Preventive maintenance (预防性维护)
✓ Environmental control (环境控制)
✓ Operator training (操作员培训)
✓ Fault tolerance (容错)

Mathematical Model (数学模型):
R(t) = e^(-λt)
MTTF = 1/λ
λ(t) = λ (constant)
```

**3. Wear-out Period (耗损失效期):**

```
Characteristics (特征):
- Increasing failure rate (失效率递增)
- λ(t) increases with time
- Duration: Varies (持续时间：变化)

Causes (原因):
✗ Physical wear (物理磨损)
✗ Fatigue (疲劳)
✗ Corrosion (腐蚀)
✗ Aging (老化)
✗ Creep (蠕变)
✗ Degradation (退化)

Mitigation (缓解措施):
✓ Scheduled replacement (定期更换)
✓ Condition-based maintenance (基于状态的维护)
✓ Overhaul (大修)
✓ Life extension programs (延寿计划)
✓ Retirement planning (退役规划)

Mathematical Model (数学模型):
λ(t) = γ × δ × t^(δ-1)
where δ > 1 (其中 δ > 1)
Weibull distribution (威布尔分布)
```

**Bathtub Curve Equation (浴盆曲线方程):**

```
Complete failure rate function:
完整失效率函数：

λ(t) = λ_early(t) + λ_useful + λ_wearout(t)

     = α·β·t^(β-1) + λ_0 + γ·δ·t^(δ-1)

Where:
  α, β: Early failure parameters (早期失效参数)
  λ_0: Constant failure rate (恒定失效率)
  γ, δ: Wear-out parameters (耗损参数)
```

---

## 2. Core Reliability Metrics (核心可靠性指标)

### 2.1 MTTF (Mean Time To Failure) (平均故障前时间)

**Definition (定义):**

**MTTF** is the expected time until the first failure of a non-repairable system.

**MTTF**是不可修复系统首次失效前的预期时间。

**Formula (公式):**

```
MTTF = ∫₀^∞ R(t) dt

For exponential distribution (指数分布):
MTTF = 1/λ

Where:
  λ = Failure rate (失效率)
  R(t) = Reliability function (可靠度函数)
```

**Calculation from Data (从数据计算):**

```
MTTF = Σ(Operating time to failure) / Number of units tested
     = (t₁ + t₂ + ... + tₙ) / n

Example (示例):
Test 10 light bulbs until failure:
测试10个灯泡直到失效：

Failure times (hours): 1200, 1350, 980, 1450, 1100, 
                       1280, 1050, 1380, 1220, 1150

MTTF = (1200+1350+980+1450+1100+1280+1050+1380+1220+1150) / 10
     = 12160 / 10
     = 1216 hours
```

**Key Points (关键点):**

```
✓ Applicable to non-repairable systems (适用于不可修复系统)
  - Light bulbs (灯泡)
  - Batteries (电池)
  - Disposable components (一次性组件)

✓ Represents expected lifetime (代表预期寿命)

✓ Not the median lifetime (非中位寿命)
  - For exponential distribution:
    Median = MTTF × ln(2) ≈ 0.693 × MTTF

✗ Does NOT mean "half will fail by MTTF"
  不意味着"一半会在MTTF时失效"
```

### 2.2 MTBF (Mean Time Between Failures) (平均故障间隔时间)

**Definition (定义):**

**MTBF** is the expected time between consecutive failures of a repairable system.

**MTBF**是可修复系统连续故障之间的预期时间。

**Formula (公式):**

```
MTBF = Total operating time / Number of failures

MTBF = MTTF + MTTR

Where:
  MTTF = Mean Time To Failure (平均故障前时间)
  MTTR = Mean Time To Repair (平均修复时间)

For systems with short MTTR:
对于MTTR很短的系统：
MTBF ≈ MTTF
```

**Calculation Example (计算示例):**

```python
# Scenario: 5 servers running for 1 year
# 场景：5台服务器运行1年

servers = 5
days = 365
hours_per_day = 24
total_time = servers * days * hours_per_day  # 43,800 hours

failures = 12  # Total failures in the year

MTBF = total_time / failures
     = 43,800 / 12
     = 3,650 hours
     = 152 days

# Interpretation (解释):
# On average, expect one failure every 3,650 hours
# 平均每3650小时发生一次故障
```

**MTBF vs MTTF (对比):**

| Aspect               | MTTF                | MTBF             |
| -------------------- | ------------------- | ---------------- |
| **System Type**      | Non-repairable      | Repairable       |
| **系统类型**         | 不可修复            | 可修复           |
| **Measurement**      | Until first failure | Between failures |
| **测量**             | 直到首次失效        | 故障之间         |
| **Includes Repair?** | No                  | Yes (MTTR)       |
| **包含修复?**        | 否                  | 是 (MTTR)        |
| **Example**          | Light bulb          | Server           |
| **示例**             | 灯泡                | 服务器           |

**Common Misconceptions (常见误解):**

```
✗ Myth: "MTBF is the expected lifetime"
  误区："MTBF是预期寿命"
  
✓ Reality: MTBF is the average interval between failures
  实际：MTBF是故障之间的平均间隔
  
✗ Myth: "50% fail by MTBF time"
  误区："50%会在MTBF时间失效"
  
✓ Reality: For exponential distribution, 
           63.2% fail by MTTF (≈MTBF)
  实际：对于指数分布，63.2%在MTTF时失效
```

### 2.3 MTTR (Mean Time To Repair) (平均修复时间)

**Definition (定义):**

**MTTR** is the average time required to repair a failed system and restore it to operational status.

**MTTR**是修复故障系统并恢复到运行状态所需的平均时间。

**Formula (公式):**

```
MTTR = Total repair time / Number of repairs

MTTR = Σ(Individual repair times) / n
```

**Components of MTTR (MTTR组成):**

```
MTTR = Detection + Diagnosis + Acquisition + Repair + Verification
       检测时间   诊断时间   获取备件     修复时间  验证时间

┌────────────────────────────────────────────────────┐
│ 1. Detection Time (故障检测时间)                   │
│    - Monitoring alerts (监控告警)                  │
│    - User reports (用户报告)                       │
│    - Time to notice failure (注意到故障的时间)     │
├────────────────────────────────────────────────────┤
│ 2. Diagnosis Time (故障诊断时间)                   │
│    - Fault isolation (故障隔离)                    │
│    - Root cause analysis (根因分析)                │
│    - Troubleshooting (故障排除)                    │
├────────────────────────────────────────────────────┤
│ 3. Acquisition Time (获取备件时间)                 │
│    - Spare parts availability (备件可用性)         │
│    - Logistics delay (物流延迟)                    │
├────────────────────────────────────────────────────┤
│ 4. Repair Time (实际修复时间)                      │
│    - Disassembly (拆卸)                            │
│    - Replacement (更换)                            │
│    - Reassembly (重新组装)                         │
├────────────────────────────────────────────────────┤
│ 5. Verification Time (验证时间)                    │
│    - Testing (测试)                                │
│    - Validation (验证)                             │
│    - Documentation (文档记录)                      │
└────────────────────────────────────────────────────┘
```

**Calculation Example (计算示例):**

```
Repair Record (维修记录):

Failure 1: 5 hours (2h diagnosis + 1h parts + 2h repair)
Failure 2: 3 hours (1h diagnosis + 0.5h parts + 1.5h repair)
Failure 3: 8 hours (3h diagnosis + 3h parts + 2h repair)
Failure 4: 4 hours (1h diagnosis + 1h parts + 2h repair)
Failure 5: 6 hours (2h diagnosis + 2h parts + 2h repair)

MTTR = (5 + 3 + 8 + 4 + 6) / 5
     = 26 / 5
     = 5.2 hours

Breakdown (分解):
- Average diagnosis: (2+1+3+1+2)/5 = 1.8h
- Average parts: (1+0.5+3+1+2)/5 = 1.5h
- Average repair: (2+1.5+2+2+2)/5 = 1.9h
```

**Reducing MTTR (降低MTTR):**

```
Strategies (策略):

1. Faster Detection (更快检测):
   ✓ Real-time monitoring (实时监控)
   ✓ Automated alerts (自动告警)
   ✓ Health checks (健康检查)

2. Faster Diagnosis (更快诊断):
   ✓ Better logging (更好的日志)
   ✓ Diagnostic tools (诊断工具)
   ✓ Runbooks (操作手册)
   ✓ Knowledge base (知识库)

3. Faster Acquisition (更快获取):
   ✓ Spare parts inventory (备件库存)
   ✓ Vendor SLAs (供应商SLA)
   ✓ Pre-positioned spares (预置备件)

4. Faster Repair (更快修复):
   ✓ Modular design (模块化设计)
   ✓ Hot-swappable components (热插拔组件)
   ✓ Trained personnel (训练有素的人员)
   ✓ Better tools (更好的工具)

5. Faster Verification (更快验证):
   ✓ Automated testing (自动化测试)
   ✓ Built-in diagnostics (内置诊断)
```

### 2.4 Availability (可用性)

**Definition (定义):**

**Availability** is the probability that a system is operational at any given time.

**可用性**是系统在任意给定时间处于运行状态的概率。

**Formula (公式):**

```
A = MTBF / (MTBF + MTTR)

  = Uptime / (Uptime + Downtime)

  = Operating time / Total time

Alternative form (替代形式):
A = 1 - (MTTR / (MTBF + MTTR))
```

**Types of Availability (可用性类型):**

**1. Inherent Availability (固有可用性):**

```
A_i = MTBF / (MTBF + MTTR)

Assumptions (假设):
- Only corrective maintenance (仅纠正性维护)
- Unlimited resources (无限资源)
- Ideal conditions (理想条件)

Use (用途):
- Design comparison (设计比较)
- Theoretical maximum (理论最大值)
```

**2. Achieved Availability (实现可用性):**

```
A_a = MTBM / (MTBM + M̄)

Where:
  MTBM = Mean Time Between Maintenance
         平均维护间隔时间
  M̄ = Mean maintenance time (including PM)
      平均维护时间（包括预防性维护）

Includes (包括):
- Preventive maintenance (预防性维护)
- Corrective maintenance (纠正性维护)
```

**3. Operational Availability (操作可用性):**

```
A_o = Uptime / (Uptime + Downtime)

Includes (包括):
- All downtime (所有停机时间)
- Logistics delays (物流延迟)
- Administrative time (管理时间)
- Training time (培训时间)

Most realistic measure (最现实的度量)
```

**"Nines" of Availability (可用性的"几个九"):**

```
┌────────────┬────────────┬──────────────────┬─────────────────┐
│ Availability│ Percentage │ Annual Downtime  │ Common Use Case │
│ 可用性      │ 百分比     │ 年停机时间       │ 常见用例        │
├────────────┼────────────┼──────────────────┼─────────────────┤
│ 90%        │ One Nine   │ 36.5 days        │ Personal sites  │
│            │ 一个九     │ 36.5天           │ 个人网站        │
├────────────┼────────────┼──────────────────┼─────────────────┤
│ 99%        │ Two Nines  │ 3.65 days        │ Small business  │
│            │ 两个九     │ 3.65天           │ 小型企业        │
├────────────┼────────────┼──────────────────┼─────────────────┤
│ 99.9%      │ Three Nines│ 8.76 hours       │ Enterprise apps │
│            │ 三个九     │ 8.76小时         │ 企业应用        │
├────────────┼────────────┼──────────────────┼─────────────────┤
│ 99.99%     │ Four Nines │ 52.6 minutes     │ Banking, Telecom│
│            │ 四个九     │ 52.6分钟         │ 银行、电信      │
├────────────┼────────────┼──────────────────┼─────────────────┤
│ 99.999%    │ Five Nines │ 5.26 minutes     │ Critical infra  │
│            │ 五个九     │ 5.26分钟         │ 关键基础设施    │
├────────────┼────────────┼──────────────────┼─────────────────┤
│ 99.9999%   │ Six Nines  │ 31.5 seconds     │ Life support    │
│            │ 六个九     │ 31.5秒           │ 生命支持        │
└────────────┴────────────┴──────────────────┴─────────────────┘

Calculation (计算):
Annual downtime = (1 - A) × 365 days × 24 hours
年停机时间 = (1 - A) × 365天 × 24小时
```

**Availability Calculation Example (可用性计算示例):**

```python
# Scenario (场景)
MTBF = 720  # hours (30 days)
MTTR = 4    # hours

# Calculate availability
A = MTBF / (MTBF + MTTR)
  = 720 / (720 + 4)
  = 720 / 724
  = 0.99448
  = 99.448%

# Annual downtime
downtime_hours = (1 - A) * 365 * 24
               = (1 - 0.99448) * 8760
               = 0.00552 * 8760
               = 48.36 hours
               = 2.01 days

print(f"Availability: {A*100:.3f}%")
print(f"Annual downtime: {downtime_hours:.2f} hours")

# What MTTR needed for 99.9%?
# 要达到99.9%需要什么MTTR?
target_A = 0.999
# A = MTBF / (MTBF + MTTR)
# MTTR = MTBF*(1-A)/A
required_MTTR = MTBF * (1 - target_A) / target_A
              = 720 * (1 - 0.999) / 0.999
              = 720 * 0.001 / 0.999
              = 0.72 hours
              = 43 minutes

print(f"MTTR needed for 99.9%: {required_MTTR:.2f} hours")
```

### 2.5 Reliability Function R(t) (可靠度函数)

**Definition (定义):**

**R(t)** is the probability that a system functions without failure until time t.

**R(t)**是系统在时间t之前无故障运行的概率。

**Mathematical Representation (数学表示):**

```
R(t) = P(T > t) = 1 - F(t)

Where:
  T = Random variable for time to failure
      故障时间的随机变量
  F(t) = Cumulative distribution function (CDF)
         累积分布函数
  F(t) = P(T ≤ t) = Failure probability
         失效概率
```

**Exponential Distribution (指数分布):**

```
Most common model for constant failure rate
恒定失效率最常用模型

R(t) = e^(-λt)

Where:
  λ = Failure rate (constant) (失效率 - 恒定)
  e = Euler's number ≈ 2.71828

Properties (性质):
1. R(0) = 1 (initially perfect - 初始完美)
2. R(∞) = 0 (eventually fails - 最终失效)
3. Memoryless property (无记忆性):
   P(T > t+s | T > t) = P(T > s)

MTTF = 1/λ

Example (示例):
λ = 0.001 failures/hour (失效率)

R(100) = e^(-0.001 × 100)
       = e^(-0.1)
       = 0.9048
       = 90.48%

R(1000) = e^(-0.001 × 1000)
        = e^(-1)
        = 0.3679
        = 36.79%

R(MTTF) = e^(-1) = 0.368 (always! - 总是!)
```

**Weibull Distribution (威布尔分布):**

```
More flexible, models various failure patterns
更灵活，可建模各种失效模式

R(t) = e^(-(t/η)^β)

Where:
  η (eta) = Scale parameter (characteristic life)
            尺度参数（特征寿命）
  β (beta) = Shape parameter (形状参数)

Shape Parameter Interpretation (形状参数解释):

β < 1: Early failure (decreasing failure rate)
       早期失效（失效率递减）
       Example: Infant mortality
       示例：早期失效期

β = 1: Random failure (constant failure rate)
       随机失效（恒定失效率）
       = Exponential distribution
       = 指数分布

β > 1: Wear-out failure (increasing failure rate)
       耗损失效（失效率递增）
       Example: Aging, fatigue
       示例：老化、疲劳

Common values (常见值):
- β = 0.5: Electronics early failure
- β = 1.0: Random failures
- β = 2.0: Mechanical wear
- β = 3.5: Fatigue failures
```

**Reliability Curve Examples (可靠度曲线示例):**

```python
import numpy as np
import matplotlib.pyplot as plt

t = np.linspace(0, 10, 1000)

# Exponential (β=1)
lambda_rate = 0.5
R_exp = np.exp(-lambda_rate * t)

# Weibull with different β
eta = 5
beta_values = [0.5, 1.0, 2.0, 3.0]

plt.figure(figsize=(12, 6))
plt.plot(t, R_exp, label='Exponential (β=1)', linewidth=2)

for beta in beta_values[:-1]:
    R_weibull = np.exp(-(t/eta)**beta)
    plt.plot(t, R_weibull, label=f'Weibull (β={beta})', linewidth=2)

plt.xlabel('Time (时间)', fontsize=12)
plt.ylabel('Reliability R(t) (可靠度)', fontsize=12)
plt.title('Reliability Functions (可靠度函数)', fontsize=14)
plt.grid(True, alpha=0.3)
plt.legend()
plt.ylim(0, 1.05)
plt.show()

# Interpretation (解释):
# β < 1: Curve above exponential (早期失效)
# β = 1: Exponential curve (随机失效)
# β > 1: Curve below exponential (耗损失效)
```

### 2.6 Failure Rate λ(t) (失效率)

**Definition (定义):**

**Failure rate** is the frequency with which an engineered system or component fails, expressed as failures per unit time.

**失效率**是工程系统或组件失效的频率，表示为单位时间内的失效次数。

**Mathematical Definition (数学定义):**

```
λ(t) = f(t) / R(t) = -dR(t)/dt / R(t)

Where:
  f(t) = Probability density function (PDF)
         概率密度函数
  R(t) = Reliability function (可靠度函数)

For exponential distribution (指数分布):
λ(t) = λ (constant - 恒定)

For Weibull distribution (威布尔分布):
λ(t) = (β/η) × (t/η)^(β-1)
```

**Units (单位):**

```
Common units (常见单位):
- Failures per hour (故障/小时)
- Failures per million hours (故障/百万小时)
- FIT (Failures In Time) = failures per 10⁹ hours
  FIT = 故障/10⁹小时

Conversion (转换):
λ = 0.001 failures/hour
  = 1000 failures/million hours
  = 1,000,000 FIT

Example (示例):
Component with 100 FIT:
λ = 100 / 10⁹ failures/hour
  = 10⁻⁷ failures/hour
MTTF = 1/λ = 10⁷ hours = 1141 years
```

**Relationship to MTBF (与MTBF的关系):**

```
For constant failure rate (恒定失效率):

λ = 1 / MTBF

MTBF = 1 / λ

Example (示例):
MTBF = 10,000 hours
λ = 1 / 10,000 = 0.0001 failures/hour

λ = 0.0002 failures/hour
MTBF = 1 / 0.0002 = 5,000 hours
```

**Failure Rate Variations (失效率变化):**

```
Constant Failure Rate (恒定失效率):
┌──────────────────────────────────┐
│ λ(t) = λ₀                        │
│                                  │
│ ────────────────────────          │
│                                  │
│ Exponential distribution         │
│ Most common assumption           │
└──────────────────────────────────┘

Decreasing Failure Rate (递减失效率):
┌──────────────────────────────────┐
│ λ(t)                             │
│ ╲                                │
│  ╲                               │
│   ╲────                          │
│                                  │
│ Early failure period             │
│ Weibull with β < 1               │
└──────────────────────────────────┘

Increasing Failure Rate (递增失效率):
┌──────────────────────────────────┐
│ λ(t)                             │
│                                  │
│                          ╱       │
│                    ╱╱            │
│         ────╱╱                   │
│                                  │
│ Wear-out period                  │
│ Weibull with β > 1               │
└──────────────────────────────────┘
```

---

## 3. Reliability Mathematical Models (可靠性数学模型)

### 3.1 Probability Distributions (概率分布)

**Key Concepts (关键概念):**

```
PDF (Probability Density Function) (概率密度函数):
f(t) = Probability that failure occurs at time t
     = 在时间t发生失效的概率

Properties (性质):
• f(t) ≥ 0 for all t
• ∫₀^∞ f(t) dt = 1

CDF (Cumulative Distribution Function) (累积分布函数):
F(t) = P(T ≤ t) = ∫₀^t f(x) dx
     = Probability of failure by time t
     = 时间t之前失效的概率

Properties (性质):
• F(0) = 0
• F(∞) = 1
• F(t) is non-decreasing

Reliability Function (可靠度函数):
R(t) = 1 - F(t) = P(T > t)
     = Probability of survival beyond time t
     = 时间t之后存活的概率

Hazard Function (Failure Rate) (危险函数 - 失效率):
λ(t) = f(t) / R(t)
     = Instantaneous failure rate at time t
     = 时间t的瞬时失效率
```

### 3.2 Exponential Distribution (指数分布)

**Most Important Distribution in Reliability (可靠性中最重要的分布)**

**PDF:**
```
f(t) = λe^(-λt),  t ≥ 0

Where:
  λ = Constant failure rate (恒定失效率)
  e = Euler's number
```

**CDF:**
```
F(t) = 1 - e^(-λt)
```

**Reliability:**
```
R(t) = e^(-λt)
```

**Failure Rate:**
```
λ(t) = λ (constant - 恒定)
```

**MTTF:**
```
MTTF = 1/λ

Proof (证明):
MTTF = ∫₀^∞ t·f(t) dt
     = ∫₀^∞ t·λe^(-λt) dt
     = [-te^(-λt)]₀^∞ + ∫₀^∞ e^(-λt) dt
     = 0 + [-1/λ·e^(-λt)]₀^∞
     = 1/λ
```

**Memoryless Property (无记忆性):**

```
P(T > t+s | T > t) = P(T > s)

Meaning (含义):
The probability of surviving additional time s
is independent of how long it has already survived.

存活额外时间s的概率与已经存活多长时间无关。

Example (示例):
A component that has worked for 1000 hours
has the same probability of working another
100 hours as a brand new component.

已工作1000小时的组件在未来100小时工作的概率
与全新组件相同。

Mathematical proof (数学证明):
P(T > t+s | T > t) = P(T > t+s) / P(T > t)
                   = e^(-λ(t+s)) / e^(-λt)
                   = e^(-λs)
                   = P(T > s) ✓
```

**Applications (应用):**

```
Suitable for (适用于):
✓ Electronic components (电子元件)
✓ Software reliability (random bugs)
  软件可靠性（随机缺陷）
✓ Systems in useful life period
  有效寿命期的系统

NOT suitable for (不适用于):
✗ Mechanical wear-out (机械磨损)
✗ Aging effects (老化效应)
✗ Early failure period (早期失效期)
```

### 3.3 Weibull Distribution (威布尔分布)

**Most Versatile Distribution (最通用的分布)**

**Three-Parameter Weibull (三参数威布尔):**

```
f(t) = (β/η)((t-γ)/η)^(β-1) exp(-((t-γ)/η)^β),  t ≥ γ

Where:
  β = Shape parameter (形状参数)
  η = Scale parameter (尺度参数)
  γ = Location parameter (位置参数)

Two-Parameter Weibull (γ=0) (二参数威布尔):
f(t) = (β/η)(t/η)^(β-1) exp(-(t/η)^β),  t ≥ 0
```

**Reliability Function:**
```
R(t) = exp(-(t/η)^β)
```

**Failure Rate:**
```
λ(t) = (β/η)(t/η)^(β-1)
```

**Shape Parameter β Interpretation (形状参数β解释):**

```
β < 1: Decreasing failure rate (DFR)
       递减失效率
       
       λ(t) = (β/η)(t/η)^(β-1) decreases as t increases
       
       Applications (应用):
       • Early failure period (早期失效期)
       • Burn-in phase (磨合阶段)
       • Infant mortality (早期失效)
       
       Example: β = 0.5
       Early failures in electronics
       电子器件早期失效

β = 1: Constant failure rate (CFR)
       恒定失效率
       
       λ(t) = 1/η (constant)
       
       = Exponential distribution
       = 指数分布
       
       Applications (应用):
       • Useful life period (有效寿命期)
       • Random failures (随机失效)
       
       η = MTTF

β > 1: Increasing failure rate (IFR)
       递增失效率
       
       λ(t) = (β/η)(t/η)^(β-1) increases as t increases
       
       Applications (应用):
       • Wear-out period (耗损期)
       • Aging (老化)
       • Fatigue (疲劳)
       
       Example: β = 2.0
       Mechanical wear
       机械磨损
       
       Example: β = 3.5
       Fatigue failures
       疲劳失效
```

**Scale Parameter η (尺度参数):**

```
η = Characteristic life (特征寿命)

At t = η:
R(η) = e^(-1) = 0.368 = 36.8%

Meaning (含义):
63.2% of units fail by time η
63.2%的单元在时间η之前失效

Relationship to MTTF:
MTTF = η × Γ(1 + 1/β)

Where Γ is the Gamma function
其中Γ是伽马函数

Examples (示例):
β = 1: MTTF = η
β = 2: MTTF = η × √π/2 ≈ 0.886η
β = 3: MTTF ≈ 0.893η
```

**Weibull Analysis (威布尔分析):**

```python
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt

# Failure time data (故障时间数据)
failure_times = np.array([
    100, 150, 180, 200, 220, 250, 280, 300, 
    350, 400, 450, 500, 550, 600, 700, 800
])

# Weibull fit (威布尔拟合)
shape, loc, scale = stats.weibull_min.fit(failure_times, floc=0)

print("=== Weibull Parameters ===")
print(f"Shape (β): {shape:.3f}")
print(f"Scale (η): {scale:.1f}")

# Interpretation
if shape < 1:
    failure_mode = "Decreasing failure rate (Early failure)"
    failure_mode_cn = "递减失效率（早期失效）"
elif abs(shape - 1) < 0.1:
    failure_mode = "Constant failure rate (Random failure)"
    failure_mode_cn = "恒定失效率（随机失效）"
else:
    failure_mode = "Increasing failure rate (Wear-out)"
    failure_mode_cn = "递增失效率（耗损）"

print(f"\nFailure Mode: {failure_mode}")
print(f"失效模式: {failure_mode_cn}")

# Calculate MTTF
from scipy.special import gamma
mttf = scale * gamma(1 + 1/shape)
print(f"\nMTTF: {mttf:.1f}")

# Plot
t = np.linspace(0, max(failure_times)*1.5, 1000)
R_weibull = np.exp(-(t/scale)**shape)

plt.figure(figsize=(12, 5))

# Reliability plot
plt.subplot(1, 2, 1)
plt.plot(t, R_weibull, 'b-', linewidth=2)
plt.xlabel('Time (时间)')
plt.ylabel('Reliability R(t) (可靠度)')
plt.title(f'Weibull Reliability (β={shape:.2f}, η={scale:.0f})')
plt.grid(True, alpha=0.3)

# Failure rate plot
lambda_t = (shape/scale) * (t/scale)**(shape-1)
plt.subplot(1, 2, 2)
plt.plot(t, lambda_t, 'r-', linewidth=2)
plt.xlabel('Time (时间)')
plt.ylabel('Failure Rate λ(t) (失效率)')
plt.title('Failure Rate Function')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

---

## 4. System Reliability Modeling (系统可靠性建模)

### 4.1 Series System (串联系统)

**Definition (定义):**

A **series system** fails if ANY component fails. All components must work for the system to work.

**串联系统**在任一组件失效时失效。所有组件都必须工作系统才能工作。

**Reliability Formula (可靠性公式):**

```
R_sys = R₁ × R₂ × R₃ × ... × Rₙ

R_sys = ∏(i=1 to n) R_i

For n identical components (n个相同组件):
R_sys = R^n
```

**Failure Rate (失效率):**

```
For exponential distribution (指数分布):

λ_sys = λ₁ + λ₂ + λ₃ + ... + λₙ

λ_sys = Σ(i=1 to n) λ_i

For n identical components:
λ_sys = n × λ

MTBF_sys = 1/λ_sys = 1/(n×λ) = MTBF/n
```

**Example (示例):**

```python
# Three modules in series (三个模块串联)
R1 = 0.95  # Module 1 reliability
R2 = 0.98  # Module 2 reliability
R3 = 0.97  # Module 3 reliability

R_sys = R1 * R2 * R3
      = 0.95 × 0.98 × 0.97
      = 0.9029
      = 90.29%

# System reliability is LESS than any component!
# 系统可靠性低于任何组件！

print(f"Individual reliabilities: {R1}, {R2}, {R3}")
print(f"System reliability: {R_sys:.4f}")
print(f"Reliability reduction: {(1-R_sys)*100:.2f}%")

# With failure rates (使用失效率)
lambda1 = 0.001  # failures/hour
lambda2 = 0.0005
lambda3 = 0.0008

lambda_sys = lambda1 + lambda2 + lambda3
           = 0.0023 failures/hour

MTBF_sys = 1 / lambda_sys
         = 1 / 0.0023
         = 435 hours

print(f"\nSystem failure rate: {lambda_sys} failures/hour")
print(f"System MTBF: {MTBF_sys:.1f} hours")
```

**Output:**
```
Individual reliabilities: 0.95, 0.98, 0.97
System reliability: 0.9029
Reliability reduction: 9.71%

System failure rate: 0.0023 failures/hour
System MTBF: 434.8 hours
```

**Weakest Link Principle (最弱环节原理):**

```
The system is only as reliable as its weakest component.
系统的可靠性仅取决于其最弱的组件。

Example (示例):
Components: R₁=0.99, R₂=0.99, R₃=0.70, R₄=0.99

R_sys = 0.99 × 0.99 × 0.70 × 0.99
      = 0.682
      ≈ 0.70 (dominated by R₃)

Improvement strategy (改进策略):
Focus on improving the weakest component first!
优先改进最弱的组件！
```

**Implications (含义):**

```
✗ Adding components DECREASES reliability
  增加组件会降低可靠性

✓ Simplify design (fewer components = higher reliability)
  简化设计（更少组件 = 更高可靠性）

✓ Use high-quality components
  使用高质量组件

✓ Improve weakest components first
  优先改进最弱组件

✓ Consider redundancy for critical paths
  考虑关键路径的冗余
```

### 4.2 Parallel System (并联系统)

**Definition (定义):**

A **parallel system** works if AT LEAST ONE component works. All components must fail for the system to fail.

**并联系统**在至少一个组件工作时工作。所有组件都必须失效系统才会失效。

**Reliability Formula (可靠性公式):**

```
R_sys = 1 - (1-R₁) × (1-R₂) × ... × (1-Rₙ)

R_sys = 1 - ∏(i=1 to n) (1-R_i)

For n identical components (n个相同组件):
R_sys = 1 - (1-R)^n
```

**Example (示例):**

```python
# Dual redundancy (热备份)
R = 0.90  # Single component reliability

# No redundancy
R_single = 0.90

# Dual redundancy (2 parallel)
R_dual = 1 - (1-0.90)²
       = 1 - (0.10)²
       = 1 - 0.01
       = 0.99
       = 99%

# Triple redundancy (3 parallel)
R_triple = 1 - (1-0.90)³
         = 1 - (0.10)³
         = 1 - 0.001
         = 0.999
         = 99.9%

print("=== Parallel Redundancy Analysis ===")
print(f"Single component: {R_single:.3f}")
print(f"Dual redundancy:  {R_dual:.3f}  (+{(R_dual/R_single-1)*100:.1f}%)")
print(f"Triple redundancy: {R_triple:.3f}  (+{(R_triple/R_single-1)*100:.1f}%)")

# Diminishing returns (收益递减)
for n in range(1, 6):
    R_n = 1 - (1-0.90)**n
    improvement = (R_n - R_single) * 100
    print(f"n={n}: R={R_n:.5f}, Improvement={improvement:.3f}%")
```

**Output:**
```
=== Parallel Redundancy Analysis ===
Single component: 0.900
Dual redundancy:  0.990  (+10.0%)
Triple redundancy: 0.999  (+11.0%)

n=1: R=0.90000, Improvement=0.000%
n=2: R=0.99000, Improvement=9.000%
n=3: R=0.99900, Improvement=9.900%
n=4: R=0.99990, Improvement=9.990%
n=5: R=0.99999, Improvement=9.999%
```

**k-out-of-n System (n中取k系统):**

```
System works if AT LEAST k out of n components work.
如果n个组件中至少k个工作，系统就工作。

Reliability (可靠性):
R_sys = Σ(i=k to n) C(n,i) × R^i × (1-R)^(n-i)

Where:
  C(n,i) = n!/(i!(n-i)!) = Binomial coefficient
           二项式系数

Special cases (特殊情况):
- k=1: Full parallel (1-out-of-n)
       完全并联
- k=n: Series system (n-out-of-n)
       串联系统
```

**Example: 2-out-of-3 System (三取二系统):**

```python
from math import comb

R = 0.90
n = 3
k = 2

R_sys = 0
for i in range(k, n+1):
    term = comb(n, i) * (R**i) * ((1-R)**(n-i))
    R_sys += term
    print(f"i={i}: C({n},{i})×{R}^{i}×{1-R}^{n-i} = {term:.5f}")

print(f"\nR_sys (2-out-of-3) = {R_sys:.4f}")

# Comparison (对比)
R_series_3 = R**3  # 3-out-of-3 (串联)
R_parallel_3 = 1 - (1-R)**3  # 1-out-of-3 (并联)

print(f"\nComparison:")
print(f"3-out-of-3 (Series):   {R_series_3:.4f}")
print(f"2-out-of-3 (Voting):   {R_sys:.4f}")
print(f"1-out-of-3 (Parallel): {R_parallel_3:.4f}")
```

**Output:**
```
i=2: C(3,2)×0.9^2×0.1^1 = 0.24300
i=3: C(3,3)×0.9^3×0.1^0 = 0.72900

R_sys (2-out-of-3) = 0.9720

Comparison:
3-out-of-3 (Series):   0.7290
2-out-of-3 (Voting):   0.9720
1-out-of-3 (Parallel): 0.9990
```

### 4.3 Mixed Systems (混合系统)

**Series-Parallel Combinations (串并联组合):**

```
Example System (示例系统):

    ┌───[A]───┐
    │         │
[S]─┤         ├─[E]
    │         │
    └───[B]───┘
        │
    ┌───[C]───┐
    │         │
    ├─────────┤
    │         │
    └───[D]───┘

Subsystem 1: A and B in parallel (A和B并联)
R₁ = 1 - (1-RA)(1-RB)

Subsystem 2: C and D in parallel (C和D并联)
R₂ = 1 - (1-RC)(1-RD)

Overall: S → Subsystem1 → Subsystem2 → E (串联)
R_sys = RS × R₁ × R₂ × RE
```

**Calculation Example (计算示例):**

```python
# Component reliabilities
RS = 0.95
RA = 0.90
RB = 0.90
RC = 0.85
RD = 0.85
RE = 0.98

# Subsystem 1: A||B (parallel)
R1 = 1 - (1-RA)*(1-RB)
   = 1 - 0.1*0.1
   = 0.99

# Subsystem 2: C||D (parallel)
R2 = 1 - (1-RC)*(1-RD)
   = 1 - 0.15*0.15
   = 0.9775

# Overall system (series)
R_sys = RS * R1 * R2 * RE
      = 0.95 * 0.99 * 0.9775 * 0.98
      = 0.8993
      = 89.93%

print(f"Subsystem 1 (A||B): {R1:.4f}")
print(f"Subsystem 2 (C||D): {R2:.4f}")
print(f"System reliability: {R_sys:.4f}")

# Compare with all series
R_all_series = RS * RA * RB * RC * RD * RE
print(f"\nIf all series: {R_all_series:.4f}")
print(f"Improvement: {(R_sys/R_all_series-1)*100:.1f}%")
```

**混合系统的可靠性建模是实际工程中最常见的情况，需要综合运用串联和并联的计算方法。**

**混合系统可靠性建模是实际工程中最常见的情况，需要综合运用串联和并联的计算方法。**

---

#### 4.4 Bridge Structures 桥接结构

**Bridge structures represent a special case of reliability modeling where components are interconnected in a way that cannot be simplified to pure series or parallel configurations.**

**桥接结构代表一种特殊的可靠性建模情况，其中组件以无法简化为纯串联或并联配置的方式互连。**

**Bridge System Configuration:**
```
    A ---- B
    |\    /|
    | \  / |
    |  E   |
    | / \  |
    |/   \ |
    C ---- D
```

**Analysis Methods:**

1. **Event Space Method (事件空间法)**
   - Enumerate all success paths
   - Calculate probability for each path
   - Apply inclusion-exclusion principle

2. **Conditional Probability Method (条件概率法)**
   - Condition on a specific component (e.g., E)
   - Calculate R_sys = P(E works)×R_sys|E + P(E fails)×R_sys|¬E

3. **Minimal Path/Cut Sets (最小路径/割集法)**
   - Minimal paths: {A,B}, {A,E,D}, {C,E,B}, {C,D}
   - Minimal cut sets: {A,C}, {B,D}, {A,E,D}, {B,E,C}

**Example Calculation (假设所有组件可靠性为0.9):**

```python
# Conditional probability method
Re = 0.9  # Component E reliability
Ra = Rb = Rc = Rd = 0.9  # Other components

# If E works: A-E-D and C-E-B are parallel
R_E_works = 1 - (1 - Ra*Rb)*(1 - Rc*Rd)

# If E fails: System becomes (A||C) in series with (B||D)
R_E_fails = (1 - (1-Ra)*(1-Rc)) * (1 - (1-Rb)*(1-Rd))

# Total reliability
R_bridge = Re * R_E_works + (1-Re) * R_E_fails

print(f"Bridge reliability: {R_bridge:.4f}")
# Result: approximately 0.9747
```

**桥接结构需要使用条件概率或路径枚举方法进行分析，无法直接使用简单的串并联公式。**

**桥接结构需要使用条件概率或路径枚举方法进行分析，无法直接使用简单的串并联公式。**

---

#### 4.5 Reliability Block Diagram (RBD) 可靠性框图

**Reliability Block Diagram (RBD) is a graphical representation that shows the logical connection of components in a system from a reliability perspective.**

**可靠性框图(RBD)是一种图形表示方法，从可靠性角度显示系统中组件的逻辑连接。**

**Key Concepts:**

**1. RBD vs Physical Diagram (RBD与物理图的区别)**
   - RBD shows functional dependencies, not physical connections
   - Success-oriented (shows paths for system success)
   - Different from circuit diagrams or flowcharts

**2. Minimal Path Sets (最小路径集)**
   - A minimal set of components that must work for system success
   - No subset is also a path set
   - System works if ANY minimal path works

**3. Minimal Cut Sets (最小割集)**
   - A minimal set of components whose failure causes system failure
   - No subset is also a cut set
   - System fails if ANY minimal cut set fails

**4. Path-Cut Duality (路径-割集对偶性)**
   - Minimal paths in original system = Minimal cuts in dual system
   - Useful for complex system analysis

**Example: Communication System**

```
System: Two sites connected through multiple routers

Site A --[R1]--\           /--[R4]-- Site B
                \--[R3]--/
Site A --[R2]--/         \--[R5]-- Site B
```

**Minimal Paths:**
- {R1, R4}
- {R1, R3, R5}
- {R2, R3, R4}
- {R2, R5}

**Minimal Cuts:**
- {R1, R2}
- {R4, R5}
- {R1, R3, R5}
- {R2, R3, R4}

**System Reliability Calculation:**

```python
import numpy as np
from itertools import combinations

# Component reliabilities
R = {'R1': 0.95, 'R2': 0.95, 'R3': 0.90, 'R4': 0.95, 'R5': 0.95}

# Using minimal paths (upper bound)
def path_reliability(components, R):
    return np.prod([R[c] for c in components])

minimal_paths = [
    ['R1', 'R4'],
    ['R1', 'R3', 'R5'],
    ['R2', 'R3', 'R4'],
    ['R2', 'R5']
]

# Probability at least one path works (inclusion-exclusion)
path_probs = [path_reliability(p, R) for p in minimal_paths]

# Simplified upper bound (union bound)
R_upper = min(1.0, sum(path_probs))
print(f"Upper bound: {R_upper:.4f}")

# More accurate: inclusion-exclusion (complex for many paths)
# For this example, numerical methods or simulation recommended
```

**RBD Analysis Tools:**
- **Commercial software:** ReliaSoft BlockSim, Isograph Reliability Workbench
- **Open source:** OpenReliability, PyRBD
- **Features:** Automatic path/cut set generation, Monte Carlo simulation, sensitivity analysis

**RBD是系统可靠性建模的核心工具，通过路径集和割集分析可以全面评估系统可靠性。**

**RBD是系统可靠性建模的核心工具，通过路径集和割集分析可以全面评估系统可靠性。**

---

#### 4.6 Fault Tree Analysis (FTA) 故障树分析

**Fault Tree Analysis (FTA) is a top-down, deductive failure analysis method that uses Boolean logic to combine lower-level events.**

**故障树分析(FTA)是一种自顶向下的演绎故障分析方法，使用布尔逻辑组合低级事件。**

**Key Elements:**

**1. Top Event (顶事件)**
   - The undesired system-level failure being analyzed
   - Example: "System Unavailable", "Data Loss", "Safety Hazard"

**2. Logic Gates (逻辑门)**
   - **AND Gate:** Output occurs only if ALL inputs occur
   - **OR Gate:** Output occurs if ANY input occurs
   - **NOT Gate:** Output is complement of input
   - **XOR Gate:** Output if exactly one input occurs
   - **k-out-of-n Gate:** Output if k or more inputs occur
   - **Priority AND:** Inputs must occur in specific sequence
   - **Inhibit Gate:** Input with conditional condition

**3. Basic Events (基本事件)**
   - Lowest-level failures that cannot be decomposed further
   - Assigned failure probabilities or rates
   - Examples: Component failures, human errors, environmental factors

**4. Intermediate Events (中间事件)**
   - Events that result from combination of lower events
   - Become inputs to higher-level gates

**Example: Server System Fault Tree**

```
Top Event: "Web Service Unavailable"
              |
           [OR Gate]
         /     |     \
    Server   Network  Database
    Failure  Failure  Failure
       |        |        |
    [AND]    [OR]    [AND]
    /   \    / | \   /   \
  HW   SW  R1 R2 R3 DB   Disk
  Fail Fail Fail    Fail Fail
```

**Quantitative Analysis:**

```python
class FaultTreeAnalyzer:
    def __init__(self):
        self.basic_events = {}
    
    def add_basic_event(self, name, probability):
        self.basic_events[name] = probability
    
    def and_gate(self, *events):
        """Probability all events occur"""
        prob = 1.0
        for event in events:
            prob *= self.basic_events[event]
        return prob
    
    def or_gate(self, *events):
        """Probability at least one event occurs"""
        prob = 1.0
        for event in events:
            prob *= (1 - self.basic_events[event])
        return 1 - prob
    
    def not_gate(self, event):
        return 1 - self.basic_events[event]

# Example calculation
fta = FaultTreeAnalyzer()

# Basic event probabilities
fta.add_basic_event('HW_Fail', 0.01)
fta.add_basic_event('SW_Fail', 0.05)
fta.add_basic_event('R1_Fail', 0.02)
fta.add_basic_event('R2_Fail', 0.02)
fta.add_basic_event('R3_Fail', 0.02)
fta.add_basic_event('DB_Fail', 0.01)
fta.add_basic_event('Disk_Fail', 0.03)

# Calculate intermediate events
server_failure = fta.and_gate('HW_Fail', 'SW_Fail')
network_failure = fta.or_gate('R1_Fail', 'R2_Fail', 'R3_Fail')
database_failure = fta.and_gate('DB_Fail', 'Disk_Fail')

# Top event (OR of three subsystem failures)
fta.basic_events['Server_Fail'] = server_failure
fta.basic_events['Network_Fail'] = network_failure
fta.basic_events['Database_Fail'] = database_failure

top_event_prob = fta.or_gate('Server_Fail', 'Network_Fail', 'Database_Fail')

print(f"Server failure: {server_failure:.6f}")
print(f"Network failure: {network_failure:.6f}")
print(f"Database failure: {database_failure:.6f}")
print(f"\nTop event (Service Unavailable): {top_event_prob:.6f}")
print(f"Service availability: {1-top_event_prob:.6f}")
```

**Minimal Cut Sets from FTA:**

A minimal cut set is a smallest combination of basic events that causes the top event.

```python
def find_minimal_cut_sets(fault_tree):
    """
    For the example above:
    Minimal cut sets for "Service Unavailable":
    1. {HW_Fail, SW_Fail} - Both server components fail
    2. {R1_Fail, R2_Fail, R3_Fail} - All routers fail
    3. {DB_Fail, Disk_Fail} - Both database components fail
    """
    minimal_cuts = [
        ['HW_Fail', 'SW_Fail'],
        ['R1_Fail', 'R2_Fail', 'R3_Fail'],
        ['DB_Fail', 'Disk_Fail']
    ]
    return minimal_cuts

# Importance measures
def birnbaum_importance(event, fta):
    """How much does event probability affect top event?"""
    # Calculate top event with P(event)=1
    original = fta.basic_events[event]
    fta.basic_events[event] = 1.0
    prob_1 = calculate_top_event(fta)
    
    # Calculate with P(event)=0
    fta.basic_events[event] = 0.0
    prob_0 = calculate_top_event(fta)
    
    # Restore
    fta.basic_events[event] = original
    
    return prob_1 - prob_0
```

**FTA Benefits:**
- Systematic identification of failure causes
- Quantitative risk assessment
- Identifies critical components (via importance measures)
- Communication tool for safety analysis
- Required by many safety standards (IEC 61508, ISO 26262)

**FTA是安全关键系统分析的核心工具，通过逻辑门组合和割集分析识别系统脆弱点。**

**FTA是安全关键系统分析的核心工具，通过逻辑门组合和割集分析识别系统脆弱点。**

---

#### 4.7 Event Tree Analysis (ETA) 事件树分析

**Event Tree Analysis (ETA) is a forward-looking, inductive method that examines possible outcomes following an initiating event.**

**事件树分析(ETA)是一种前瞻性的归纳方法，检查启动事件后的可能结果。**

**Structure:**

```
Initiating Event → Safety Function 1 → Safety Function 2 → Safety Function 3 → Outcome
                        |
                      Success ──→ Success ──→ Success ──→ Safe
                        |            |          |
                      Failure        |        Failure ──→ Minor damage
                                     |          |
                                   Failure ───→ Moderate damage
                                                 |
                                                Major damage
```

**Example: Data Center Power Failure**

```python
class EventTree:
    def __init__(self, initiating_event_freq):
        self.init_freq = initiating_event_freq
        self.scenarios = []
    
    def add_scenario(self, name, path_probabilities, consequence):
        """
        path_probabilities: list of (success/failure, probability) tuples
        """
        freq = self.init_freq
        for success, prob in path_probabilities:
            freq *= prob
        self.scenarios.append({
            'name': name,
            'frequency': freq,
            'consequence': consequence
        })
        return freq

# Initiating event: Utility power loss (2 times/year)
eta = EventTree(initiating_event_freq=2.0)

# Safety functions:
# 1. UPS activates (P_success = 0.99)
# 2. Backup generator starts (P_success = 0.95)
# 3. Emergency shutdown succeeds (P_success = 0.999)

# Scenario 1: All systems work
freq1 = eta.add_scenario(
    "No impact",
    [(True, 0.99)],  # UPS works
    consequence="None"
)

# Scenario 2: UPS fails, generator works
freq2 = eta.add_scenario(
    "Brief interruption",
    [(False, 0.01), (True, 0.95)],  # UPS fails, generator works
    consequence="Minor"
)

# Scenario 3: UPS and generator fail, emergency shutdown works
freq3 = eta.add_scenario(
    "Controlled shutdown",
    [(False, 0.01), (False, 0.05), (True, 0.999)],
    consequence="Moderate"
)

# Scenario 4: All safety functions fail
freq4 = eta.add_scenario(
    "Uncontrolled shutdown",
    [(False, 0.01), (False, 0.05), (False, 0.001)],
    consequence="Severe"
)

print("Event Tree Analysis Results:")
print(f"Initiating event frequency: {eta.init_freq}/year\n")

for scenario in eta.scenarios:
    print(f"{scenario['name']}:")
    print(f"  Frequency: {scenario['frequency']:.6f}/year")
    print(f"  Consequence: {scenario['consequence']}")
    print()
```

**Output:**
```
Event Tree Analysis Results:
Initiating event frequency: 2.0/year

No impact:
  Frequency: 1.980000/year
  Consequence: None

Brief interruption:
  Frequency: 0.019000/year
  Consequence: Minor

Controlled shutdown:
  Frequency: 0.000999/year
  Consequence: Moderate

Uncontrolled shutdown:
  Frequency: 0.000001/year
  Consequence: Severe
```

**ETA vs FTA Comparison:**

| Aspect             | ETA                  | FTA                   |
| ------------------ | -------------------- | --------------------- |
| **Direction**      | Forward (inductive)  | Backward (deductive)  |
| **Starting point** | Initiating event     | Top event (failure)   |
| **Purpose**        | Explore consequences | Find causes           |
| **Output**         | Accident scenarios   | Failure combinations  |
| **Logic**          | Sequential branching | Boolean logic gates   |
| **Best for**       | Dynamic sequences    | Static configurations |

**Combined Use:**

Often FTA and ETA are used together:
- ETA identifies scenarios
- FTA analyzes probability of each branch in ETA
- Example: Branch "Backup generator fails" in ETA can be detailed FTA

**事件树分析与故障树分析互补,前者探索后果,后者分析原因,常常结合使用进行全面风险评估。**

**事件树分析与故障树分析互补,前者探索后果,后者分析原因,常常结合使用进行全面风险评估。**

---

## 5. Redundancy and Fault Tolerance 冗余与容错

**Redundancy and fault tolerance are primary techniques for improving system reliability by providing alternative means of operation when failures occur.**

**冗余与容错是通过在故障发生时提供替代操作方式来提高系统可靠性的主要技术。**

### 5.1 Types of Redundancy 冗余类型

#### 5.1.1 Hardware Redundancy 硬件冗余

**Hardware redundancy involves duplicating physical components to provide backup capability.**

**硬件冗余涉及复制物理组件以提供备份能力。**

**1. Hot Standby (热备份)**
- Redundant component is powered on and synchronized
- Immediate takeover upon primary failure (milliseconds)
- Highest availability but highest cost
- Both components age simultaneously

**Example:**
```python
class HotStandby:
    def __init__(self, primary_reliability, standby_reliability, switch_reliability=0.999):
        self.Rp = primary_reliability
        self.Rs = standby_reliability
        self.Rsw = switch_reliability
    
    def system_reliability(self):
        # System works if:
        # 1. Primary works, OR
        # 2. Primary fails AND (standby works AND switch works)
        R_sys = self.Rp + (1-self.Rp) * self.Rs * self.Rsw
        return R_sys

# Example: Primary R=0.90, Standby R=0.90, Switch R=0.999
hs = HotStandby(0.90, 0.90, 0.999)
print(f"Hot standby reliability: {hs.system_reliability():.6f}")
# Result: 0.989910 (98.99%)

# Compare with no redundancy
print(f"Single component: {0.90:.6f}")
print(f"Improvement: {(hs.system_reliability()/0.90 - 1)*100:.2f}%")
```

**2. Warm Standby (温备份)**
- Standby component is powered but not fully synchronized
- Takeover time: seconds to minutes
- Lower power consumption than hot standby
- Reduced aging of standby component

**3. Cold Standby (冷备份)**
- Standby component is powered off until needed
- Longest takeover time (minutes to hours)
- Minimal aging, lowest power consumption
- Risk of activation failure

**Reliability Comparison:**
```python
import numpy as np
import matplotlib.pyplot as plt

def standby_reliability(t, lambda_primary, lambda_standby, switching_time, standby_type):
    """
    standby_type: 'hot', 'warm', 'cold'
    switching_time: time to activate standby
    """
    if standby_type == 'hot':
        # Both age from t=0
        R = 1 - (1 - np.exp(-lambda_primary*t)) * (1 - np.exp(-lambda_standby*t))
    elif standby_type == 'warm':
        # Standby ages at reduced rate (e.g., 50%)
        lambda_s_reduced = lambda_standby * 0.5
        R = 1 - (1 - np.exp(-lambda_primary*t)) * (1 - np.exp(-lambda_s_reduced*t))
    else:  # cold
        # Standby doesn't age until activated
        # Simplified model
        R = np.exp(-lambda_primary*t) + \
            (1 - np.exp(-lambda_primary*t)) * np.exp(-lambda_standby*switching_time)
    return R

# Plot comparison
t = np.linspace(0, 10000, 1000)
lambda_p = 0.0001  # per hour
lambda_s = 0.0001

R_hot = standby_reliability(t, lambda_p, lambda_s, 0, 'hot')
R_warm = standby_reliability(t, lambda_p, lambda_s, 1, 'warm')
R_cold = standby_reliability(t, lambda_p, lambda_s, 10, 'cold')
R_single = np.exp(-lambda_p*t)

print(f"At t=5000 hours:")
print(f"  Single: {R_single[500]:.6f}")
print(f"  Hot standby: {R_hot[500]:.6f}")
print(f"  Warm standby: {R_warm[500]:.6f}")
print(f"  Cold standby: {R_cold[500]:.6f}")
```

**热备份提供最高可用性但成本最高,冷备份成本最低但切换时间最长,需要根据实际需求选择合适的备份策略。**

**热备份提供最高可用性但成本最高,冷备份成本最低但切换时间最长,需要根据实际需求选择合适的备份策略。**

#### 5.1.2 Software Redundancy 软件冗余

**Software redundancy uses diverse implementations to avoid common-mode failures.**

**软件冗余使用多样化实现来避免共模故障。**

**1. N-Version Programming (N版本编程)**
- Multiple independent implementations of same specification
- Voting on outputs to detect and mask errors
- Protects against design faults

**Example:**
```python
class NVersionProgramming:
    def __init__(self, versions):
        """
        versions: list of functions implementing same spec
        """
        self.versions = versions
    
    def execute_with_voting(self, *args):
        results = []
        for version in self.versions:
            try:
                result = version(*args)
                results.append(result)
            except Exception as e:
                results.append(None)
        
        # Majority voting
        if len(results) >= 3:
            # Find most common result
            from collections import Counter
            counter = Counter([r for r in results if r is not None])
            if counter:
                most_common, count = counter.most_common(1)[0]
                if count >= (len(results) + 1) // 2:
                    return most_common
        
        # If no majority, return first valid result or raise error
        for r in results:
            if r is not None:
                return r
        raise Exception("All versions failed")

# Example: Three versions of a sorting algorithm
def sort_v1(arr):
    return sorted(arr)  # Built-in

def sort_v2(arr):
    # Bubble sort
    arr = arr.copy()
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

def sort_v3(arr):
    # Quick sort
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return sort_v3(left) + middle + sort_v3(right)

nvp = NVersionProgramming([sort_v1, sort_v2, sort_v3])
result = nvp.execute_with_voting([3, 1, 4, 1, 5, 9, 2, 6])
print(f"NVP result: {result}")
```

**2. Recovery Blocks (恢复块)**
- Primary algorithm with acceptance test
- If test fails, execute alternate algorithm
- Sequential rather than parallel execution

```python
class RecoveryBlock:
    def __init__(self, primary, alternates, acceptance_test):
        self.primary = primary
        self.alternates = alternates
        self.acceptance_test = acceptance_test
    
    def execute(self, *args):
        # Try primary
        try:
            result = self.primary(*args)
            if self.acceptance_test(result):
                return result
        except Exception:
            pass
        
        # Try alternates
        for alternate in self.alternates:
            try:
                result = alternate(*args)
                if self.acceptance_test(result):
                    return result
            except Exception:
                continue
        
        raise Exception("All blocks failed acceptance test")

# Example: Calculate square root
def sqrt_newton(x):
    """Newton's method"""
    if x < 0:
        raise ValueError("Negative input")
    guess = x / 2.0
    for _ in range(10):
        guess = (guess + x / guess) / 2.0
    return guess

def sqrt_binary(x):
    """Binary search method"""
    if x < 0:
        raise ValueError("Negative input")
    low, high = 0, x
    for _ in range(50):
        mid = (low + high) / 2.0
        if mid * mid > x:
            high = mid
        else:
            low = mid
    return (low + high) / 2.0

def acceptance_test(result):
    """Result should be non-negative"""
    return result >= 0

rb = RecoveryBlock(sqrt_newton, [sqrt_binary], acceptance_test)
result = rb.execute(16)
print(f"Square root of 16: {result}")
```

**3. Data Redundancy (数据冗余)**
- Checksums and hash codes
- Error detection codes (parity, CRC)
- Error correction codes (Hamming, Reed-Solomon)

**软件冗余通过多样化设计避免共模故障,N版本编程适用于安全关键系统,恢复块适用于性能敏感系统。**

**软件冗余通过多样化设计避免共模故障,N版本编程适用于安全关键系统,恢复块适用于性能敏感系统。**

#### 5.1.3 Time Redundancy 时间冗余

**Time redundancy performs operations multiple times to detect and correct transient faults.**

**时间冗余通过多次执行操作来检测和纠正瞬态故障。**

**Techniques:**

1. **Retry Mechanisms (重试机制)**
   - Automatic retry on failure
   - Exponential backoff to avoid overload
   - Maximum retry limits

```python
import time
import random

class RetryManager:
    def __init__(self, max_retries=3, base_delay=1.0, max_delay=60.0):
        self.max_retries = max_retries
        self.base_delay = base_delay
        self.max_delay = max_delay
    
    def execute_with_retry(self, func, *args, **kwargs):
        last_exception = None
        
        for attempt in range(self.max_retries + 1):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                
                if attempt < self.max_retries:
                    # Exponential backoff with jitter
                    delay = min(self.base_delay * (2 ** attempt), self.max_delay)
                    jitter = random.uniform(0, delay * 0.1)
                    sleep_time = delay + jitter
                    
                    print(f"Attempt {attempt+1} failed: {e}")
                    print(f"Retrying in {sleep_time:.2f} seconds...")
                    time.sleep(sleep_time)
        
        raise last_exception

# Example usage
def unreliable_network_call():
    """Simulates a network call that fails 70% of the time"""
    if random.random() < 0.7:
        raise ConnectionError("Network timeout")
    return "Success"

retry_mgr = RetryManager(max_retries=3, base_delay=0.5)

try:
    result = retry_mgr.execute_with_retry(unreliable_network_call)
    print(f"Result: {result}")
except Exception as e:
    print(f"Final failure: {e}")
```

2. **Watchdog Timers (看门狗定时器)**
   - Monitor task execution time
   - Reset or restart if timeout
   - Common in embedded systems

3. **Temporal Voting (时间投票)**
   - Execute same operation multiple times
   - Compare results across time
   - Detects transient errors

**时间冗余适用于瞬态故障,成本低但增加响应时间,常用于网络通信和嵌入式系统。**

**时间冗余适用于瞬态故障,成本低但增加响应时间,常用于网络通信和嵌入式系统。**

---

### 5.2 Active-Standby Configuration 主备模式

**Active-standby configuration is a common fault tolerance pattern where one component handles all traffic while another stands ready to take over.**

**主备模式是一种常见的容错模式,一个组件处理所有流量,另一个随时准备接管。**

**Key Design Considerations:**

**1. Heartbeat Mechanism (心跳机制)**
```python
import threading
import time

class HeartbeatMonitor:
    def __init__(self, timeout=5.0, check_interval=1.0):
        self.timeout = timeout
        self.check_interval = check_interval
        self.last_heartbeat = time.time()
        self.is_alive = True
        self.lock = threading.Lock()
    
    def send_heartbeat(self):
        with self.lock:
            self.last_heartbeat = time.time()
            self.is_alive = True
    
    def check_heartbeat(self):
        with self.lock:
            elapsed = time.time() - self.last_heartbeat
            if elapsed > self.timeout:
                self.is_alive = False
                return False
            return True
    
    def monitor_loop(self, on_failure_callback):
        while True:
            if not self.check_heartbeat():
                print("Heartbeat timeout detected!")
                on_failure_callback()
                break
            time.sleep(self.check_interval)

class ActiveStandbyCluster:
    def __init__(self):
        self.is_active = True
        self.heartbeat = HeartbeatMonitor(timeout=3.0)
        self.state = "ACTIVE"
    
    def promote_to_active(self):
        print("Promoting standby to active...")
        self.state = "ACTIVE"
        self.is_active = True
        # Initialize resources, load state, etc.
    
    def demote_to_standby(self):
        print("Demoting to standby...")
        self.state = "STANDBY"
        self.is_active = False
    
    def handle_request(self, request):
        if self.state == "ACTIVE":
            # Send heartbeat periodically
            self.heartbeat.send_heartbeat()
            return f"Processed by ACTIVE: {request}"
        else:
            return "Not active, cannot process"

# Usage example
active_node = ActiveStandbyCluster()
standby_node = ActiveStandbyCluster()
standby_node.demote_to_standby()

# Simulate failure and failover
def on_active_failure():
    standby_node.promote_to_active()

# Start monitoring in background
monitor_thread = threading.Thread(
    target=active_node.heartbeat.monitor_loop,
    args=(on_active_failure,),
    daemon=True
)
# monitor_thread.start()
```

**2. State Synchronization (状态同步)**
- Synchronous replication: Slow but consistent
- Asynchronous replication: Fast but risk of data loss
- Semi-synchronous: Balance between both

**3. Split-Brain Prevention (脑裂防护)**

Split-brain occurs when both nodes think they are active.

```python
class QuorumBasedFailover:
    def __init__(self, node_id, total_nodes):
        self.node_id = node_id
        self.total_nodes = total_nodes
        self.votes = set()
    
    def request_vote(self, from_node_id):
        """Another node requests this node's vote"""
        # Grant vote if not already voted
        if len(self.votes) == 0:
            self.votes.add(from_node_id)
            return True
        return False
    
    def try_become_active(self, peer_nodes):
        """Try to become active by getting majority votes"""
        votes_received = 1  # Vote for self
        self.votes.add(self.node_id)
        
        for peer in peer_nodes:
            if peer.request_vote(self.node_id):
                votes_received += 1
        
        majority = (self.total_nodes // 2) + 1
        if votes_received >= majority:
            print(f"Node {self.node_id} became active with {votes_received} votes")
            return True
        else:
            print(f"Node {self.node_id} failed to get majority ({votes_received}/{majority})")
            return False
```

**4. Failover Time (切换时间)**

Failover time = Detection time + Decision time + Recovery time

```python
class FailoverMetrics:
    def __init__(self):
        self.detection_time = 0
        self.decision_time = 0
        self.recovery_time = 0
    
    def calculate_total_failover_time(self):
        return self.detection_time + self.decision_time + self.recovery_time
    
    def calculate_availability_impact(self, mtbf_hours):
        """
        Calculate availability impact of failover time
        """
        total_failover_seconds = self.calculate_total_failover_time()
        mtbf_seconds = mtbf_hours * 3600
        
        # Downtime per failure
        availability = (mtbf_seconds - total_failover_seconds) / mtbf_seconds
        return availability

# Example
metrics = FailoverMetrics()
metrics.detection_time = 3.0  # seconds
metrics.decision_time = 0.5   # seconds
metrics.recovery_time = 1.5   # seconds

total = metrics.calculate_total_failover_time()
print(f"Total failover time: {total} seconds")

mtbf = 720  # hours (30 days)
avail = metrics.calculate_availability_impact(mtbf)
print(f"Availability with MTBF={mtbf}h and failover={total}s: {avail:.6f}")
print(f"This is: {avail*100:.4f}%")
```

**主备模式需要仔细设计心跳检测、状态同步和脑裂防护机制,切换时间直接影响系统可用性。**

**主备模式需要仔细设计心跳检测、状态同步和脑裂防护机制,切换时间直接影响系统可用性。**

---

### 5.3 Load Sharing Configuration 负载均衡模式

**Load sharing distributes work across multiple active components, providing both redundancy and increased capacity.**

**负载均衡将工作分配到多个活动组件上,既提供冗余又增加容量。**

**Common Patterns:**

**1. N+1 Redundancy**
- N components handle normal load
- 1 additional component for redundancy
- Each component operates at N/(N+1) capacity

```python
class LoadSharingCluster:
    def __init__(self, n_active, capacity_per_node, load):
        self.n_active = n_active
        self.capacity_per_node = capacity_per_node
        self.load = load
    
    def calculate_reliability(self, node_reliability, min_nodes_required):
        """
        System works if at least min_nodes_required nodes are working
        Using k-out-of-n formula
        """
        from math import comb
        
        R_sys = 0
        for k in range(min_nodes_required, self.n_active + 1):
            # Probability exactly k nodes work
            prob = comb(self.n_active, k) * \
                   (node_reliability ** k) * \
                   ((1 - node_reliability) ** (self.n_active - k))
            R_sys += prob
        
        return R_sys
    
    def analyze_configuration(self, node_reliability):
        total_capacity = self.n_active * self.capacity_per_node
        utilization = self.load / total_capacity
        
        # Minimum nodes to handle load
        min_nodes = int(np.ceil(self.load / self.capacity_per_node))
        
        R_sys = self.calculate_reliability(node_reliability, min_nodes)
        
        print(f"Configuration: {self.n_active} nodes")
        print(f"Total capacity: {total_capacity}")
        print(f"Load: {self.load}")
        print(f"Utilization: {utilization*100:.1f}%")
        print(f"Min nodes required: {min_nodes}")
        print(f"System reliability: {R_sys:.6f}")
        print(f"Can tolerate {self.n_active - min_nodes} failures\n")
        
        return R_sys

import numpy as np

# Compare different configurations
load = 400  # requests/sec
capacity = 100  # requests/sec per node
node_R = 0.95

print("Load Sharing Analysis:\n")

# 4+1 configuration (5 total, need 4)
config1 = LoadSharingCluster(5, capacity, load)
R1 = config1.analyze_configuration(node_R)

# 5+1 configuration (6 total, need 4)
config2 = LoadSharingCluster(6, capacity, load)
R2 = config2.analyze_configuration(node_R)

# 4+2 configuration (6 total, need 4) - same total but different perspective
print(f"Comparison: 5 nodes vs 6 nodes")
print(f"Reliability improvement: {(R2/R1 - 1)*100:.2f}%")
```

**2. Load Balancing Algorithms (负载均衡算法)**

```python
class LoadBalancer:
    def __init__(self, servers):
        self.servers = servers
        self.current_index = 0
        self.request_counts = {s: 0 for s in servers}
    
    def round_robin(self):
        """Simple round-robin"""
        server = self.servers[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.servers)
        return server
    
    def least_connections(self):
        """Route to server with fewest connections"""
        return min(self.request_counts, key=self.request_counts.get)
    
    def weighted_round_robin(self, weights):
        """Round-robin with server weights"""
        # More complex, based on server capacity
        total_weight = sum(weights)
        rand = random.randint(0, total_weight - 1)
        
        cumulative = 0
        for i, weight in enumerate(weights):
            cumulative += weight
            if rand < cumulative:
                return self.servers[i]
    
    def hash_based(self, client_id):
        """Consistent hashing for session affinity"""
        index = hash(client_id) % len(self.servers)
        return self.servers[index]

# Example
servers = ['Server1', 'Server2', 'Server3', 'Server4']
lb = LoadBalancer(servers)

print("Load balancing examples:")
for i in range(8):
    server = lb.round_robin()
    print(f"Request {i+1} -> {server}")
```

**3. Graceful Degradation (优雅降级)**

When some nodes fail, system continues at reduced capacity.

```python
class DegradableService:
    def __init__(self, max_capacity):
        self.max_capacity = max_capacity
        self.current_capacity = max_capacity
        self.service_levels = [
            (1.0, "Full service"),
            (0.75, "Reduced features"),
            (0.5, "Core features only"),
            (0.25, "Emergency mode"),
            (0.0, "Service unavailable")
        ]
    
    def on_node_failure(self, failed_capacity):
        self.current_capacity -= failed_capacity
        ratio = self.current_capacity / self.max_capacity
        
        # Determine service level
        for threshold, level in self.service_levels:
            if ratio >= threshold:
                print(f"Operating at {ratio*100:.0f}% capacity: {level}")
                return level
    
    def adjust_behavior(self, service_level):
        if service_level == "Full service":
            return {"rate_limit": None, "features": "all"}
        elif service_level == "Reduced features":
            return {"rate_limit": 0.75, "features": "core+premium"}
        elif service_level == "Core features only":
            return {"rate_limit": 0.5, "features": "core"}
        elif service_level == "Emergency mode":
            return {"rate_limit": 0.25, "features": "critical"}
        else:
            return {"rate_limit": 0, "features": "none"}

# Example
service = DegradableService(max_capacity=1000)

print("Graceful degradation simulation:")
service.on_node_failure(200)  # Lose 20%
service.on_node_failure(300)  # Lose another 30%
service.on_node_failure(300)  # Lose another 30%
```

**负载均衡模式提供冗余和扩展性,N+1配置在性能和可靠性间取得平衡,优雅降级确保部分故障时核心功能可用。**

**负载均衡模式提供冗余和扩展性,N+1配置在性能和可靠性间取得平衡,优雅降级确保部分故障时核心功能可用。**

---

### 5.4 Triple Modular Redundancy (TMR) 三模冗余

**Triple Modular Redundancy uses three identical components with a voting mechanism to mask single faults.**

**三模冗余使用三个相同的组件和投票机制来屏蔽单个故障。**

TMR是容错系统中的经典技术,通过三个相同组件并行执行相同任务,然后通过投票器对结果进行表决,只要有两个模块给出相同结果,系统就能正常工作。这种方法可以屏蔽单个模块的故障,广泛应用于航空航天、核电站控制等安全关键领域。TMR的可靠性计算公式为: R_TMR = 3R² - 2R³,当模块可靠性R>0.5时,TMR的可靠性高于单个模块。

---

## 7. Maintainability Metrics 可维护性指标

**Maintainability is the ability to perform maintenance activities efficiently and effectively.**

**可维护性是有效高效地执行维护活动的能力。**

### 7.1 MTTR and Downtime 平均修复时间与停机时间

MTTR(平均修复时间)由多个组成部分构成:

1. **故障检测时间** - 发现故障的时间
2. **故障定位时间** - 确定故障原因和位置
3. **获取备件时间** - 准备替换组件
4. **实际修复时间** - 更换或修理
5. **验证测试时间** - 确认修复效果

可维护性设计原则:
- **模块化设计** - 快速更换故障部件
- **故障自诊断** - 缩短定位时间
- **可测试性** - 简化检测过程
- **标准化接口** - 降低维护复杂度

### 7.2 Preventive vs Corrective Maintenance 预防性与纠正性维护

**预防性维护(PM)**: 定期检查和更换,避免故障发生
**纠正性维护(CM)**: 故障后的修复行动

维护策略选择需要权衡成本和效益。

---

## 8. Reliability Design Principles 可靠性设计原则

**Reliability must be designed in from the beginning, not tested in at the end.**

**可靠性必须从一开始就设计进去,而不是最后测试进去。**

### 8.1 FMEA and FMECA 故障模式影响分析

**FMEA** (Failure Mode and Effects Analysis) 系统分析每个组件的潜在故障模式及其影响。

**FMECA** (Failure Mode, Effects, and Criticality Analysis) 增加了关键度分析,评估故障的严重程度。

FMEA流程:
1. 识别潜在故障模式
2. 分析故障影响
3. 评估发生概率和严重度
4. 计算风险优先数(RPN)
5. 制定缓解措施

RPN = 严重度(S) × 发生频率(O) × 检测难度(D)

### 8.2 Derating and Safety Margins 降额使用与安全余量

**降额使用**是指组件在低于额定值的条件下工作:
- 电压降额: 工作电压 < 80% 额定电压
- 功率降额: 工作功率 < 50% 额定功率
- 温度降额: 工作温度 < 70% 最高工作温度

降额可显著提高组件可靠性和寿命。

### 8.3 Design for Reliability (DfR) 可靠性设计

DfR核心原则:
1. **简化设计** - 减少组件数量
2. **冗余设计** - 关键功能备份
3. **容错设计** - 故障自动恢复
4. **强壮性设计** - 耐受环境变化
5. **可维护性** - 易于维护和修复

---

## 9. Software Reliability 软件可靠性

**Software reliability is the probability of failure-free operation over a specified period in a specified environment.**

**软件可靠性是在指定环境中、在指定时间内无故障运行的概率。**

### 9.1 Software vs Hardware Reliability 软件与硬件可靠性对比

**关键差异**:
- 软件无物理老化,故障源于设计缺陷
- 软件不遵循浴盆曲线,失效率不是恒定的
- 软件可复制,但每个实例包含相同缺陷
- 修复软件可能引入新缺陷

### 9.2 Software Reliability Models 软件可靠性模型

**常用模型**:

1. **Jelinski-Moranda Model** - 假设固定数量的缺陷,每次修复减少一个
2. **Goel-Okumoto Model** - 非齐次泊松过程(NHPP)模型
3. **Musa Execution Time Model** - 基于执行时间而非日历时间

### 9.3 Software Testing and Quality 软件测试与质量

软件可靠性提升方法:
- **代码审查** - 发现设计缺陷
- **单元测试** - 验证模块功能
- **集成测试** - 检查模块间交互
- **系统测试** - 验证整体功能
- **回归测试** - 确保修复未引入新问题

代码覆盖率指标:
- 语句覆盖率 > 80%
- 分支覆盖率 > 70%
- 关键路径100%覆盖

---

## 10. Practical Applications and Case Studies 实际应用与案例

**Real-world examples demonstrate how reliability principles are applied in various industries.**

**实际案例展示了可靠性原理在各行业的应用。**

### 10.1 High-Availability Systems 高可用性系统

**云计算平台可用性目标**:
- **99.9% ("Three Nines")** - 允许每年停机8.76小时
- **99.99% ("Four Nines")** - 允许每年停机52.56分钟
- **99.999% ("Five Nines")** - 允许每年停机5.26分钟
- **99.9999% ("Six Nines")** - 允许每年停机31.56秒

实现高可用性的关键技术:
1. **地理分布** - 多数据中心、多可用区
2. **负载均衡** - 流量分发到多个实例
3. **自动故障转移** - 快速切换到备用系统
4. **健康监控** - 持续检测系统状态
5. **数据备份** - 实时同步和定期备份

### 10.2 SLA and Reliability Requirements SLA与可靠性需求

**服务级别协议(SLA)示例**:

| 服务类型 | 可用性目标 | 月度停机时间 | 响应时间 |
| -------- | ---------- | ------------ | -------- |
| 关键业务 | 99.99%     | 4.38分钟     | <100ms   |
| 一般业务 | 99.9%      | 43.8分钟     | <500ms   |
| 内部系统 | 99.5%      | 3.65小时     | <2s      |

SLA通常包括:
- 可用性承诺
- 性能目标
- 故障响应时间
- 维护窗口
- 赔偿条款

### 10.3 Industry Standards 行业标准

**重要可靠性标准**:

1. **IEC 61508** - 电气/电子/可编程电子安全相关系统功能安全
   - 定义SIL(Safety Integrity Level) 1-4级
   - SIL 4: 最高安全等级 (10⁻⁵ 到 10⁻⁴ 每小时危险故障概率)

2. **ISO 26262** - 道路车辆功能安全
   - 定义ASIL(Automotive SIL) A-D级
   - ASIL D: 最高汽车安全等级

3. **DO-178C** - 机载系统和设备认证中的软件考虑
   - 定义软件等级A-E
   - Level A: 灾难性，故障可能导致飞机坏损或人员伤亡

4. **MIL-STD-882** - 系统安全要求
   - 军用系统安全标准

### 10.4 Case Study: AWS Availability Zones 案例: AWS可用区

Amazon Web Services通过地理分布实现高可用性:

**架构设计**:
- 每个区域(Region)包含多个可用区(AZ)
- 每个AZ是独立的数据中心,有独立的电力、冷却、网络
- AZ之间低延迟互联(<2ms)
- 地理隔离防止共同模式故障

**可靠性计算**:
- 单个AZ可用性: 99.9%
- 两个AZ部署: 1-(1-0.999)² = 99.9999% (6个9)
- 三个AZ部署: 1-(1-0.999)³ = 99.999999% (8个9)

**最佳实践**:
- 关键应用部署在至少两个AZ
- 使用ELB(负载均衡)分发流量
- 数据实时同步到多个AZ
- 自动故障转移和自动扩展

---

## 11. Conclusion 总结

**System reliability is a critical quality attribute that must be addressed throughout the entire product lifecycle.**

**系统可靠性是一个关键的质量属性,必须在整个产品生命周期中得到解决。**

### Key Takeaways 关键要点

**1. Core Metrics 核心指标**
- MTTF, MTBF, MTTR是可靠性量化的基础
- 可用性 A = MTBF/(MTBF+MTTR) 平衡可靠性和可维护性
- 失效率和可靠度函数描述时间上的变化

**2. Mathematical Models 数学模型**
- 指数分布适用于随机故障(恒定失效率)
- 威布尔分布适用于各种失效模式(通过形状参数控制)
- 马尔可夫模型适用于状态转移系统

**3. System Modeling 系统建模**
- 串联系统:可靠性为各组件之积
- 并联系统:提供冗余,显著提高可靠性
- RBD和FTA是互补的分析工具

**4. Redundancy and Fault Tolerance 冗余与容错**
- 硬件冗余:热/温/冷备份有不同的性能和成本
- 软件冗余:N版本编程和恢复块防设计缺陷
- TMR适用于安全关键系统,但成本高

**5. Assessment Methods 评估方法**
- 预测提供设计阶段估计,但需要验证
- 分配确保子系统目标支持总体目标
- 测试验证实际可靠性
- 增长管理持续改进可靠性

**6. Design Principles 设计原则**
- FMEA/FMECA系统识别和缓解风险
- 降额使用和安全余量提高组件可靠性
- DfR将可靠性融入设计过程

**7. Software Reliability 软件可靠性**
- 软件故障源于设计缺陷,非物理老化
- 代码质量、测试覆盖率直接影响可靠性
- 版本控制和回归测试防止退化

**8. Practical Applications 实际应用**
- 高可用性系统需要多层次冗余
- SLA将技术指标转化为商业承诺
- 行业标准(IEC 61508, ISO 26262, DO-178C)提供指导

### Future Trends 未来趋势

**1. AI and Machine Learning for Reliability 人工智能与可靠性**
- 预测性维护:使用ML预测故障
- 异常检测:自动识别非正常行为
- 故障根因分析:智能诊断系统

**2. Cloud-Native Reliability 云原生可靠性**
- 混沌工程(Chaos Engineering)
- 服务网格(Service Mesh)
- 可观测性(Observability)

**3. Edge Computing Reliability 边缘计算可靠性**
- 分布式决策
- 自主故障恢复
- 资源受限环境下的高可靠性

**4. Sustainability and Reliability 可持续性与可靠性**
- 能效优化与可靠性的平衡
- 延长产品生命周期
- 循环经济与可维修性

### Final Thoughts 最后思考

**Reliability is not just a technical requirement—it is a business imperative and a moral obligation, especially in safety-critical systems.**

**可靠性不仅仅是技术要求——它是商业命令和道德义务,尤其是在安全关键系统中。**

Key success factors for reliability:
1. **Design for reliability from the start** - 从一开始就考虑可靠性
2. **Measure and monitor continuously** - 持续测量和监控
3. **Learn from failures** - 从故障中学习
4. **Balance cost and reliability** - 平衡成本和可靠性
5. **Follow industry standards** - 遵循行业标准
6. **Maintain a reliability culture** - 培养可靠性文化

**Remember**: A highly reliable system is the result of systematic engineering, rigorous testing, continuous improvement, and unwavering commitment to quality.

**记住**:高度可靠的系统是系统工程、严格测试、持续改进和对质量坚定承诺的结果。

---

## References 参考文献

1. MIL-HDBK-217F: "Military Handbook: Reliability Prediction of Electronic Equipment"
2. IEC 61508: "Functional Safety of Electrical/Electronic/Programmable Electronic Safety-related Systems"
3. ISO 26262: "Road vehicles — Functional safety"
4. Reliability Engineering Handbook by Kececioglu, D.
5. Practical Reliability Engineering by O'Connor, P. and Kleyner, A.
6. Software Reliability Engineering by Lyu, M.
7. System Reliability Theory by Rausand, M. and Høyland, A.
8. Design for Reliability by Dev G. Raheja and Louis J. Gullo

---

**Document Version**: 1.0  
**Last Updated**: 2025  
**Author**: System Reliability Expert (Based on CRISPE Framework)  

**文档版本**: 1.0  
**最后更新**: 2025年  
**作者**: 系统可靠性专家(基于CRISPE框架)  

---

**END OF DOCUMENT / 文档结束**
