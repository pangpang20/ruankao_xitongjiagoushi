# Encryption and Decryption (加密和解密)

## 1. Fundamentals of Cryptography (密码学基础概念)

### 1.1 Definition and Objectives (定义与目标)

**Cryptography** is the science and art of designing systems and protocols to protect information from unauthorized access, ensuring confidentiality, integrity, authenticity, and non-repudiation.

**密码学**是设计系统和协议以保护信息免受未经授权访问的科学和艺术，确保机密性、完整性、真实性和不可否认性。

**Core Objectives (核心目标):**

1. **Confidentiality (机密性):** Ensuring that information is accessible only to authorized parties.
   - 确保信息只能被授权方访问

2. **Integrity (完整性):** Ensuring that information has not been altered during storage or transmission.
   - 确保信息在存储或传输过程中未被篡改

3. **Authentication (认证性):** Verifying the identity of the parties involved in communication.
   - 验证通信参与方的身份

4. **Non-repudiation (不可否认性):** Ensuring that a party cannot deny having performed an action.
   - 确保一方不能否认其执行过某个操作

### 1.2 Basic Terminology (基本术语)

**Plaintext (明文):** The original, unencrypted message or data.
- 原始的、未加密的消息或数据

**Ciphertext (密文):** The encrypted version of the plaintext.
- 明文的加密版本

**Encryption (加密):** The process of converting plaintext into ciphertext using an algorithm and a key.
- 使用算法和密钥将明文转换为密文的过程

**Decryption (解密):** The process of converting ciphertext back into plaintext using a key.
- 使用密钥将密文转换回明文的过程

**Key (密钥):** A parameter used in the encryption/decryption algorithm.
- 用于加密/解密算法的参数

**Cipher (密码算法):** A cryptographic algorithm for encryption and decryption.
- 用于加密和解密的密码算法

**Cryptanalysis (密码分析):** The study of breaking cryptographic systems.
- 研究破解密码系统的学科

### 1.3 Kerckhoffs's Principle (Kerckhoffs原则)

**Principle Statement (原则陈述):**

"A cryptosystem should be secure even if everything about the system, except the key, is public knowledge."

"即使密码系统的所有内容（除了密钥）都是公开的，该系统也应该是安全的。"

**Implications (含义):**
- Security relies on the secrecy of the key, not the algorithm (安全性依赖于密钥的保密性，而非算法)
- Algorithms should be publicly reviewed to ensure robustness (算法应公开审查以确保健壮性)
- Proprietary "security through obscurity" is discouraged (不鼓励专有的"通过隐蔽实现安全")

### 1.4 Types of Cryptanalysis (密码分析类型)

| Attack Type       | Attacker's Knowledge               | 攻击类型       | 攻击者的知识       |
| ----------------- | ---------------------------------- | -------------- | ------------------ |
| Ciphertext-only   | Only ciphertext                    | 唯密文攻击     | 仅有密文           |
| Known-plaintext   | Plaintext-ciphertext pairs         | 已知明文攻击   | 明文-密文对        |
| Chosen-plaintext  | Can encrypt chosen plaintexts      | 选择明文攻击   | 可加密选择的明文   |
| Chosen-ciphertext | Can decrypt chosen ciphertexts     | 选择密文攻击   | 可解密选择的密文   |
| Adaptive chosen   | Can adapt choices based on results | 自适应选择攻击 | 可根据结果调整选择 |

### 1.5 Computational vs Information-Theoretic Security (计算安全性vs信息论安全性)

**Computational Security (计算安全性):**
- Secure if breaking it is computationally infeasible with current technology
- 如果用当前技术破解在计算上不可行，则是安全的
- Examples: RSA, AES (示例: RSA, AES)

**Information-Theoretic Security (Perfect Security) (信息论安全性/完美安全性):**
- Secure even against adversaries with unlimited computational power
- 即使对抗具有无限计算能力的对手也是安全的
- Example: One-Time Pad (示例: 一次性密码本)

---

## 2. Symmetric Encryption Algorithms (对称加密算法)

### 2.1 Symmetric Encryption Principles (对称加密原理)

**Definition (定义):**
Symmetric encryption uses the same key for both encryption and decryption.

对称加密使用相同的密钥进行加密和解密。

**Process (流程):**
```
Encryption: C = E(K, P)
Decryption: P = D(K, C)
Where: K = secret key, P = plaintext, C = ciphertext
```

**Characteristics (特点):**
- ✓ Fast encryption/decryption (加密/解密速度快)
- ✓ Suitable for large data volumes (适合大数据量)
- ✗ Key distribution problem (密钥分发问题)
- ✗ Requires secure key exchange channel (需要安全的密钥交换通道)

### 2.2 Block Ciphers vs Stream Ciphers (分组密码vs流密码)

**Block Cipher (分组密码):**
- Encrypts fixed-size blocks of plaintext (加密固定大小的明文块)
- Typically 64 or 128 bits per block (通常每块64或128位)
- Examples: DES, AES, 3DES

**Stream Cipher (流密码):**
- Encrypts data bit-by-bit or byte-by-byte (逐位或逐字节加密数据)
- Uses a keystream generated from the key (使用从密钥生成的密钥流)
- Examples: RC4, ChaCha20

### 2.3 DES (Data Encryption Standard)

**Overview (概述):**
- Developed by IBM in the 1970s (1970年代由IBM开发)
- Adopted as US federal standard in 1977 (1977年被采纳为美国联邦标准)
- Block size: 64 bits (分组大小: 64位)
- Key size: 56 bits (effective) + 8 parity bits (密钥大小: 56位有效位 + 8位奇偶校验位)

**Feistel Network Structure (Feistel网络结构):**

```
┌─────────────────────────────────────┐
│      64-bit Plaintext Input         │
└─────────────────────────────────────┘
           ↓
    Initial Permutation (IP)
           ↓
    ┌──────┴──────┐
    │  L0  │  R0  │ (32 bits each)
    └──────┬──────┘
           ↓
    ┌─────────────┐
    │  16 Rounds  │
    │  ┌────────┐ │
    │  │ Round 1│ │  L1 = R0
    │  │ Round 2│ │  R1 = L0 ⊕ f(R0, K1)
    │  │  ...   │ │
    │  │Round 16│ │
    │  └────────┘ │
    └──────┬──────┘
           ↓
    Final Permutation (IP⁻¹)
           ↓
┌─────────────────────────────────────┐
│      64-bit Ciphertext Output       │
└─────────────────────────────────────┘
```

**Round Function f (轮函数):**

1. **Expansion (E):** Expand 32 bits to 48 bits
   - 将32位扩展到48位

2. **XOR with subkey:** 48-bit result ⊕ 48-bit subkey
   - 48位结果与48位子密钥异或

3. **S-box substitution:** 48 bits → 32 bits through 8 S-boxes
   - 通过8个S盒将48位替换为32位

4. **Permutation (P):** Permute the 32-bit output
   - 对32位输出进行置换

**Security Analysis (安全性分析):**

| Aspect                     | Status                                          | 方面         | 状态                    |
| -------------------------- | ----------------------------------------------- | ------------ | ----------------------- |
| Key size                   | 56 bits - too small                             | 密钥大小     | 56位 - 太小             |
| Brute force                | Feasible (< 24 hours with specialized hardware) | 暴力破解     | 可行（专用硬件<24小时） |
| Differential cryptanalysis | Resistant (S-boxes designed against it)         | 差分密码分析 | 有抵抗力                |
| Linear cryptanalysis       | Vulnerable                                      | 线性密码分析 | 易受攻击                |
| Recommendation             | Deprecated - use 3DES or AES instead            | 建议         | 已弃用 - 使用3DES或AES  |

### 2.4 3DES (Triple DES)

**Principle (原理):**
Apply DES three times with different keys to increase effective key length.

使用不同密钥对DES应用三次以增加有效密钥长度。

**Three Keying Options (三种密钥选项):**

1. **Keying Option 1:** Three independent keys (K1, K2, K3)
   - Effective key length: 168 bits (有效密钥长度: 168位)
   - Most secure (最安全)

2. **Keying Option 2:** K1 and K2 independent, K3 = K1
   - Effective key length: 112 bits (有效密钥长度: 112位)
   - Commonly used (常用)

3. **Keying Option 3:** K1 = K2 = K3 (backward compatible with DES)
   - Effective key length: 56 bits (有效密钥长度: 56位)

**Encryption Process (加密过程):**
```
C = E(K3, D(K2, E(K1, P)))
(Encrypt-Decrypt-Encrypt)
```

**Decryption Process (解密过程):**
```
P = D(K1, E(K2, D(K3, C)))
```

**Advantages (优点):**
- Significantly stronger than DES (比DES强得多)
- Backward compatible (向后兼容)

**Disadvantages (缺点):**
- Slow (3× DES performance) (慢 - 3倍DES性能)
- Being phased out in favor of AES (逐渐被AES取代)

### 2.5 AES (Advanced Encryption Standard)

**Overview (概述):**
- Selected through NIST competition (2001) (通过NIST竞赛选出 - 2001年)
- Based on Rijndael algorithm (基于Rijndael算法)
- Block size: 128 bits (分组大小: 128位)
- Key sizes: 128, 192, or 256 bits (密钥大小: 128、192或256位)
- Rounds: 10, 12, or 14 (depending on key size) (轮数: 10、12或14 - 取决于密钥大小)

**AES Structure (AES结构):**

AES operates on a 4×4 array of bytes called the **State**.

AES对一个称为**状态（State）**的4×4字节数组进行操作。

```
State Matrix (状态矩阵):
┌──────────────┐
│ b0  b4  b8  b12│
│ b1  b5  b9  b13│
│ b2  b6  b10 b14│
│ b3  b7  b11 b15│
└──────────────┘
```

**Round Transformations (轮变换):**

1. **SubBytes (字节替换):**
   - Non-linear substitution using S-box
   - 使用S盒进行非线性替换
   - Each byte is replaced independently
   - 每个字节独立替换

2. **ShiftRows (行移位):**
   - Row 0: No shift (第0行: 不移位)
   - Row 1: Left shift 1 byte (第1行: 左移1字节)
   - Row 2: Left shift 2 bytes (第2行: 左移2字节)
   - Row 3: Left shift 3 bytes (第3行: 左移3字节)

3. **MixColumns (列混合):**
   - Matrix multiplication in GF(2⁸)
   - 在GF(2⁸)中进行矩阵乘法
   - Provides diffusion (提供扩散性)
   - Skipped in final round (最后一轮跳过)

4. **AddRoundKey (轮密钥加):**
   - XOR state with round key
   - 状态与轮密钥异或
   - Derived from main key through key expansion
   - 通过密钥扩展从主密钥派生

**AES Encryption Process (AES加密过程):**

```
Input: 128-bit plaintext
       128/192/256-bit key

1. AddRoundKey (initial)
2. For rounds 1 to N-1:
     SubBytes
     ShiftRows
     MixColumns
     AddRoundKey
3. Final round:
     SubBytes
     ShiftRows
     AddRoundKey

Output: 128-bit ciphertext
```

**Key Expansion (密钥扩展):**

The key expansion algorithm generates round keys from the cipher key.

密钥扩展算法从密码密钥生成轮密钥。

- AES-128: 128 bits → 11 round keys (each 128 bits)
- AES-192: 192 bits → 13 round keys
- AES-256: 256 bits → 15 round keys

**Security and Performance (安全性和性能):**

| Aspect                     | AES-128     | AES-192        | AES-256        |
| -------------------------- | ----------- | -------------- | -------------- |
| Key size (密钥大小)        | 128 bits    | 192 bits       | 256 bits       |
| Rounds (轮数)              | 10          | 12             | 14             |
| Security level (安全级别)  | High        | Very High      | Extremely High |
| Performance (性能)         | Fastest     | Medium         | Slowest        |
| Recommended use (推荐用途) | General use | Sensitive data | Top secret     |

**Advantages (优点):**
- ✓ Very secure (no practical attacks) (非常安全 - 无实际攻击)
- ✓ Fast in both hardware and software (硬件和软件中都快速)
- ✓ Flexible key sizes (灵活的密钥大小)
- ✓ International standard (国际标准)
- ✓ Resistant to known attacks (抵抗已知攻击)

### 2.6 Other Symmetric Algorithms (其他对称算法)

**RC4 (Rivest Cipher 4):**
- Stream cipher (流密码)
- Variable key size (1-256 bytes) (可变密钥大小 - 1-256字节)
- Once widely used in SSL/TLS and WEP (曾广泛用于SSL/TLS和WEP)
- Now deprecated due to biases in keystream (由于密钥流存在偏差现已弃用)

**ChaCha20:**
- Modern stream cipher by Daniel Bernstein (Daniel Bernstein的现代流密码)
- Faster than AES in software on devices without AES hardware (在无AES硬件的设备上比AES快)
- Used in TLS 1.3 (用于TLS 1.3)
- Highly resistant to timing attacks (高度抵抗时序攻击)

**Blowfish & Twofish:**
- Block ciphers designed by Bruce Schneier (Bruce Schneier设计的分组密码)
- Blowfish: 64-bit blocks (Blowfish: 64位块)
- Twofish: 128-bit blocks, AES finalist (Twofish: 128位块，AES决赛选手)

### 2.7 Block Cipher Modes of Operation (分组密码工作模式)

**ECB (Electronic Codebook) Mode:**

```
Encryption: Ci = E(K, Pi)
Decryption: Pi = D(K, Ci)
```

| Advantages                     | Disadvantages                                                           |
| ------------------------------ | ----------------------------------------------------------------------- |
| Simple (简单)                  | Identical plaintext blocks → identical ciphertext (相同明文块→相同密文) |
| Parallel encryption (并行加密) | Does not hide data patterns (不隐藏数据模式)                            |
| Random access (随机访问)       | Vulnerable to replay attacks (易受重放攻击)                             |

**⚠️ Not recommended for general use (不推荐一般使用)**

**CBC (Cipher Block Chaining) Mode:**

```
Encryption: 
  C0 = IV (Initialization Vector)
  Ci = E(K, Pi ⊕ Ci-1)

Decryption:
  Pi = D(K, Ci) ⊕ Ci-1
```

**Visual (可视化):**
```
P1 → ⊕ → [E] → C1
     ↑
     IV

P2 → ⊕ → [E] → C2
     ↑
     C1

P3 → ⊕ → [E] → C3
     ↑
     C2
```

| Advantages                                                | Disadvantages                             |
| --------------------------------------------------------- | ----------------------------------------- |
| Hides patterns (隐藏模式)                                 | Sequential encryption (only) (仅顺序加密) |
| Same plaintext → different ciphertext (相同明文→不同密文) | Error propagation (错误传播)              |
| Widely used (广泛使用)                                    | Requires IV management (需要IV管理)       |

**CFB (Cipher Feedback) Mode:**

Turns block cipher into a stream cipher.

将分组密码转换为流密码。

```
Encryption:
  C0 = IV
  Ci = Pi ⊕ E(K, Ci-1)

Decryption:
  Pi = Ci ⊕ E(K, Ci-1)
```

**OFB (Output Feedback) Mode:**

```
Encryption/Decryption:
  O0 = IV
  Oi = E(K, Oi-1)
  Ci = Pi ⊕ Oi
  Pi = Ci ⊕ Oi
```

**Advantages (优点):**
- No error propagation (无错误传播)
- Can precompute keystream (可预计算密钥流)

**CTR (Counter) Mode:**

```
Ci = Pi ⊕ E(K, Counter + i)
```

```
P1 → ⊕ → C1         P2 → ⊕ → C2
     ↑                   ↑
  [E(K, Ctr+1)]      [E(K, Ctr+2)]
```

| Advantages                                     | Disadvantages                                                    |
| ---------------------------------------------- | ---------------------------------------------------------------- |
| Parallel encryption/decryption (并行加密/解密) | Counter must never repeat (计数器绝不能重复)                     |
| Random access (随机访问)                       | Requires careful IV/counter management (需要仔细的IV/计数器管理) |
| No padding required (无需填充)                 |                                                                  |
| Preprocessing possible (可预处理)              |                                                                  |

**GCM (Galois/Counter Mode):**

Combines CTR mode with authentication (GMAC).

结合CTR模式和认证（GMAC）。

```
Provides: Confidentiality + Authenticity + Integrity
提供: 机密性 + 真实性 + 完整性
```

**Features (特性):**
- Authenticated encryption (认证加密)
- Parallel processing (并行处理)
- Widely used in TLS 1.2/1.3 (广泛用于TLS 1.2/1.3)
- High performance (高性能)

**Mode Selection Guide (模式选择指南):**

| Use Case                 | Recommended Mode | 用例     | 推荐模式 |
| ------------------------ | ---------------- | -------- | -------- |
| General encryption       | CBC or CTR       | 通用加密 | CBC或CTR |
| Authenticated encryption | GCM              | 认证加密 | GCM      |
| Disk encryption          | XTS              | 磁盘加密 | XTS      |
| Streaming data           | CTR or CFB       | 流数据   | CTR或CFB |
| **Avoid**                | **ECB**          | **避免** | **ECB**  |

---

## 3. Asymmetric Encryption Algorithms (非对称加密算法)

### 3.1 Asymmetric Encryption Principles (非对称加密原理)

**Definition (定义):**

Asymmetric encryption uses a pair of mathematically related keys: a public key for encryption and a private key for decryption.

非对称加密使用一对数学上相关的密钥：公钥用于加密，私钥用于解密。

**Key Pair (密钥对):**
```
Public Key (公钥):  Can be freely distributed
                    用于加密，可自由分发

Private Key (私钥): Must be kept secret
                    用于解密，必须保密
```

**Process (流程):**
```
Encryption: C = E(PublicKey, P)
Decryption: P = D(PrivateKey, C)

Or reverse for digital signatures (或用于数字签名的相反过程):
Signing:    S = E(PrivateKey, H)
Verification: H = D(PublicKey, S)
```

**Mathematical Foundation (数学基础):**

Asymmetric algorithms rely on **one-way functions** with **trapdoors**:
- Easy to compute in one direction (单向容易计算)
- Computationally infeasible to reverse (反向计算不可行)
- Easy to reverse with special knowledge (trapdoor) (有特殊知识 - 陷门 - 则容易反向)

**Common Hard Problems (常见难题):**
1. **Integer factorization** (整数分解) - basis for RSA
2. **Discrete logarithm** (离散对数) - basis for ElGamal, DSA
3. **Elliptic curve discrete logarithm** (椭圆曲线离散对数) - basis for ECC

### 3.2 RSA Algorithm

**Overview (概述):**
- Invented by Rivest, Shamir, and Adleman (1977) (由Rivest、Shamir和Adleman于1977年发明)
- Most widely used public-key cryptosystem (最广泛使用的公钥密码系统)
- Based on difficulty of factoring large composite numbers (基于大合数分解的困难性)

**Mathematical Basis (数学基础):**

**Euler's Theorem (欧拉定理):**
```
If gcd(a, n) = 1, then a^φ(n) ≡ 1 (mod n)
where φ(n) is Euler's totient function
```

**RSA Key Generation (RSA密钥生成):**

```
Step 1: Select two large prime numbers p and q
        选择两个大素数 p 和 q
        (Typically 1024-2048 bits each)
        (通常每个1024-2048位)

Step 2: Compute n = p × q
        计算 n = p × q
        (n is the modulus, part of both public and private keys)
        (n是模数，是公钥和私钥的一部分)

Step 3: Compute φ(n) = (p-1) × (q-1)
        计算欧拉函数 φ(n) = (p-1) × (q-1)

Step 4: Choose public exponent e
        选择公钥指数 e
        where 1 < e < φ(n) and gcd(e, φ(n)) = 1
        其中 1 < e < φ(n) 且 gcd(e, φ(n)) = 1
        (Common choice: e = 65537 = 2^16 + 1)
        (常用选择: e = 65537 = 2^16 + 1)

Step 5: Compute private exponent d
        计算私钥指数 d
        where d × e ≡ 1 (mod φ(n))
        其中 d × e ≡ 1 (mod φ(n))
        (Using Extended Euclidean Algorithm)
        (使用扩展欧几里得算法)

Result:
  Public Key: (e, n)   公钥: (e, n)
  Private Key: (d, n)  私钥: (d, n)
```

**Example (示例):**

```python
# Small example (实际应用中使用更大的数字)
p = 61
q = 53

n = p * q = 3233
φ(n) = (p-1)(q-1) = 60 * 52 = 3120

Choose e = 17  (gcd(17, 3120) = 1)

Find d: d * 17 ≡ 1 (mod 3120)
       d = 2753

Public Key: (17, 3233)
Private Key: (2753, 3233)
```

**RSA Encryption/Decryption (RSA加密/解密):**

```
Encryption (加密):
  Given: message m, public key (e, n)
  Compute: c = m^e mod n

Decryption (解密):
  Given: ciphertext c, private key (d, n)
  Compute: m = c^d mod n

Proof (证明):
  c^d ≡ (m^e)^d ≡ m^(ed) ≡ m^(1 + kφ(n)) ≡ m (mod n)
```

**Example Calculation (示例计算):**

```
Message: m = 65

Encryption (用公钥 (17, 3233)):
c = 65^17 mod 3233 = 2790

Decryption (用私钥 (2753, 3233)):
m = 2790^2753 mod 3233 = 65  ✓
```

**Security Considerations (安全性考虑):**

| Aspect          | Recommendation                             | 方面     | 建议                         |
| --------------- | ------------------------------------------ | -------- | ---------------------------- |
| Key size        | ≥ 2048 bits (3072-4096 for long-term)      | 密钥大小 | ≥2048位 (长期用3072-4096)    |
| Prime selection | Cryptographically random, safe primes      | 素数选择 | 密码学随机，安全素数         |
| Padding         | Use OAEP, not raw RSA                      | 填充     | 使用OAEP，不使用原始RSA      |
| Public exponent | e = 65537 (balance security & performance) | 公钥指数 | e = 65537 (平衡安全性和性能) |

**Common Attacks (常见攻击):**

1. **Factorization attacks (因子分解攻击):**
   - Breaking RSA requires factoring n into p and q
   - 破解RSA需要将n分解为p和q
   - Current record: ~829-bit number factored (当前记录: ~829位数已被分解)

2. **Small exponent attack (小指数攻击):**
   - If e is small and message is small, c < n
   - Use proper padding to prevent (使用适当填充来防止)

3. **Common modulus attack (公共模数攻击):**
   - Never use same n for multiple key pairs
   - 切勿对多个密钥对使用相同的n

4. **Timing attacks (时序攻击):**
   - Side-channel attack measuring decryption time
   - Use constant-time implementations (使用恒定时间实现)

**Padding Schemes (填充方案):**

**PKCS#1 v1.5 Padding:**
```
EB = 00 || 02 || PS || 00 || D
where PS = random non-zero bytes
```
- Legacy, vulnerable to chosen-ciphertext attacks
- 遗留方案，易受选择密文攻击

**OAEP (Optimal Asymmetric Encryption Padding):**
```
More secure, recommended for new implementations
更安全，推荐用于新实现
```
- Provably secure under certain assumptions
- 在特定假设下可证明安全

### 3.3 Elliptic Curve Cryptography (ECC) (椭圆曲线密码学)

**Overview (概述):**

ECC provides equivalent security to RSA with much smaller key sizes.

ECC以更小的密钥大小提供与RSA相当的安全性。

**Elliptic Curve Equation (椭圆曲线方程):**

```
y² = x³ + ax + b (mod p)

where 4a³ + 27b² ≠ 0 (mod p)
```

**Visual Representation (可视化表示):**
```
      y
      ↑
      │     ╱╲
      │    ╱  ╲
      │   │    │
──────┼───┴────┴────→ x
      │
      │
```

**Point Addition (点加法):**

Key operation: P + Q = R

- Draw line through P and Q
- Find third intersection with curve
- Reflect across x-axis to get R

**Scalar Multiplication (标量乘法):**

```
kP = P + P + ... + P (k times)

Computed efficiently using double-and-add algorithm
使用倍加算法高效计算
```

**ECC Key Generation (ECC密钥生成):**

```
1. Select elliptic curve E and base point G
   选择椭圆曲线E和基点G

2. Choose random private key d (large integer)
   选择随机私钥d（大整数）

3. Compute public key Q = d × G
   计算公钥 Q = d × G

Public Key: (E, G, Q)
Private Key: d
```

**ECDH (Elliptic Curve Diffie-Hellman) Key Exchange:**

```
Alice                          Bob
─────────────────────────────────────
Private: da                   Private: db
Public:  Qa = da × G         Public:  Qb = db × G

         Qa ──────────────→
         ←──────────────── Qb

Shared:  S = da × Qb         Shared:  S = db × Qa
            = da × db × G               = db × da × G
            (Same!)                      (相同!)
```

**ECDSA (Elliptic Curve Digital Signature Algorithm):**

**Signing (签名):**
```
1. Compute hash: e = H(message)
2. Select random k
3. Compute (x, y) = k × G
4. r = x mod n
5. s = k⁻¹(e + d·r) mod n
   Signature: (r, s)
```

**Verification (验证):**
```
1. Compute e = H(message)
2. w = s⁻¹ mod n
3. u1 = ew mod n
4. u2 = rw mod n
5. (x, y) = u1×G + u2×Q
6. Verify: r ≡ x (mod n)
```

**ECC vs RSA Comparison (ECC与RSA对比):**

| Security Level | RSA Key Size | ECC Key Size | Performance    |
| -------------- | ------------ | ------------ | -------------- |
| 80-bit         | 1024 bits    | 160 bits     | ECC 10× faster |
| 112-bit        | 2048 bits    | 224 bits     | ECC 5× faster  |
| 128-bit        | 3072 bits    | 256 bits     | ECC 3× faster  |
| 192-bit        | 7680 bits    | 384 bits     | ECC 2× faster  |
| 256-bit        | 15360 bits   | 521 bits     | ECC faster     |

**Advantages of ECC (ECC的优点):**
- ✓ Smaller key sizes (更小的密钥)
- ✓ Faster operations (更快的操作)
- ✓ Lower bandwidth (更低的带宽)
- ✓ Lower power consumption (更低的功耗)
- ✓ Ideal for mobile and IoT devices (适合移动和物联网设备)

**Standard Curves (标准曲线):**
- **NIST curves:** P-256, P-384, P-521
- **Curve25519:** Modern, high-security curve by Bernstein
- **secp256k1:** Used in Bitcoin

### 3.4 Other Asymmetric Algorithms (其他非对称算法)

**Diffie-Hellman (DH) Key Exchange:**

**Purpose:** Securely exchange cryptographic keys over public channel.
目的：在公共通道上安全交换密码密钥。

```
Public: prime p, generator g

Alice                          Bob
─────────────────────────────────────
Private: a                    Private: b
Public:  A = g^a mod p       Public:  B = g^b mod p

         A ──────────────→
         ←──────────────── B

Shared:  s = B^a mod p       Shared:  s = A^b mod p
           = g^(ab) mod p              = g^(ab) mod p
```

**DSA (Digital Signature Algorithm):**

- US Federal standard for digital signatures (美国联邦数字签名标准)
- Based on discrete logarithm problem (基于离散对数问题)
- Key sizes: 1024-3072 bits (密钥大小: 1024-3072位)
- Signature size: 320-512 bits (签名大小: 320-512位)

**ElGamal Encryption:**

- Based on Diffie-Hellman (基于Diffie-Hellman)
- Probabilistic encryption (same plaintext → different ciphertext) (概率加密)
- Ciphertext expansion: 2× plaintext size (密文扩展: 2倍明文大小)

### 3.5 Hybrid Cryptosystems (混合密码系统)

**Problem (问题):**
- Symmetric: Fast but key distribution difficult (对称: 快速但密钥分发困难)
- Asymmetric: Solves key distribution but slow (非对称: 解决密钥分发但慢)

**Solution: Hybrid Approach (解决方案: 混合方法)**

```
1. Generate random symmetric session key K
   生成随机对称会话密钥K

2. Encrypt message with symmetric key: C1 = AES(K, M)
   用对称密钥加密消息: C1 = AES(K, M)

3. Encrypt session key with recipient's public key: C2 = RSA(PubKey, K)
   用接收方公钥加密会话密钥: C2 = RSA(PubKey, K)

4. Send both: (C1, C2)
   发送两者: (C1, C2)

Decryption (解密):
1. K = RSA_Decrypt(PrivKey, C2)
2. M = AES_Decrypt(K, C1)
```

**Advantages (优点):**
- ✓ Fast encryption of large data (symmetric) (快速加密大数据)
- ✓ Secure key distribution (asymmetric) (安全密钥分发)
- ✓ Used in SSL/TLS, PGP, S/MIME (用于SSL/TLS、PGP、S/MIME)

---

## 4. Hash Functions and Message Digests (哈希函数与消息摘要)

### 4.1 Hash Function Principles (哈希函数原理)

**Definition (定义):**

A **cryptographic hash function** takes an input of arbitrary length and produces a fixed-length output (hash value or digest).

**密码哈希函数**接受任意长度的输入并产生固定长度的输出（哈希值或摘要）。

```
H: {0,1}* → {0,1}^n
H(message) = hash_value
```

**Properties (性质):**

1. **Deterministic (确定性):** Same input always produces same output.
   - 相同输入始终产生相同输出

2. **Fast Computation (快速计算):** Efficient to compute hash for any message.
   - 对任何消息计算哈希都高效

3. **Pre-image Resistance (单向性/原像抗性):** Given hash h, infeasible to find m such that H(m) = h.
   - 给定哈希h，找到满足H(m) = h的m不可行

4. **Second Pre-image Resistance (弱抗碰撞性/第二原像抗性):** Given m1, infeasible to find m2 ≠ m1 such that H(m1) = H(m2).
   - 给定m1，找到m2 ≠ m1使得H(m1) = H(m2)不可行

5. **Collision Resistance (强抗碰撞性):** Infeasible to find any m1 ≠ m2 such that H(m1) = H(m2).
   - 找到任意m1 ≠ m2使得H(m1) = H(m2)不可行

6. **Avalanche Effect (雪崩效应):** Small change in input causes significant change in output.
   - 输入的微小变化导致输出的显著变化

**Applications (应用):**
- Data integrity verification (数据完整性验证)
- Password storage (密码存储)
- Digital signatures (数字签名)
- Blockchain (区块链)
- HMAC (message authentication codes) (消息认证码)
- Key derivation (密钥派生)

### 4.2 MD5 (Message Digest Algorithm 5)

**Overview (概述):**
- Designed by Ronald Rivest (1991) (由Ronald Rivest于1991年设计)
- Output: 128 bits (16 bytes) (输出: 128位)
- Processes input in 512-bit blocks (以512位块处理输入)

**Algorithm Structure (算法结构):**

```
Input: Message M (任意长度)

1. Padding (填充):
   - Append '1' bit
   - Append '0' bits until length ≡ 448 (mod 512)
   - Append 64-bit message length

2. Initialize MD buffer (初始化MD缓冲区):
   A = 0x67452301
   B = 0xEFCDAB89
   C = 0x98BADCFE
   D = 0x10325476

3. Process each 512-bit block (处理每个512位块):
   - 64 rounds of operations
   - Mix using functions F, G, H, I
   - Update A, B, C, D

4. Output: Concatenate A, B, C, D (128 bits)
```

**Security Status (安全状态):**

| Year | Attack                      | Impact       |
| ---- | --------------------------- | ------------ |
| 2004 | Collision found in < 1 hour | 碰撞攻击     |
| 2008 | Chosen-prefix collision     | 选择前缀碰撞 |
| 2012 | Collision in seconds        | 秒级碰撞     |

**⚠️ MD5 is BROKEN - DO NOT USE for security purposes**
**⚠️ MD5已破解 - 不要用于安全目的**

**Still acceptable for (仍可用于):**
- Non-cryptographic checksums (非加密校验和)
- Hash tables (哈希表)
- Deduplication (去重)

### 4.3 SHA (Secure Hash Algorithm) Family

**SHA-1:**
- Output: 160 bits (输出: 160位)
- Developed by NSA (1995) (由NSA于1995年开发)
- **Status:** Deprecated (Google demonstrated collision in 2017) (状态: 已弃用)

**SHA-2 Family:**

| Algorithm   | Output Size  | Block Size    | Security Level |
| ----------- | ------------ | ------------- | -------------- |
| SHA-224     | 224 bits     | 512 bits      | 112-bit        |
| **SHA-256** | **256 bits** | **512 bits**  | **128-bit**    |
| SHA-384     | 384 bits     | 1024 bits     | 192-bit        |
| **SHA-512** | **512 bits** | **1024 bits** | **256-bit**    |
| SHA-512/224 | 224 bits     | 1024 bits     | 112-bit        |
| SHA-512/256 | 256 bits     | 1024 bits     | 128-bit        |

**SHA-256 Algorithm (SHA-256算法):**

```
Input: Message M

1. Padding (填充):
   - Append '1' bit
   - Append '0' bits until length ≡ 448 (mod 512)
   - Append 64-bit message length

2. Initialize hash values (初始化哈希值):
   H0 = 0x6a09e667
   H1 = 0xbb67ae85
   H2 = 0x3c6ef372
   H3 = 0xa54ff53a
   H4 = 0x510e527f
   H5 = 0x9b05688c
   H6 = 0x1f83d9ab
   H7 = 0x5be0cd19

3. Process each 512-bit block (处理每个512位块):
   - Prepare message schedule (W0...W63)
   - Initialize working variables a, b, c, d, e, f, g, h
   - 64 rounds of compression function:
     T1 = h + Σ1(e) + Ch(e,f,g) + Kt + Wt
     T2 = Σ0(a) + Maj(a,b,c)
     h = g; g = f; f = e; e = d + T1
     d = c; c = b; b = a; a = T1 + T2
   - Add to hash values

4. Output: Concatenate H0...H7 (256 bits)
```

**Example (示例):**

```python
import hashlib

message = "Hello, World!"
hash_object = hashlib.sha256(message.encode())
print(hash_object.hexdigest())

# Output:
# dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f

# Small change (改变一个字符):
message2 = "Hello, World?"
hash_object2 = hashlib.sha256(message2.encode())
print(hash_object2.hexdigest())

# Completely different hash (完全不同的哈希):
# 3f3c3c5f2c1c1b0b5e5c8a8a3a3a1a1a... (示例)
```

**SHA-3 (Keccak):**

- Winner of NIST competition (2012) (NIST竞赛获胜者 - 2012)
- Different internal structure from SHA-2 (与SHA-2的内部结构不同)
- Based on sponge construction (基于海绵构造)
- Variants: SHA3-224, SHA3-256, SHA3-384, SHA3-512

**SHA-2 vs SHA-3:**

| Aspect         | SHA-2             | SHA-3                   |
| -------------- | ----------------- | ----------------------- |
| Structure      | Merkle-Damgård    | Sponge function         |
| Security       | Very high         | Very high               |
| Performance    | Faster (hardware) | Faster (software)       |
| Status         | Widely deployed   | Newer, growing adoption |
| Recommendation | Primary choice    | Alternative/future      |

### 4.4 HMAC (Hash-based Message Authentication Code)

**Purpose (目的):**

Provide **integrity** and **authenticity** (not just integrity like plain hash).

提供**完整性**和**真实性**（不仅仅是像普通哈希那样的完整性）。

**Construction (构造):**

```
HMAC(K, M) = H((K ⊕ opad) || H((K ⊕ ipad) || M))

where:
  K = secret key (密钥)
  M = message (消息)
  H = hash function (哈希函数)
  opad = 0x5c5c5c... (outer padding)
  ipad = 0x363636... (inner padding)
  || = concatenation (连接)
  ⊕ = XOR
```

**Process (过程):**

```
1. If key length > block size: K = H(K)
   如果密钥长度 > 块大小: K = H(K)

2. If key length < block size: pad K with zeros
   如果密钥长度 < 块大小: 用零填充K

3. Compute inner hash: h1 = H((K ⊕ ipad) || M)
   计算内部哈希: h1 = H((K ⊕ ipad) || M)

4. Compute outer hash: h2 = H((K ⊕ opad) || h1)
   计算外部哈希: h2 = H((K ⊕ opad) || h1)

5. Output: h2
```

**Example (示例):**

```python
import hmac
import hashlib

key = b"secret_key_123"
message = b"Important message"

# Create HMAC-SHA256
h = hmac.new(key, message, hashlib.sha256)
print(h.hexdigest())

# Verification (验证):
h_verify = hmac.new(key, message, hashlib.sha256)
if hmac.compare_digest(h.digest(), h_verify.digest()):
    print("Authentic (真实)")
else:
    print("Tampered (被篡改)")
```

**Applications (应用):**
- API authentication (API认证)
- Message integrity in protocols (协议中的消息完整性)
- JWT (JSON Web Tokens)
- Password-based key derivation (基于密码的密钥派生)

### 4.5 Password Hashing (密码哈希)

**Naive Approach (朴素方法) - INSECURE:**

```
Hash = SHA256(password)  ✗ DO NOT USE
```

**Problems (问题):**
- Vulnerable to rainbow table attacks (易受彩虹表攻击)
- Too fast to compute (allows brute force) (计算太快 - 允许暴力破解)

**Proper Password Hashing (正确的密码哈希):**

**1. Salting (加盐):**

```python
import os
import hashlib

# Generate random salt (生成随机盐)
salt = os.urandom(32)

# Hash password with salt
password = "MySecurePassword123"
hash_value = hashlib.pbkdf2_hmac(
    'sha256',
    password.encode(),
    salt,
    100000  # iterations (迭代次数)
)

# Store both salt and hash
stored = salt + hash_value
```

**2. Key Derivation Functions (KDF) (密钥派生函数):**

**PBKDF2 (Password-Based Key Derivation Function 2):**
```
PBKDF2(password, salt, iterations, dkLen)
```
- Widely supported (广泛支持)
- Configurable iterations (可配置迭代次数)
- NIST approved (NIST批准)

**bcrypt:**
```python
import bcrypt

password = b"MySecurePassword123"

# Hash password (哈希密码)
hashed = bcrypt.hashpw(password, bcrypt.gensalt(rounds=12))

# Verify password (验证密码)
if bcrypt.checkpw(password, hashed):
    print("Password correct")
```
- Adaptive cost factor (自适应成本因子)
- Built-in salt (内置盐)
- Designed to be slow (设计为慢速)

**scrypt:**
- Memory-hard (内存困难)
- Resistant to hardware attacks (抵抗硬件攻击)
- Higher resource requirements (更高的资源需求)

**Argon2 (Recommended):**
```
Winner of Password Hashing Competition (2015)
密码哈希竞赛获胜者 (2015)
```
- Best resistance against GPU/ASIC attacks (最佳抵抗GPU/ASIC攻击)
- Three variants: Argon2d, Argon2i, Argon2id
- Configurable memory, time, and parallelism (可配置内存、时间和并行度)

**Comparison (对比):**

| Function   | Speed            | Memory           | Hardware Resistance | Recommendation |
| ---------- | ---------------- | ---------------- | ------------------- | -------------- |
| SHA-256    | Very Fast        | Low              | ✗ Poor              | ✗ Don't use    |
| PBKDF2     | Configurable     | Low              | ⚠ Moderate          | ✓ Acceptable   |
| bcrypt     | Slow             | Moderate         | ✓ Good              | ✓ Good         |
| scrypt     | Slow             | High             | ✓ Very Good         | ✓ Very Good    |
| **Argon2** | **Configurable** | **Configurable** | **✓ Excellent**     | **✓✓ Best**    |

---

## 5. Digital Signatures (数字签名)

### 5.1 Digital Signature Principles (数字签名原理)

**Definition (定义):**

A **digital signature** is a cryptographic mechanism that provides **authentication**, **integrity**, and **non-repudiation** for digital messages or documents.

**数字签名**是一种密码学机制，为数字消息或文档提供**认证**、**完整性**和**不可否认性**。

**Digital Signature vs Encryption (数字签名vs加密):**

| Aspect                | Encryption               | Digital Signature                 |
| --------------------- | ------------------------ | --------------------------------- |
| Purpose               | Confidentiality (机密性) | Authentication (认证性)           |
| Who uses private key? | Receiver (接收方)        | Sender (发送方)                   |
| Who uses public key?  | Sender (发送方)          | Receiver (接收方)                 |
| Protects against      | Eavesdropping (窃听)     | Forgery, Repudiation (伪造、否认) |

**Process (流程):**

```
Signing (签名):
──────────────
Message → Hash → Encrypt with Private Key → Signature
                                              |
                                              └→ Send (Message + Signature)

Verification (验证):
─────────────────
Received Message → Hash → Compare ← Decrypt Signature with Public Key
                    ↓                     ↓
                  Hash1                 Hash2
                    
                  If Hash1 == Hash2: Valid Signature
                  如果 Hash1 == Hash2: 签名有效
```

**Properties (性质):**

1. **Authentication (认证):** Verifies sender's identity.
   - 验证发送者身份

2. **Integrity (完整性):** Detects any modification to message.
   - 检测消息的任何修改

3. **Non-repudiation (不可否认性):** Sender cannot deny signing.
   - 发送方不能否认签名

4. **Unforgeable (不可伪造):** Only possessor of private key can create valid signature.
   - 只有私钥持有者才能创建有效签名

### 5.2 RSA Digital Signature

**Signing Process (签名过程):**

```
1. Compute message hash: h = H(M)
   计算消息哈希: h = H(M)

2. Sign hash with private key: S = h^d mod n
   用私钥签名哈希: S = h^d mod n

3. Send (M, S)
   发送 (M, S)
```

**Verification Process (验证过程):**

```
1. Receive (M, S)
   接收 (M, S)

2. Decrypt signature with public key: h' = S^e mod n
   用公钥解密签名: h' = S^e mod n

3. Compute hash of received message: h = H(M)
   计算接收消息的哈希: h = H(M)

4. Compare: If h == h', signature is valid
   比较: 如果 h == h', 签名有效
```

**Example (示例):**

```python
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256

# Generate key pair (生成密钥对)
key = RSA.generate(2048)
private_key = key
public_key = key.publickey()

# Sign message (签名消息)
message = b"Transfer $1000 to Bob"
h = SHA256.new(message)
signature = pkcs1_15.new(private_key).sign(h)

print(f"Signature length: {len(signature)} bytes")

# Verify signature (验证签名)
try:
    h = SHA256.new(message)
    pkcs1_15.new(public_key).verify(h, signature)
    print("✓ Signature is valid (签名有效)")
except (ValueError, TypeError):
    print("✗ Signature is invalid (签名无效)")

# Tamper with message (篡改消息)
tampered = b"Transfer $9000 to Bob"
try:
    h = SHA256.new(tampered)
    pkcs1_15.new(public_key).verify(h, signature)
except:
    print("✗ Tampered message detected (检测到篡改)")
```

### 5.3 DSA (Digital Signature Algorithm)

**Overview (概述):**
- US Federal standard (FIPS 186) (美国联邦标准)
- Based on discrete logarithm problem (基于离散对数问题)
- Cannot be used for encryption (不能用于加密)
- Smaller signature size than RSA (比RSA签名更小)

**Parameters (参数):**
- p: Large prime (1024-3072 bits) (大素数)
- q: Prime divisor of (p-1), 160-256 bits (q: (p-1)的素数因子)
- g: Generator (生成元)
- x: Private key (私钥)
- y: Public key, y = g^x mod p (公钥)

**Signing (签名):**

```
1. Select random k (1 < k < q)
   选择随机k

2. Compute r = (g^k mod p) mod q

3. Compute s = k^(-1)(H(M) + xr) mod q

   Signature: (r, s)
```

**Verification (验证):**

```
1. Compute w = s^(-1) mod q

2. Compute u1 = H(M) × w mod q

3. Compute u2 = r × w mod q

4. Compute v = ((g^u1 × y^u2) mod p) mod q

5. Accept if v == r
   如果 v == r 则接受
```

**Important: k must be random and never reused!**
**重要: k必须是随机的且绝不能重用!**

If k is reused for two signatures, private key can be recovered.
如果k在两个签名中重用，私钥可以被恢复。

### 5.4 ECDSA (Elliptic Curve Digital Signature Algorithm)

**Overview (概述):**
- Elliptic curve variant of DSA (DSA的椭圆曲线变体)
- Smaller key and signature sizes (更小的密钥和签名大小)
- Widely used (Bitcoin, TLS, etc.) (广泛使用)

**Signing (签名):**

```
1. Select random k (1 < k < n)
   选择随机k

2. Compute point (x, y) = k × G

3. Compute r = x mod n

4. Compute s = k^(-1)(H(M) + d × r) mod n
   where d is private key (其中d是私钥)

   Signature: (r, s)
```

**Verification (验证):**

```
1. Compute w = s^(-1) mod n

2. Compute u1 = H(M) × w mod n

3. Compute u2 = r × w mod n

4. Compute point (x, y) = u1 × G + u2 × Q
   where Q is public key (其中Q是公钥)

5. Accept if r ≡ x (mod n)
```

**Comparison (对比):**

| Algorithm | Key Size  | Signature Size | Speed     | Security Basis  |
| --------- | --------- | -------------- | --------- | --------------- |
| RSA-2048  | 2048 bits | 256 bytes      | Moderate  | Factorization   |
| DSA-2048  | 2048 bits | 40-64 bytes    | Fast      | Discrete log    |
| ECDSA-256 | 256 bits  | 64 bytes       | Very Fast | EC discrete log |

### 5.5 Blind Signatures and Multi-Signatures (盲签名和多重签名)

**Blind Signature (盲签名):**

Signer signs message without seeing its content.

签名者在不看到消息内容的情况下签名。

**Application (应用):** Anonymous digital cash (匿名数字现金)

```
1. User blinds message: M' = blind(M, r)
   用户对消息盲化: M' = blind(M, r)

2. Signer signs: S' = sign(M')
   签名者签名: S' = sign(M')

3. User unblinds signature: S = unblind(S', r)
   用户对签名解盲: S = unblind(S', r)

4. S is valid signature on M
   S是M的有效签名
```

**Multi-Signature (多重签名):**

Requires multiple parties to sign message.

需要多方签名消息。

**Types (类型):**

1. **Sequential Multi-Signature (顺序多重签名):**
   - Each party signs in order (每方按顺序签名)
   - S = Sign_A(Sign_B(Sign_C(M)))

2. **Threshold Signature (门限签名):**
   - Requires t out of n signatures (需要n个中的t个签名)
   - Example: 2-of-3, 3-of-5 (示例: 2/3, 3/5)

**Bitcoin Multi-Signature Example (比特币多重签名示例):**

```
2-of-3 Multi-Sig Address:
Requires 2 signatures from:
- Alice's key
- Bob's key
- Charlie's key

Use case: Corporate wallet, escrow
用例: 企业钱包、托管
```

---

## 6. Key Management (密钥管理)

### 6.1 Key Lifecycle (密钥生命周期)

```
┌───────────────────────────────────────────┐
│ 1. Generation (生成)                       │
│    - Use cryptographically secure RNG     │
│    - Sufficient entropy (足够的熵)         │
└─────────────┬─────────────────────────────┘
              ↓
┌───────────────────────────────────────────┐
│ 2. Distribution (分发)                     │
│    - Secure channel                        │
│    - Out-of-band verification (带外验证)   │
└─────────────┬─────────────────────────────┘
              ↓
┌───────────────────────────────────────────┐
│ 3. Storage (存储)                          │
│    - Encrypted storage                     │
│    - Hardware security modules (HSM)       │
│    - Access control (访问控制)             │
└─────────────┬─────────────────────────────┘
              ↓
┌───────────────────────────────────────────┐
│ 4. Usage (使用)                            │
│    - Proper algorithm selection            │
│    - Secure implementation (安全实现)      │
└─────────────┬─────────────────────────────┘
              ↓
��───────────────────────────────────────────┐
│ 5. Rotation (轮换)                         │
│    - Regular key updates                   │
│    - Cryptoperiod management (密码周期管理)│
└─────────────┬─────────────────────────────┘
              ↓
┌───────────────────────────────────────────┐
│ 6. Archival/Backup (归档/备份)             │
│    - Secure backup procedures              │
│    - Escrow (if required) (托管 - 如需要)  │
└─────────────┬─────────────────────────────┘
              ↓
┌───────────────────────────────────────────┐
│ 7. Revocation/Destruction (撤销/销毁)      │
│    - Secure deletion                       │
│    - Certificate revocation (证书撤销)     │
│    - Audit trail (审计跟踪)                │
└───────────────────────────────────────────┘
```

### 6.2 Key Generation (密钥生成)

**Requirements (要求):**

1. **Randomness (随机性):**
   - Use cryptographically secure random number generator (CSRNG)
   - 使用密码学安全的随机数生成器
   - Sufficient entropy source (足够的熵源)

2. **Key Length (密钥长度):**
   - Follow current security standards (遵循当前安全标准)
   - Account for expected lifetime (考虑预期生命周期)

**Poor Randomness Sources (不良随机源) - AVOID:**
```python
import random  # ✗ NOT cryptographically secure

# Bad (坏例子):
key = random.randint(0, 2**128)  # Predictable!
```

**Proper Randomness (正确的随机性):**
```python
import os
import secrets  # Python 3.6+

# Good (好例子):
key = os.urandom(32)  # 256 bits, cryptographically secure
# or
key = secrets.token_bytes(32)

print(f"Key: {key.hex()}")
```

**Entropy Sources (熵源):**
- Hardware RNG (硬件随机数生成器)
- /dev/urandom (Linux)
- CryptGenRandom (Windows)
- CPU instruction: RDRAND (Intel)

### 6.3 Key Distribution (密钥分发)

**The Key Distribution Problem (密钥分发问题):**

How do two parties securely share a secret key over an insecure channel?

如何在不安全的通道上安全地共享密钥？

**Solutions (解决方案):**

**1. Pre-shared Keys (预共享密钥):**
```
- Exchange keys in person (面对面交换密钥)
- Use trusted courier (使用可信快递员)
- Out-of-band communication (带外通信)

Pros: Simple, secure if done correctly (简单，如果正确操作则安全)
Cons: Not scalable (不可扩展)
```

**2. Key Distribution Center (KDC) (密钥分发中心):**

```
Alice and Bob each share long-term key with KDC:
Alice ←→ KDC ←→ Bob
  Ka        Kb

Session key exchange:
1. Alice → KDC: "I want to talk to Bob"
2. KDC generates session key Ks
3. KDC → Alice: E(Ka, Ks || E(Kb, Ks))
4. Alice → Bob: E(Kb, Ks)
5. Now both have Ks
```

**Example:** Kerberos authentication protocol

**3. Diffie-Hellman Key Exchange:**

Solves key distribution without pre-shared secrets or KDC.

无需预共享密钥或KDC即可解决密钥分发。

```
Public: prime p, generator g

Alice                          Bob
─────────────────────────────────────
1. Choose random a            Choose random b
2. Compute A = g^a mod p     Compute B = g^b mod p
3.        A ──────────────→
4.        ←────────────── B
5. Compute K = B^a mod p     Compute K = A^b mod p
                = g^ab mod p            = g^ab mod p

Shared secret: K
```

**Security Note (安全注意):**
Vulnerable to man-in-the-middle (MITM) attack without authentication.
易受中间人攻击，除非有认证。

**Solution:** Combine with public key certificates (PKI)
解决方案：结合公钥证书（PKI）

**4. Public Key Infrastructure (PKI):**

Use asymmetric cryptography to securely distribute symmetric keys.

使用非对称密码学安全分发对称密钥。

```
Alice:
1. Obtain Bob's public key (from certificate)
2. Generate random session key Ks
3. Encrypt: C = RSA_Encrypt(Bob_PublicKey, Ks)
4. Send C to Bob

Bob:
5. Decrypt: Ks = RSA_Decrypt(Bob_PrivateKey, C)
```

### 6.4 Key Storage and Protection (密钥存储和保护)

**Storage Options (存储选项):**

**1. Software Storage (软件存储):**
```
- Encrypted file
- Operating system keystore
- Password manager

Protection: Encryption with master password
保护：使用主密码加密
```

**2. Hardware Security Module (HSM) (硬件安全模块):**
```
Physical device designed to:
- Generate keys (生成密钥)
- Store keys securely (安全存储密钥)
- Perform cryptographic operations (执行密码操作)
- Tamper-resistant (防篡改)

Examples:
- Dedicated HSM appliances (专用HSM设备)
- Smart cards (智能卡)
- USB security tokens (USB安全令牌)
- Trusted Platform Module (TPM) (可信平台模块)
```

**Benefits (优点):**
- Private keys never leave the device (私钥永不离开设备)
- Physical security (物理安全)
- Regulatory compliance (法规合规)

**3. Trusted Platform Module (TPM):**
```
Chip on motherboard that provides:
主板上的芯片，提供：
- Secure key generation and storage
- Platform integrity verification
- Sealed storage (encrypted to specific hardware)

Use cases: BitLocker, secure boot
```

**4. Cloud Key Management Service (云密钥管理服务):**
```
Examples:
- AWS KMS (Key Management Service)
- Azure Key Vault
- Google Cloud KMS

Features:
- Centralized key management (集中密钥管理)
- Access control and auditing (访问控制和审计)
- High availability (高可用性)
```

**Key Encryption Key (KEK) Pattern (密钥加密密钥模式):**

```
Data Encryption Key (DEK) (数据加密密钥):
  - Encrypts actual data
  - 加密实际数据
  - Can be stored with data (encrypted)
  - 可与数据一起存储（加密）

Key Encryption Key (KEK) (密钥加密密钥):
  - Encrypts DEK
  - 加密DEK
  - Stored separately, highly protected
  - 单独存储，高度保护

Master Key (主密钥):
  - Encrypts KEKs
  - 加密KEK
  - Stored in HSM
  - 存储在HSM中
```

### 6.5 Key Rotation and Revocation (密钥轮换和撤销)

**Key Rotation (密钥轮换):**

**Why rotate keys? (为什么轮换密钥?)**
- Limit damage from key compromise (限制密钥泄露的损害)
- Reduce cryptanalysis risk (降低密码分析风险)
- Comply with regulations (符合法规)

**Rotation Strategies (轮换策略):**

```
1. Time-based (基于时间):
   - Every 90 days, 1 year, etc.
   - 每90天、1年等

2. Usage-based (基于使用):
   - After N operations/bytes encrypted
   - N次操作/加密字节后

3. Event-based (基于事件):
   - Employee departure (员工离职)
   - Security incident (安全事件)
   - Suspected compromise (疑似泄露)
```

**Rotation Process (轮换过程):**

```
1. Generate new key (生成新密钥)
2. Deploy new key to all systems (将新密钥部署到所有系统)
3. Re-encrypt sensitive data (if needed) (重新加密敏感数据 - 如需要)
4. Retire old key (淘汰旧密钥)
5. Destroy old key securely (安全销毁旧密钥)
```

**Key Revocation (密钥撤销):**

**Reasons (原因):**
- Private key compromised (私钥泄露)
- Owner no longer trusted (所有者不再可信)
- Certificate expired (证书过期)
- Change in affiliation (隶属关系变更)

**Mechanisms (机制):**
- Certificate Revocation List (CRL) (证书撤销列表)
- Online Certificate Status Protocol (OCSP) (在线证书状态协议)

---

## 7. Public Key Infrastructure (PKI) (公钥基础设施)

### 7.1 PKI Overview (PKI概述)

**Definition (定义):**

**Public Key Infrastructure (PKI)** is a framework that manages digital certificates and public-key encryption to secure communications and verify identities.

**公钥基础设施（PKI）**是管理数字证书和公钥加密以保护通信和验证身份的框架。

**Components (组件):**

```
┌──────────────────────────────────────────┐
│   Certificate Authority (CA) (证书颁发机构)│
│   - Issues certificates (颁发证书)        │
│   - Signs certificates (签名证书)         │
└──────────────┬───────────────────────────┘
                ↓
┌──────────────────────────────────────────┐
│ Registration Authority (RA) (注册机构)    │
│ - Verifies identities (验证身份)          │
│ - Approves certificate requests (批准请求)│
└──────────────┬───────────────────────────┘
                ↓
┌──────────────────────────────────────────┐
│   Digital Certificates (数字证书)         │
│   - Bind public keys to identities        │
└──────────────┬───────────────────────────┘
                ↓
┌──────────────────────────────────────────┐
│ Certificate Repository (证书库)           │
│ - Stores and distributes certificates     │
└──────────────┬───────────────────────────┘
                ↓
┌──────────────────────────────────────────┐
│ Revocation System (撤销系统)              │
│ - CRL (Certificate Revocation List)       │
│ - OCSP (Online Certificate Status Protocol)│
└──────────────────────────────────────────┘
```

### 7.2 Digital Certificates (数字证书)

**X.509 Certificate Standard:**

Most widely used certificate format.

最广泛使用的证书格式。

**Certificate Structure (证书结构):**

```
Certificate:
  Version: 3 (版本)
  Serial Number: 0x12345... (序列号)
  Signature Algorithm: SHA256withRSA (签名算法)
  Issuer: CN=GlobalSign CA, O=GlobalSign, C=US (颁发者)
  Validity: (有效期)
    Not Before: 2024-01-01 00:00:00 UTC
    Not After:  2025-12-31 23:59:59 UTC
  Subject: CN=www.example.com, O=Example Inc, C=US (主体)
  Subject Public Key Info: (主体公钥信息)
    Algorithm: RSA (2048 bits)
    Public Key: 30 82 01 0a...
  Extensions: (扩展)
    Key Usage: Digital Signature, Key Encipherment
    Extended Key Usage: TLS Web Server Authentication
    Subject Alternative Name: www.example.com, example.com
  Signature: (签名)
    30 82 01 0a 02 82...
```

**Key Fields (关键字段):**

| Field           | Description                | 字段   | 描述         |
| --------------- | -------------------------- | ------ | ------------ |
| Issuer          | CA that issued certificate | 颁发者 | 颁发证书的CA |
| Subject         | Certificate owner          | 主体   | 证书所有者   |
| Public Key      | Owner's public key         | 公钥   | 所有者的公钥 |
| Validity Period | Certificate lifetime       | 有效期 | 证书生命周期 |
| Signature       | CA's digital signature     | 签名   | CA的数字签名 |

**Certificate Types (证书类型):**

**1. Domain Validation (DV) (域名验证):**
- Verifies domain ownership only (仅验证域名所有权)
- Automated issuance (自动颁发)
- Lowest cost (成本最低)
- Example: Let's Encrypt certificates

**2. Organization Validation (OV) (组织验证):**
- Verifies organization identity (验证组织身份)
- Manual verification required (需要人工验证)
- Displays organization name (显示组织名称)

**3. Extended Validation (EV) (扩展验证):**
- Extensive organization verification (广泛的组织验证)
- Green address bar (in some browsers) (绿色地址栏 - 某些浏览器)
- Highest assurance (最高保证)
- Example: Bank websites

**Certificate Lifecycle (证书生命周期):**

```
1. Key Pair Generation (密钥对生成)
   ↓
2. Certificate Signing Request (CSR) (证书签名请求)
   - Contains public key and identity info
   ↓
3. Identity Verification (身份验证)
   - RA verifies requestor's identity
   ↓
4. Certificate Issuance (证书颁发)
   - CA signs and issues certificate
   ↓
5. Certificate Publication (证书发布)
   - Published to repository
   ↓
6. Certificate Usage (证书使用)
   - TLS, email encryption, code signing
   ↓
7. Certificate Renewal or Revocation (证书续期或撤销)
```

### 7.3 Certificate Authority (CA) (证书颁发机构)

**CA Hierarchy (CA层次结构):**

```
        ┌─────────────────────┐
        │    Root CA (根CA)   │
        │  (Self-signed)      │
        │  (Offline, secure)  │
        └──────────┬──────────┘
                   │
         ┌─────────┴─────────┐
         │                   │
┌────────▼─────────┐ ┌───────▼──────────┐
│ Intermediate CA 1│ │Intermediate CA 2 │
│   (中间CA 1)     │ │  (中间CA 2)      │
└────────┬─────────┘ └───────┬──────────┘
         │                   │
    ┌────┴────┐         ┌────┴────┐
    │         │         │         │
┌───▼───┐ ┌───▼───┐ ┌────▼──┐ ┌───▼──┐
│Cert 1│ │Cert 2│ │Cert 3 │ │Cert 4│
│(终端)│ │(终端)│ │(终端) │ │(终端)│
└──────┘ └──────┘ └───────┘ └──────┘
```

**Why hierarchical? (为什么分层?)**
- Root CA kept offline for security (根CA离线保证安全)
- Intermediate CAs handle day-to-day operations (中间CA处理日常操作)
- Easier to revoke intermediate CA if compromised (如果泄露更容易撤销中间CA)

**Trust Chain Verification (信任链验证):**

```
1. Browser has list of trusted root CAs (浏览器有可信根CA列表)
2. Server sends certificate + intermediate certificates (服务器发送证书+中间证书)
3. Browser builds chain: Server Cert → Intermediate → Root
4. Verify each certificate's signature using issuer's public key
5. Check validity period, revocation status
6. If all valid: Trust established (如果全部有效：建立信任)
```

**Example: Viewing Certificate Chain (查看证书链):**

```bash
# Using OpenSSL
openssl s_client -connect www.google.com:443 -showcerts

# Output shows:
# Certificate chain
#  0 s:CN=www.google.com
#    i:CN=GTS CA 1C3
#  1 s:CN=GTS CA 1C3
#    i:CN=GTS Root R1
#  2 s:CN=GTS Root R1 (root)
#    i:CN=GTS Root R1 (self-signed)
```

### 7.4 Certificate Revocation (证书撤销)

**Certificate Revocation List (CRL) (证书撤销列表):**

```
Periodically published list of revoked certificates
定期发布的撤销证书列表

CRL Contents (CRL内容):
- Serial numbers of revoked certificates (撤销证书的序列号)
- Revocation date (撤销日期)
- Reason code (原因代码)
- Next update time (下次更新时间)

Process (流程):
1. Client downloads CRL from CA
2. Checks if certificate serial number is in CRL
3. If present: Certificate is revoked (如果存在：证书已撤销)
```

**Disadvantages (缺点):**
- Can be large (several MB) (可能很大)
- Delay between revocation and CRL update (撤销和CRL更新之间的延迟)
- Bandwidth intensive (带宽密集)

**Online Certificate Status Protocol (OCSP):**

```
Real-time certificate status checking
实时证书状态检查

Request (请求):
Client → OCSP Responder: "Is certificate XYZ valid?"

Response (响应):
OCSP Responder → Client:
  - Good (良好)
  - Revoked (已撤销)
  - Unknown (未知)
```

**Advantages (优点):**
- Real-time status (实时状态)
- Smaller messages (更小的消息)
- More efficient (更高效)

**OCSP Stapling (OCSP装订):**

```
Server periodically requests OCSP response and "staples" it to TLS handshake
服务器定期请求OCSP响应并将其"装订"到TLS握手

Benefits (优点):
- Reduces client latency (减少客户端延迟)
- Improves privacy (CA doesn't see client requests) (提高隐私)
- Better performance (更好的性能)
```

---

## 8. Security Protocols (安全协议)

### 8.1 SSL/TLS Protocol

**Overview (概述):**

**Transport Layer Security (TLS)** and its predecessor **Secure Sockets Layer (SSL)** provide secure communication over networks.

**传输层安全协议（TLS）**及其前身**安全套接字层（SSL）**在网络上提供安全通信。

**Protocol Versions (协议版本):**

| Version     | Year     | Status                     | 版本        | 年份     | 状态                 |
| ----------- | -------- | -------------------------- | ----------- | -------- | -------------------- |
| SSL 2.0     | 1995     | Deprecated (弃用)          | SSL 2.0     | 1995     | 已弃用               |
| SSL 3.0     | 1996     | Deprecated (POODLE attack) | SSL 3.0     | 1996     | 已弃用（POODLE攻击） |
| TLS 1.0     | 1999     | Deprecated                 | TLS 1.0     | 1999     | 已弃用               |
| TLS 1.1     | 2006     | Deprecated                 | TLS 1.1     | 2006     | 已弃用               |
| **TLS 1.2** | **2008** | **Current**                | **TLS 1.2** | **2008** | **当前**             |
| **TLS 1.3** | **2018** | **Recommended**            | **TLS 1.3** | **2018** | **推荐**             |

**TLS Handshake (TLS 1.2):**

```
Client                                  Server
 │                                        │
  │─── ClientHello ───────────────────────→ │
  │    - Supported cipher suites           │
  │    - Random value (Client Random)      │
  │    - Supported TLS versions            │
  │                                        │
  │←── ServerHello ────────────────────────── │
  │    - Selected cipher suite              │
  │    - Random value (Server Random)       │
  │←── Certificate ──────────────────────── │
  │    - Server's certificate chain         │
  │←── ServerKeyExchange (if needed) ───── │
  │←── CertificateRequest (optional) ───── │
  │←── ServerHelloDone ──────────────────── │
  │                                        │
  │─── Certificate (if requested) ────────→ │
  │─── ClientKeyExchange ─────────────────→ │
  │    - Pre-master secret (encrypted)      │
  │─── CertificateVerify (if sent cert) ──→ │
  │─── ChangeCipherSpec ──────────────────→ │
  │─── Finished ──────────────────────────→ │
  │    (encrypted with session keys)        │
  │                                        │
  │←── ChangeCipherSpec ──────────────────── │
  │←── Finished ──────────────────────────── │
  │                                        │
  │══════ Encrypted Communication ═════════ │
```

**TLS 1.3 Handshake (Improved):**

```
Client                                  Server
  │                                        │
  │─── ClientHello + KeyShare ────────────→ │
  │    - Supported cipher suites            │
  │    - Key exchange data                  │
  │                                        │
  │                    ┌─── Derive Keys ───┤
  │                    │                    │
  │←── ServerHello + KeyShare ────────────── │
  │←── EncryptedExtensions ────────────────── │
  │←── Certificate ──────────────────────── │
  │←── CertificateVerify ──────────────────── │
  │←── Finished ─────────────────────────── │
  │                                        │
  ├─── Derive Keys ────┐                   │
  │                    │                   │
  │─── Finished ──────────────────────────→ │
  │                                        │
  │══════ Encrypted Communication ═════════ │

Improvement: 0-RTT (Zero Round Trip Time) possible
改进：可实现0-RTT（零往返时间）
```

**Key Derivation (密钥派生):**

```
1. Pre-Master Secret (预主密钥):
   - Generated by client
   - Encrypted with server's public key (RSA)
   - Or derived from DH/ECDH key exchange

2. Master Secret (主密钥):
   Master = PRF(Pre-Master, "master secret", 
                ClientRandom + ServerRandom)

3. Session Keys (会话密钥):
   - Client encryption key (客户端加密密钥)
   - Server encryption key (服务器加密密钥)
   - Client MAC key (客户端MAC密钥)
   - Server MAC key (服务器MAC密钥)
   - IVs (initialization vectors) (初始化向量)
```

**Cipher Suites (密码套件):**

Format: TLS_KeyExchange_WITH_BulkCipher_MAC

```
Examples (示例):

TLS_RSA_WITH_AES_128_CBC_SHA256
  - Key Exchange: RSA
  - Bulk Cipher: AES-128-CBC
  - MAC: SHA-256

TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
  - Key Exchange: ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)
  - Bulk Cipher: AES-256-GCM
  - MAC: SHA-384 (integrated in GCM)

TLS_CHACHA20_POLY1305_SHA256 (TLS 1.3)
  - Stream cipher: ChaCha20
  - AEAD: Poly1305
  - Hash: SHA-256
```

**TLS 1.2 vs TLS 1.3:**

| Aspect        | TLS 1.2               | TLS 1.3                           |
| ------------- | --------------------- | --------------------------------- |
| Handshake RTT | 2-RTT                 | 1-RTT (0-RTT possible)            |
| Cipher suites | 37+ options           | 5 secure options                  |
| Key exchange  | RSA, DH, ECDH         | ECDHE, DHE only (forward secrecy) |
| Deprecated    | MD5, SHA-1, RC4, 3DES | All weak ciphers removed          |
| Performance   | Slower                | 2× faster handshake               |
| Security      | Good                  | Excellent                         |

### 8.2 IPsec Protocol

**Overview (概述):**

**IPsec (Internet Protocol Security)** provides network-layer security for IP communications.

**IPsec（互联网协议安全）**为IP通信提供网络层安全。

**Components (组件):**

```
1. Authentication Header (AH) (认证头):
   - Provides integrity and authentication
   - 提供完整性和认证
   - Does NOT provide confidentiality
   - 不提供机密性

2. Encapsulating Security Payload (ESP) (封装安全载荷):
   - Provides confidentiality, integrity, and authentication
   - 提供机密性、完整性和认证
   - Most commonly used
   - 最常用

3. Internet Key Exchange (IKE) (互联网密钥交换):
   - Establishes security associations (SA)
   - 建立安全关联
   - Negotiates cryptographic parameters
   - 协商密码参数
```

**Modes of Operation (操作模式):**

**1. Transport Mode (传输模式):**

```
Original IP Packet:
[IP Header][TCP/UDP Header][Data]

IPsec Transport Mode:
[IP Header][IPsec Header][TCP/UDP Header][Data][IPsec Trailer]
             ↑___________ Protected ___________↑

Use case: End-to-end communication between two hosts
用例：两台主机之间的端到端通信
```

**2. Tunnel Mode (隧道模式):**

```
Original IP Packet:
[IP Header][TCP/UDP Header][Data]

IPsec Tunnel Mode:
[New IP Header][IPsec Header][Original IP Packet][IPsec Trailer]
                ↑__________ Protected __________↑

Use case: VPN, site-to-site connections
用例：VPN、站点到站点连接
```

**IKE Protocol (IKE协议):**

```
Phase 1: Establish IKE SA (建立IKE安全关联)
  - Authenticate peers (认证对等方)
  - Establish secure channel for Phase 2
  - Modes: Main Mode (6 messages) or Aggressive Mode (3 messages)

Phase 2: Establish IPsec SA (建立IPsec安全关联)
  - Negotiate encryption/authentication algorithms
  - 协商加密/认证算法
  - Exchange keys for data protection
  - 交换数据保护密钥
```

### 8.3 SSH Protocol

**Overview (概述):**

**SSH (Secure Shell)** provides secure remote access and command execution.

**SSH（安全外壳）**提供安全的远程访问和命令执行。

**SSH Protocol Layers (SSH协议层):**

```
┌────────────────────────────────────┐
│ SSH Connection Protocol (SSH连接协议)│
│ - Multiple channels                │
│ - Port forwarding                  │
├────────────────────────────────────┤
│ SSH Authentication Protocol        │
│ (SSH认证协议)                       │
│ - Password, public key, etc.       │
├────────────────────────────────────┤
│ SSH Transport Protocol             │
│ (SSH传输协议)                       │
│ - Encryption, integrity, compression│
├────────────────────────────────────┤
│ TCP/IP                             │
└────────────────────────────────────┘
```

**Authentication Methods (认证方法):**

**1. Password Authentication (密码认证):**
```
- Simplest method (最简单的方法)
- User provides username + password
- Vulnerable to brute force (易受暴力破解)
```

**2. Public Key Authentication (公钥认证):**
```
Setup (设置):
1. User generates key pair on client
   用户在客户端生成密钥对
2. Public key copied to server (~/.ssh/authorized_keys)
   公钥复制到服务器

Authentication (认证):
1. Server sends challenge (encrypted with public key)
   服务器发送挑战（用公钥加密）
2. Client decrypts with private key and responds
   客户端用私钥解密并响应
3. Server verifies response
   服务器验证响应

Advantages (优点):
- More secure than passwords (比密码更安全)
- Can be automated (without passwords) (可自动化)
```

**3. Host-Based Authentication (基于主机的认证):**
```
- Authenticates entire host machine
- 认证整个主机
- Less common (较少使用)
```

**SSH Key Generation Example (SSH密钥生成示例):**

```bash
# Generate RSA key pair (生成RSA密钥对)
ssh-keygen -t rsa -b 4096 -C "user@example.com"

# Generate Ed25519 key pair (recommended) (生成Ed25519密钥对 - 推荐)
ssh-keygen -t ed25519 -C "user@example.com"

# Copy public key to server (复制公钥到服务器)
ssh-copy-id user@server.com

# Connect using key (使用密钥连接)
ssh user@server.com
```

**SSH Tunneling / Port Forwarding (SSH隧道/端口转发):**

```bash
# Local Port Forwarding (本地端口转发)
# Access remote service through SSH tunnel
ssh -L 8080:remote_server:80 user@ssh_server
# Now localhost:8080 → remote_server:80

# Remote Port Forwarding (远程端口转发)
# Expose local service to remote network
ssh -R 9090:localhost:3000 user@ssh_server
# Now ssh_server:9090 → localhost:3000

# Dynamic Port Forwarding (SOCKS proxy) (动态端口转发)
ssh -D 1080 user@ssh_server
# Creates SOCKS proxy on localhost:1080
```

---

## 9. Cryptographic Attacks and Defense (密码攻击与防御)

### 9.1 Types of Cryptanalysis (密码分析类型)

**1. Ciphertext-Only Attack (唯密文攻击):**
```
Attacker has: Ciphertext only
攻击者拥有：仅密文

Goal: Deduce plaintext or key
目标：推断明文或密钥

Difficulty: Hardest (most realistic scenario)
难度：最难（最现实的场景）
```

**2. Known-Plaintext Attack (已知明文攻击):**
```
Attacker has: Plaintext-ciphertext pairs
攻击者拥有：明文-密文对

Goal: Deduce key or decrypt other ciphertexts
目标：推断密钥或解密其他密文

Example: Many WWII codebreaking efforts
示例：许多二战密码破译工作
```

**3. Chosen-Plaintext Attack (选择明文攻击):**
```
Attacker can: Choose plaintexts to encrypt
攻击者可以：选择要加密的明文

Goal: Deduce key
目标：推断密钥

Example: Adaptive chosen-plaintext attack on RSA without padding
示例：对无填充RSA的自适应选择明文攻击
```

**4. Chosen-Ciphertext Attack (选择密文攻击):**
```
Attacker can: Choose ciphertexts to decrypt
攻击者可以：选择要解密的密文

Goal: Deduce key or plaintext
目标：推断密钥或明文

Example: Attack on PKCS#1 v1.5 padding
示例：对PKCS#1 v1.5填充的攻击
```

### 9.2 Common Attacks (常见攻击)

**Brute Force Attack (暴力破解攻击):**

```
Method: Try all possible keys
方法：尝试所有可能的密钥

Time Complexity (assuming 10^12 keys/second):
时间复杂度（假设每秒10^12个密钥）：

| Key Size      | Combinations | Time to Break |
| ------------- | ------------ | ------------- |
| 56 bits (DES) | 2^56         | < 1 day       |
| 128 bits      | 2^128        | 10^19 years   |
| 256 bits      | 2^256        | 10^58 years   |

Defense (防御):
- Use sufficiently long keys (≥128 bits)
- 使用足够长的密钥（≥128位）
```

**Dictionary Attack (字典攻击):**

```
Target: Password-based systems
目标：基于密码的系统

Method: Try common passwords from dictionary
方法：从字典中尝试常见密码

Common passwords:
- 123456, password, qwerty, 12345678
- admin, welcome, 111111, abc123

Defense (防御):
- Enforce strong password policies
- 强制实施强密码策略
- Use slow hash functions (bcrypt, scrypt, Argon2)
- 使用慢哈希函数
- Implement rate limiting
- 实施速率限制
- Multi-factor authentication (MFA)
- 多因素认证
```

**Rainbow Table Attack (彩虹表攻击):**

```
Concept: Pre-computed hash chains
概念：预计算的哈希链

Process:
1. Generate hash chains for all possible passwords
   为所有可能的密码生成哈希链
2. Store in compressed "rainbow table"
   存储在压缩的"彩虹表"中
3. Look up hash to find password
   查找哈希以找到密码

Defense (防御):
- Add salt to hashes (makes rainbow tables ineffective)
- 向哈希添加盐值（使彩虹表无效）

Example:
Without salt:
  Hash("password") always = 5f4dcc3b5aa765d61d8327deb882cf99

With salt:
  Hash("password" + salt1) = a1b2c3d4...
  Hash("password" + salt2) = e5f6g7h8...
  (Different for each user)
```

**Man-in-the-Middle (MITM) Attack (中间人攻击):**

```
Scenario:
Alice ←→ [Attacker] ←→ Bob

Attacker:
1. Intercepts communication between Alice and Bob
   拦截Alice和Bob之间的通信
2. Impersonates Bob to Alice
   向Alice冒充Bob
3. Impersonates Alice to Bob
   向Bob冒充Alice
4. Can read/modify all messages
   可以读取/修改所有消息

Defense (防御):
- Use authenticated key exchange (使用认证的密钥交换)
- Verify certificates (PKI) (验证证书)
- Certificate pinning (证书固定)
- Out-of-band verification (带外验证)
```

**Side-Channel Attacks (侧信道攻击):**

**1. Timing Attack (时序攻击):**
```
Exploit: Different operations take different times
利用：不同操作花费不同时间

Example:
- Measure RSA decryption time
- 测量RSA解密时间
- Deduce private key bits
- 推断私钥位

Defense:
- Use constant-time implementations
- 使用恒定时间实现
- Add random delays (blinding)
- 添加随机延迟（盲化）
```

**2. Power Analysis Attack (功耗分析攻击):**
```
Exploit: Measure power consumption during crypto operations
利用：测量密码操作期间的功耗

Types:
- Simple Power Analysis (SPA) (简单功耗分析)
- Differential Power Analysis (DPA) (差分功耗分析)

Defense:
- Add noise to power consumption
- 向功耗添加噪声
- Use hardware countermeasures
- 使用硬件对策
```

**3. Cache Timing Attack (缓存时序攻击):**
```
Exploit: Observe cache access patterns
利用：观察缓存访问模式

Defense:
- Constant-time table lookups
- 恒定时间表查找
- Disable cache for crypto operations
- 为密码操作禁用缓存
```

**Padding Oracle Attack (填充预言机攻击):**

```
Target: CBC mode with PKCS#7 padding
目标：使用PKCS#7填充的CBC模式

Exploit:
- Server returns different errors for:
  服务器为以下情况返回不同错误：
  1. Invalid padding (无效填充)
  2. Valid padding but invalid data (有效填充但数据无效)
- Attacker uses this to decrypt ciphertext byte-by-byte
- 攻击者使用此信息逐字节解密密文

Defense (防御):
- Return generic error messages
- 返回通用错误消息
- Use authenticated encryption (GCM)
- 使用认证加密
```

### 9.3 Best Practices (最佳实践)

**Cryptographic Best Practices (密码学最佳实践):**

```
✓ DO (应该做):

1. Use established, peer-reviewed algorithms
   使用已建立的、经过同行评审的算法
   - AES, RSA-2048+, SHA-256, etc.

2. Use appropriate key sizes
   使用适当的密钥大小
   - Symmetric: ≥128 bits
   - RSA: ≥2048 bits
   - ECC: ≥256 bits

3. Use cryptographically secure random number generators
   使用密码学安全的随机数生成器
   - os.urandom(), secrets module, /dev/urandom

4. Use authenticated encryption
   使用认证加密
   - AES-GCM, ChaCha20-Poly1305

5. Use proper padding schemes
   使用适当的填充方案
   - OAEP for RSA, PKCS#7 for AES

6. Implement perfect forward secrecy
   实施完美前向保密
   - Use ephemeral key exchange (ECDHE, DHE)

7. Regularly rotate keys
   定期轮换密钥

8. Use salts for password hashing
   密码哈希使用盐值
   - Unique salt per user

9. Implement rate limiting
   实施速率限制
   - Prevent brute force attacks

10. Keep cryptographic libraries updated
    保持密码库更新

✗ DON'T (不应该做):

1. Don't implement your own crypto algorithms
   不要实现自己的密码算法
   - "Don't roll your own crypto"

2. Don't use deprecated algorithms
   不要使用已弃用的算法
   - MD5, SHA-1, DES, 3DES, RC4

3. Don't reuse IVs/nonces
   不要重用IV/nonce
   - Each encryption must use unique IV

4. Don't use ECB mode
   不要使用ECB模式
   - Reveals patterns in plaintext

5. Don't store passwords in plaintext or reversible encryption
   不要以明文或可逆加密存储密码
   - Use slow hash functions (Argon2, bcrypt)

6. Don't ignore certificate warnings
   不要忽略证书警告

7. Don't use small key sizes
   不要使用小密钥大小
   - RSA-1024 is too weak

8. Don't trust user input
   不要信任用户输入
   - Always validate and sanitize
```

---

## 10. Modern Cryptography Applications (现代密码学应用)

### 10.1 Blockchain Cryptography (区块链密码学)

**Hash Pointers and Merkle Trees (哈希指针和默克尔树):**

```
Merkle Tree Structure:

         Root Hash (根哈希)
        /            \
       /              \
   Hash01          Hash23
    /  \            /  \
   /    \          /    \
Hash0 Hash1   Hash2  Hash3
  |     |       |      |
 TX0   TX1     TX2    TX3
(Transactions 交易)

Benefits (优点):
- Efficient verification (高效验证)
- Tamper-evident (防篡改)
- Used in Bitcoin, Ethereum
```

**Digital Signatures in Blockchain (区块链中的数字签名):**

```
Bitcoin uses ECDSA (secp256k1 curve):

Transaction Signing (交易签名):
1. Create transaction
   创建交易
2. Sign with private key: Sign(PrivKey, TxHash)
   用私钥签名
3. Broadcast transaction + public key + signature
   广播交易+公钥+签名

Verification (验证):
1. Derive Bitcoin address from public key
   从公钥派生比特币地址
2. Verify signature: Verify(PubKey, TxHash, Signature)
   验证签名
3. Check address matches sender
   检查地址是否匹配发送者
```

**Zero-Knowledge Proofs (零知识证明):**

```
Concept: Prove knowledge of secret without revealing it
概念：证明拥有秘密的知识而不泄露它

Example - Proving you know password without revealing it:
Prover to Verifier: "I know the password"
Verifier: Sends challenge
Prover: Responds using password (without revealing it)
Verifier: Checks response

Applications (应用):
- Zcash (privacy cryptocurrency) (隐私加密货币)
- Private authentication (隐私认证)
- zk-SNARKs, zk-STARKs
```

### 10.2 Homomorphic Encryption (同态加密)

**Concept (概念):**

Perform computations on encrypted data without decrypting it.

对加密数据执行计算而无需解密。

```
Regular encryption:
Encrypt(a) + Encrypt(b) ≠ Encrypt(a + b)

Homomorphic encryption:
Encrypt(a) ⊕ Encrypt(b) = Encrypt(a + b)

Example:
a = 5, b = 3
E(5) ⊕ E(3) = E(8)
Decrypt(E(8)) = 8  ✓
```

**Types (类型):**

```
1. Partially Homomorphic Encryption (PHE) (部分同态加密):
   - Supports only one operation (addition OR multiplication)
   - 仅支持一种操作（加法或乘法）
   - Examples: RSA (multiplication), Paillier (addition)

2. Somewhat Homomorphic Encryption (SHE) (稍微同态加密):
   - Limited number of operations
   - 有限次数的操作

3. Fully Homomorphic Encryption (FHE) (全同态加密):
   - Unlimited operations (addition and multiplication)
   - 无限次操作（加法和乘法）
   - Very slow (currently impractical for most uses)
   - 非常慢（目前对大多数用途不实用）
```

**Applications (应用):**

```
- Cloud computing with data privacy
  云计算中的数据隐私
- Secure voting systems
  安全投票系统
- Private information retrieval
  隐私信息检索
- Medical data analysis (preserve privacy)
  医疗数据分析（保护隐私）
```

### 10.3 Quantum Cryptography (量子密码学)

**Quantum Key Distribution (QKD) (量子密钥分发):**

**BB84 Protocol:**

```
1. Alice sends photons with random polarizations
   Alice发送具有随机偏振的光子

2. Bob measures with random bases
   Bob用随机基测量

3. Alice and Bob compare bases (publicly)
   Alice和Bob比较基（公开）

4. Keep bits where bases matched
   保留基匹配的位

5. Result: Shared secret key
   结果：共享密钥

Security: Any eavesdropping disturbs quantum state (detectable)
安全性：任何窃听都会扰乱量子态（可检测）
```

**Quantum Threat to Classical Crypto (量子威胁):**

```
Shor's Algorithm (Quantum Computer):
- Can factor large numbers efficiently
- 可以高效分解大数
- Breaks RSA, ECC, DH
- 破解RSA、ECC、DH

Grover's Algorithm:
- Speeds up brute force search
- 加速暴力搜索
- Reduces effective key length by half
- 将有效密钥长度减半
- AES-128 → 64-bit security, AES-256 → 128-bit security
```

### 10.4 Post-Quantum Cryptography (后量子密码学)

**Goal (目标):**

Develop algorithms resistant to quantum computer attacks.

开发抵抗量子计算机攻击的算法。

**NIST Post-Quantum Cryptography Standardization:**

```
Selected Algorithms (2022) (选定算法):

1. Public Key Encryption / Key Establishment:
   - CRYSTALS-Kyber (lattice-based) (基于格)

2. Digital Signatures:
   - CRYSTALS-Dilithium (lattice-based)
   - FALCON (lattice-based)
   - SPHINCS+ (hash-based) (基于哈希)
```

**Approaches (方法):**

```
1. Lattice-based cryptography (基于格的密码学):
   - Based on hard problems in lattice theory
   - 基于格理论中的难题
   - Examples: NTRU, LWE

2. Code-based cryptography (基于编码的密码学):
   - Based on error-correcting codes
   - 基于纠错码
   - Example: McEliece cryptosystem

3. Hash-based signatures (基于哈希的签名):
   - Based on hash functions
   - 基于哈希函数
   - Example: SPHINCS+

4. Multivariate cryptography (多变量密码学):
   - Based on multivariate polynomial equations
   - 基于多变量多项式方程

5. Isogeny-based cryptography (基于同源的密码学):
   - Based on elliptic curve isogenies
   - 基于椭圆曲线同源
```

**Migration Timeline (迁移时间表):**

```
2024-2025: Finalize PQC standards (最终确定PQC标准)
2025-2030: Transition period (过渡期)
  - Hybrid classical + post-quantum (混合经典+后量子)
  - Gradual deployment (逐步部署)
2030+: Post-quantum becomes standard (后量子成为标准)
```

### 10.5 Secure Multi-Party Computation (安全多方计算)

**Secret Sharing (秘密共享):**

**Shamir's Secret Sharing (Shamir秘密共享):**

```
Concept: Split secret into n shares, require t shares to reconstruct
概念：将秘密分成n份，需要t份才能重建

(t, n) threshold scheme:
- Any t shares can reconstruct secret
- 任意t份可以重建秘密
- Fewer than t shares reveal nothing
- 少于t份不泄露任何信息

Example (2,3):
Secret S = 42
Share 1: 15
Share 2: 28
Share 3: 67

Any 2 shares → S = 42
Any 1 share → No information about S

Applications (应用):
- Cryptocurrency wallets (multi-sig)
- 加密货币钱包（多签）
- Key escrow (密钥托管)
- Distributed trust (分布式信任)
```

---

## Summary and Conclusion (总结与结论)

### Key Takeaways (关键要点)

**1. Cryptography Fundamentals (密码学基础):**
- Provides confidentiality, integrity, authentication, non-repudiation
- 提供机密性、完整性、认证性、不可否认性
- Security depends on key secrecy, not algorithm secrecy (Kerckhoffs's Principle)
- 安全性依赖密钥保密性，而非算法保密性

**2. Symmetric Encryption (对称加密):**
- Fast, efficient for bulk data (快速，适合大量数据)
- Key distribution problem (密钥分发问题)
- Use AES (128/256-bit) (使用AES)
- Avoid ECB mode, prefer GCM (避免ECB模式，首选GCM)

**3. Asymmetric Encryption (非对称加密):**
- Solves key distribution, enables digital signatures (解决密钥分发，支持数字签名)
- Slower than symmetric (比对称加密慢)
- Use RSA-2048+ or ECC-256+ (使用RSA-2048+或ECC-256+)
- Hybrid approach: Asymmetric for key exchange + Symmetric for data (混合方法)

**4. Hash Functions (哈希函数):**
- Integrity verification, digital signatures, password storage (完整性验证、数字签名、密码存储)
- Use SHA-256 or SHA-3 (使用SHA-256或SHA-3)
- For passwords: Use Argon2, bcrypt, or scrypt with salt (密码使用Argon2等加盐)

**5. Digital Signatures (数字签名):**
- Provides authentication and non-repudiation (提供认证和不可否认性)
- Hash then sign (first hash, then encrypt hash with private key) (先哈希再签名)

**6. Key Management (密钥管理):**
- Critical component of cryptographic systems (密码系统的关键组件)
- Secure generation, storage, distribution, rotation, destruction (安全生成、存储、分发、轮换、销毁)
- Use HSM for high-security applications (高安全应用使用HSM)

**7. PKI (公钥基础设施):**
- Framework for managing digital certificates (管理数字证书的框架)
- Trust chain from root CA to end-entity (从根CA到终端实体的信任链)
- Certificate revocation: CRL and OCSP (证书撤销)

**8. Security Protocols (安全协议):**
- TLS 1.3 for web security (recommended) (Web安全推荐TLS 1.3)
- IPsec for VPNs and network security (VPN和网络安全使用IPsec)
- SSH for secure remote access (安全远程访问使用SSH)

**9. Cryptographic Attacks (密码攻击):**
- Brute force, dictionary, rainbow tables (暴力、字典、彩虹表)
- MITM, side-channel attacks (中间人、侧信道)
- Defense: Strong keys, salts, authenticated encryption, constant-time implementations
- 防御：强密钥、盐值、认证加密、恒定时间实现

**10. Modern Applications (现代应用):**
- Blockchain: Hash pointers, digital signatures, zero-knowledge proofs
  区块链：哈希指针、数字签名、零知识证明
- Homomorphic encryption: Compute on encrypted data
  同态加密：在加密数据上计算
- Quantum cryptography: QKD for provably secure key exchange
  量子密码：QKD实现可证明安全的密钥交换
- Post-quantum cryptography: Preparing for quantum computers
  后量子密码：为量子计算机做准备

### Future Trends (未来趋势)

```
1. Quantum-Resistant Cryptography (抗量子密码学)
   - Migration to post-quantum algorithms
   - 迁移到后量子算法
   - Timeline: 2025-2030

2. Lightweight Cryptography (轻量级密码学)
   - For IoT and resource-constrained devices
   - 用于物联网和资源受限设备

3. Privacy-Preserving Technologies (隐私保护技术)
   - Zero-knowledge proofs
   - Fully homomorphic encryption

4. Blockchain and Distributed Ledger (区块链和分布式账本)
   - Continued innovation in consensus and privacy
   - 共识和隐私方面的持续创新

5. AI and Cryptography (AI与密码学)
   - AI-assisted cryptanalysis
   - AI密码分析
   - Adversarial ML in crypto systems
   - 密码系统中的对抗性机器学习
```

### Final Recommendations (最终建议)

```
For System Architects (系统架构师):
✓ Always use established cryptographic libraries (OpenSSL, libsodium)
  始终使用已建立的密码库
✓ Implement defense in depth (多层防御)
✓ Plan for crypto-agility (enable algorithm updates)
  规划密码敏捷性（支持算法更新）
✓ Regular security audits and penetration testing
  定期安全审计和渗透测试
✓ Stay informed about vulnerabilities and best practices
  及时了解漏洞和最佳实践

For Developers (开发人员):
✓ Never roll your own crypto (永远不要自创密码)
✓ Use high-level APIs when possible (尽可能使用高级API)
✓ Validate all inputs (验证所有输入)
✓ Handle errors securely (avoid information leakage)
  安全处理错误（避免信息泄露）
✓ Keep dependencies updated (保持依赖更新)

For Organizations (组织):
✓ Develop comprehensive cryptographic policies
  制定全面的密码政策
✓ Implement key management procedures
  实施密钥管理程序
✓ Train personnel on security best practices
  培训人员安全最佳实践
✓ Prepare for post-quantum transition
  为后量子转型做准备
✓ Comply with relevant regulations (GDPR, HIPAA, etc.)
  遵守相关法规
```

---

**Conclusion (结论):**

Encryption and decryption are fundamental pillars of modern information security. From classical ciphers to quantum-resistant algorithms, cryptography continues to evolve to meet emerging threats. Understanding these concepts—symmetric and asymmetric encryption, hash functions, digital signatures, key management, PKI, and security protocols—is essential for building secure systems in today's digital world.

加密和解密是现代信息安全的基本支柱。从经典密码到抗量子算法，密码学不断发展以应对新兴威胁。理解这些概念——对称和非对称加密、哈希函数、数字签名、密钥管理、PKI和安全协议——对于在当今数字世界中构建安全系统至关重要。

As we move toward a future with quantum computers and increasingly sophisticated attacks, staying informed about cryptographic best practices and emerging technologies is more important than ever. The key to successful cryptographic implementation lies not just in choosing the right algorithms, but in proper key management, secure implementation, and continuous vigilance against evolving threats.

随着我们迈向量子计算机和日益复杂的攻击的未来，及时了解密码学最佳实践和新兴技术比以往任何时候都更加重要。成功实施密码学的关键不仅在于选择正确的算法，还在于适当的密钥管理、安全实施以及对不断演变的威胁保持持续警惕。

---

**Document End (文档结束)**