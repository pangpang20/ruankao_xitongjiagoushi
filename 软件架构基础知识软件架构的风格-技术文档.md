# Software Architecture Styles - Comprehensive Technical Documentation

# 软件架构基础知识软件架构的风格 - 完整技术文档

---

## Table of Contents | 目录

1. [Introduction | 概述](#introduction--概述)
2. [Software Architecture Overview | 软件架构概述](#software-architecture-overview--软件架构概述)
3. [Classic Architecture Styles | 经典架构风格](#classic-architecture-styles--经典架构风格)
4. [Distributed Architecture Styles | 分布式架构风格](#distributed-architecture-styles--分布式架构风格)
5. [Modern Architecture Styles | 现代架构风格](#modern-architecture-styles--现代架构风格)
6. [Architecture Selection and Evolution | 架构选择与演进](#architecture-selection-and-evolution--架构选择与演进)
7. [Case Studies and Best Practices | 案例分析与最佳实践](#case-studies-and-best-practices--案例分析与最佳实践)
8. [Exam Focus Points | 考试要点](#exam-focus-points--考试要点)

---

## Introduction | 概述

### What is Software Architecture? | 什么是软件架构?

**English:**

**Software Architecture** is the fundamental organization of a system, embodied in its components, their relationships to each other and the environment, and the principles governing its design and evolution. (IEEE 1471-2000)

In modern software engineering, architecture serves as the blueprint that guides development, ensures quality attributes, and enables system evolution. It represents the high-level structure of a software system and the discipline of creating such structures.

**Key Aspects | 关键方面**:

1. **Structure | 结构**: How components are organized and interconnected
2. **Behavior | 行为**: How components interact and collaborate
3. **Quality Attributes | 质量属性**: Non-functional requirements (performance, scalability, security)
4. **Decisions | 决策**: Architectural choices, trade-offs, and rationale

**Why Architecture Matters | 架构的重要性**:

**For Development | 对开发**:
- **Blueprint | 蓝图**: Provides a shared understanding among stakeholders
- **Early Decisions | 早期决策**: Major decisions made early when change is cheaper
- **Quality Foundation | 质量基础**: Architecture determines achievable quality attributes
- **Risk Mitigation | 风险缓解**: Identifies and addresses risks early

**For Business | 对业务**:
- **Time-to-Market | 上市时间**: Well-designed architecture accelerates development
- **Cost Control | 成本控制**: Prevents expensive rework and redesign
- **Scalability | 可扩展性**: Supports business growth and evolution
- **Competitive Advantage | 竞争优势**: Enables innovation and differentiation

**For System Architects Exam | 对系统架构设计师考试**:
- **Core Topic | 核心主题**: Architecture accounts for 15-20% of exam content
- **Case Analysis | 案例分析**: Architecture selection and design scenarios
- **Technical Depth | 技术深度**: Understanding of architecture styles, patterns, quality attributes
- **Practical Application | 实践应用**: Recognize appropriate architecture for given requirements

**Architecture Evolution | 架构演进**:
```
1960s-1970s:  Monolithic, Procedural
              单体、过程式
              ↓
1980s-1990s:  Client-Server, Layered
              客户端-服务器、分层
              ↓
2000s:        SOA, Web Services
              SOA、Web服务
              ↓
2010s:        Microservices, Cloud-Native
              微服务、云原生
              ↓
2020s:        Serverless, Mesh, Edge Computing
              无服务器、网格、边缘计算
```

**中文:**

**软件架构**是系统的基本组织结构，体现在其组件、组件之间及与环境的关系，以及指导其设计和演进的原则中。（IEEE 1471-2000）

在现代软件工程中，架构作为指导开发、确保质量属性、使系统演进的蓝图。它代表了软件系统的高层结构和创建这种结构的学科。

---

## Software Architecture Overview | 软件架构概述

### 1.1 Definition and Core Concepts | 定义与核心概念

**English:**

**Software Architecture** comprises the fundamental structures of a software system, the discipline of creating such structures, and the documentation of these structures.

**Core Elements | 核心要素**:

**1. Components | 组件**
- **Definition | 定义**: Modular, deployable, and replaceable parts of a system
- **Examples | 示例**: Services, modules, libraries, databases
- **Characteristics | 特征**: Encapsulation, interfaces, dependencies

**2. Connectors | 连接器**
- **Definition | 定义**: Mechanisms that mediate communication among components
- **Examples | 示例**: API calls, message queues, HTTP requests, database connections
- **Characteristics | 特征**: Communication protocols, data formats, synchronization

**3. Constraints | 约束**
- **Definition | 定义**: Rules and restrictions on component interactions
- **Examples | 示例**: Layer restrictions, communication patterns, data flow rules
- **Characteristics | 特征**: Architectural styles, design patterns, compliance requirements

**Architecture vs. Design | 架构vs设计**:

| Aspect<br/>方面                 | Architecture<br/>架构                                   | Design<br/>设计                                |
| ------------------------------- | ------------------------------------------------------- | ---------------------------------------------- |
| **Level<br/>层次**              | High-level, strategic<br/>高层次、战略性                | Low-level, tactical<br/>低层次、战术性         |
| **Focus<br/>关注**              | Structure, quality attributes<br/>结构、质量属性        | Algorithms, data structures<br/>算法、数据结构 |
| **Scope<br/>范围**              | System-wide<br/>系统范围                                | Component/module<br/>组件/模块                 |
| **Stakeholders<br/>利益相关者** | Business, architects, managers<br/>业务、架构师、管理者 | Developers, testers<br/>开发者、测试者         |
| **Decisions<br/>决策**          | Harder to change<br/>更难改变                           | Easier to change<br/>更容易改变                |
| **Impact<br/>影响**             | Affects entire system<br/>影响整个系统                  | Affects specific components<br/>影响特定组件   |

**中文:**

**软件架构**包括软件系统的基本结构、创建这些结构的学科以及这些结构的文档。

**核心要素**: 组件、连接器、约束

**[Exam Focus | 考试重点]**: 
- Understand IEEE 1471 definition of software architecture
- Differentiate architecture from design
- Identify core elements: components, connectors, constraints

### 1.2 Architecture Views and Modeling | 架构视图与建模

**English:**

**4+1 View Model** (Philippe Kruchten, 1995) provides multiple perspectives on software architecture to address different stakeholder concerns.

**4+1 Architecture Views | 4+1架构视图**:

```
                    ┌───────────────┐
                    │   Scenarios   │
                    │   Use Cases   │
                    │   场景/用例   │
                    └───────┬───────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
   ┌────▼────┐         ┌───▼────┐         ┌───▼────┐
   │ Logical │         │Process │         │Physical│
   │ View    │         │ View   │         │ View   │
   │ 逻辑视图│         │进程视图│         │物理视图│
   └────┬────┘         └───┬────┘         └───┬────┘
        │                  │                   │
        └──────────────────┼───────────────────┘
                           │
                      ┌────▼────┐
                      │Development│
                      │  View     │
                      │ 开发视图  │
                      └───────────┘
```

#### 1. Logical View | 逻辑视图

**Purpose | 目的**: Describes functionality provided to end-users

**Stakeholders | 利益相关者**: End-users, analysts

**Elements | 元素**: Classes, packages, interfaces, collaborations

**Diagrams | 图表**: Class diagrams, object diagrams, state diagrams

**Example - E-commerce Logical View | 示例 - 电商逻辑视图**:
```
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│   User      │         │   Order     │         │   Product   │
│   用户      │────────→│   订单      │←────────│   产品      │
│             │  places │             │ contains│             │
└─────────────┘         └─────────────┘         └─────────────┘
       │                       │                        │
       │                       │                        │
       ▼                       ▼                        ▼
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│   Cart      │         │   Payment   │         │  Inventory  │
│   购物车    │         │   支付      │         │   库存      │
└─────────────┘         └─────────────┘         └─────────────┘
```

#### 2. Development View | 开发视图

**Purpose | 目的**: Describes system organization from programmer's perspective

**Stakeholders | 利益相关者**: Developers, testers

**Elements | 元素**: Modules, libraries, layers, subsystems

**Diagrams | 图表**: Package diagrams, component diagrams

**Example - Layered Development View | 示例 - 分层开发视图**:
```
┌───────────────────────────────────────────────────┐
│            Presentation Layer                     │
│            表示层                                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐       │
│  │Web UI    │  │Mobile UI │  │Admin UI  │       │
│  └──────────┘  └──────────┘  └──────────┘       │
├───────────────────────────────────────────────────┤
│            Business Logic Layer                   │
│            业务逻辑层                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐       │
│  │User Svc  │  │Order Svc │  │Product   │       │
│  │          │  │          │  │Svc       │       │
│  └──────────┘  └──────────┘  └──────────┘       │
├───────────────────────────────────────────────────┤
│            Data Access Layer                      │
│            数据访问层                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐       │
│  │UserRepo  │  │OrderRepo │  │ProductRep│       │
│  └──────────┘  └──────────┘  └──────────┘       │
├───────────────────────────────────────────────────┤
│            Database                               │
│            数据库                                 │
│  ┌──────────────────────────────────────────┐    │
│  │         PostgreSQL / MySQL               │    │
│  └──────────────────────────────────────────┘    │
└───────────────────────────────────────────────────┘
```

#### 3. Process View | 进程视图

**Purpose | 目的**: Describes system's concurrency and synchronization

**Stakeholders | 利益相关者**: System integrators, performance engineers

**Elements | 元素**: Processes, threads, tasks

**Diagrams | 图表**: Activity diagrams, sequence diagrams

**Example - Concurrent Processes | 示例 - 并发进程**:
```
User Request
     │
     ▼
┌─────────────────────────────────────────┐
│          Load Balancer                  │
│          负载均衡器                     │
└────┬────────────┬───────────┬───────────┘
     │            │           │
     ▼            ▼           ▼
┌─────────┐  ┌─────────┐  ┌─────────┐
│Web      │  │Web      │  │Web      │
│Server 1 │  │Server 2 │  │Server 3 │
│Web服务器│  │Web服务器│  │Web服务器│
└────┬────┘  └────┬────┘  └────┬────┘
     │            │            │
     └────────────┼────────────┘
                  │
                  ▼
     ┌────────────────────────┐
     │  Application Servers   │
     │  应用服务器集群        │
     │  (Thread Pool)         │
     └────────┬───────────────┘
              │
     ┌────────┼────────┐
     │        │        │
     ▼        ▼        ▼
┌─────────┐ ┌────────┐ ┌─────────┐
│DB Read  │ │DB Write│ │ Cache   │
│Replica  │ │Master  │ │ Redis   │
│读副本   │ │写主库  │ │ 缓存    │
└─────────┘ └────────┘ └─────────┘
```

#### 4. Physical View | 物理视图

**Purpose | 目的**: Describes system's deployment on hardware

**Stakeholders | 利益相关者**: System engineers, operators

**Elements | 元素**: Nodes, devices, network

**Diagrams | 图表**: Deployment diagrams

**Example - Physical Deployment | 示例 - 物理部署**:
```
┌─────────────────────────────────────────────────────┐
│                    Internet                         │
│                    互联网                           │
└──────────────────────┬──────────────────────────────┘
                       │
         ┌─────────────▼─────────────┐
         │      CDN (Cloudflare)     │
         │      CDN (内容分发网络)   │
         └─────────────┬─────────────┘
                       │
         ┌─────────────▼─────────────┐
         │   Load Balancer (AWS ELB) │
         │   负载均衡器              │
         └──────┬──────────┬─────────┘
                │          │
       ┌────────▼───┐  ┌──▼─────────┐
       │ Web Server │  │ Web Server │
       │ (EC2)      │  │ (EC2)      │
       │ Web服务器  │  │ Web服务器  │
       └────────┬───┘  └──┬─────────┘
                │         │
                └────┬────┘
                     │
          ┌──────────▼──────────┐
          │  App Server Cluster │
          │  (Kubernetes)       │
          │  应用服务器集群     │
          └──────────┬──────────┘
                     │
      ┌──────────────┼──────────────┐
      │              │              │
┌─────▼─────┐  ┌────▼────┐  ┌──────▼──────┐
│PostgreSQL │  │  Redis  │  │   Kafka     │
│(RDS)      │  │(ElastiC │  │(MSK)        │
│数据库     │  │Cache)   │  │消息队列     │
│           │  │缓存     │  │             │
└───────────┘  └─────────┘  └─────────────┘
```

#### 5. Scenarios (Use Cases) | 场景（用例）

**Purpose | 目的**: Validates and illustrates architecture through key scenarios

**Stakeholders | 利益相关者**: All stakeholders

**Elements | 元素**: Use cases, quality scenarios

**Example - User Login Scenario | 示例 - 用户登录场景**:
```
┌────────┐                                      ┌──────────┐
│  User  │                                      │  System  │
│  用户  │                                      │  系统    │
└───┬────┘                                      └────┬─────┘
    │  1. Enter credentials (输入凭证)              │
    │─────────────────────────────────────────────→│
    │                                               │
    │  2. Validate credentials (验证凭证)           │
    │                                      ┌────────▼────────┐
    │                                      │ Authentication  │
    │                                      │ Service         │
    │                                      │ 认证服务        │
    │                                      └────────┬────────┘
    │                                               │
    │                                      ┌────────▼────────┐
    │                                      │ User Database   │
    │                                      │ 用户数据库      │
    │                                      └────────┬────────┘
    │  3. Generate JWT token (生成JWT令牌)          │
    │←─────────────────────────────────────────────│
    │                                               │
    │  4. Return token and user info                │
    │    (返回令牌和用户信息)                       │
    │←─────────────────────────────────────────────│
    │                                               │
    │  5. Store token in session                    │
    │    (在会话中存储令牌)                         │
    │                                               │
```

**C4 Model (Alternative View Model) | C4模型（替代视图模型）**:

**C4 Model Levels | C4模型层次**:
```
Level 1: System Context (系统上下文)
         - High-level view of system and external dependencies
         - 系统及其外部依赖的高层视图

Level 2: Container (容器)
         - Applications, databases, microservices
         - 应用、数据库、微服务

Level 3: Component (组件)
         - Components within containers
         - 容器内的组件

Level 4: Code (代码)
         - Classes, interfaces (optional)
         - 类、接口（可选）
```

**Example - C4 Level 1: System Context | 示例 - C4一级：系统上下文**:
```
┌──────────┐           ┌───────────────────┐           ┌──────────┐
│          │           │                   │           │          │
│  Users   │──────────→│  E-commerce       │──────────→│  Payment │
│  用户    │  Browse   │  Platform         │   Pay     │  Gateway │
│          │  & Buy    │  电商平台         │           │  支付网关│
└──────────┘           │                   │           └──────────┘
                       │                   │
┌──────────┐           │                   │           ┌──────────┐
│          │           │                   │           │          │
│  Admin   │──────────→│                   │←──────────│  Email   │
│  管理员  │  Manage   │                   │  Notify   │  Service │
│          │           │                   │           │  邮件服务│
└──────────┘           └───────────────────┘           └──────────┘
```

**中文:**

**4+1视图模型**（Philippe Kruchten，1995）提供软件架构的多个视角，以解决不同利益相关者的关注点。

**五个视图**: 逻辑视图、开发视图、进程视图、物理视图、场景/用例

**[Exam Focus | 考试重点]**: 
- Understand 4+1 view model and purpose of each view
- Recognize which stakeholders use which views
- Identify appropriate diagrams for each view
- Understand C4 model as alternative approach

### 1.3 Quality Attributes | 质量属性

**English:**

**Quality Attributes** (Non-Functional Requirements) are measurable properties of a system that indicate how well the system fulfills its intended purpose.

**Key Quality Attributes | 关键质量属性**:

#### 1. Performance | 性能

**Definition | 定义**: System's responsiveness and throughput

**Metrics | 指标**:
- **Response Time | 响应时间**: Time from request to response
- **Throughput | 吞吐量**: Requests processed per unit time
- **Latency | 延迟**: Delay before response begins

**Tactics | 策略**:
```
Performance Tactics | 性能策略:

1. Caching | 缓存
   - Reduce database queries
   - Store frequently accessed data

2. Load Balancing | 负载均衡
   - Distribute requests across servers
   - Avoid single point of overload

3. Asynchronous Processing | 异步处理
   - Non-blocking operations
   - Background job processing

4. Database Optimization | 数据库优化
   - Indexing
   - Query optimization
   - Database replication
```

**Example - Performance Scenario | 示例 - 性能场景**:
```
Scenario: User searches for products
场景: 用户搜索产品

Source: User
Stimulus: Search request
Artifact: Search service
Environment: Normal operation
Response: Return results
Response Measure: < 200ms for 95% of requests

来源: 用户
刺激: 搜索请求
制品: 搜索服务
环境: 正常操作
响应: 返回结果
响应度量: 95%的请求<200ms
```

#### 2. Scalability | 可扩展性

**Definition | 定义**: System's ability to handle increased load

**Types | 类型**:
- **Vertical Scaling (Scale Up) | 垂直扩展**: Add more resources to single node
- **Horizontal Scaling (Scale Out) | 水平扩展**: Add more nodes

**Scalability Patterns | 可扩展性模式**:
```
┌──────────────────────────────────────┐
│  Horizontal Scaling (Preferred)     │
│  水平扩展（首选）                   │
├──────────────────────────────────────┤
│  ┌────┐  ┌────┐  ┌────┐  ┌────┐    │
│  │App │  │App │  │App │  │App │    │
│  │Srv │  │Srv │  │Srv │  │Srv │    │
│  └────┘  └────┘  └────┘  └────┘    │
│                                      │
│  Benefits:                           │
│  ✓ No single point of failure       │
│  ✓ Easier to add/remove nodes       │
│  ✓ Better fault tolerance           │
│                                      │
│  优势:                               │
│  ✓ 无单点故障                       │
│  ✓ 更容易添加/移除节点              │
│  ✓ 更好的容错性                     │
└──────────────────────────────────────┘

┌──────────────────────────────────────┐
│  Vertical Scaling                    │
│  垂直扩展                            │
├──────────────────────────────────────┤
│  ┌─────────────────┐                │
│  │  Application    │                │
│  │  应用服务器     │                │
│  │                 │                │
│  │  4 CPU → 8 CPU  │                │
│  │  8GB → 32GB RAM │                │
│  └─────────────────┘                │
│                                      │
│  Limitations:                        │
│  ✗ Hardware limits                   │
│  ✗ Single point of failure          │
│  ✗ Expensive                         │
│                                      │
│  限制:                               │
│  ✗ 硬件限制                         │
│  ✗ 单点故障                         │
│  ✗ 昂贵                             │
└──────────────────────────────────────┘
```

#### 3. Availability | 可用性

**Definition | 定义**: Proportion of time system is operational

**Formula | 公式**:
```
Availability = Uptime / (Uptime + Downtime) × 100%

Example:
99.9% availability = 8.76 hours downtime/year
99.99% availability = 52.56 minutes downtime/year
99.999% availability = 5.26 minutes downtime/year
```

**Availability Tactics | 可用性策略**:
```
1. Redundancy | 冗余
   - Active-Active: Multiple nodes serving traffic
   - Active-Passive: Standby nodes ready to take over
   - 主-主: 多个节点同时服务流量
   - 主-备: 备用节点准备接管

2. Health Monitoring | 健康监控
   - Heartbeat checks
   - Watchdog timers
   - 心跳检查
   - 看门狗定时器

3. Failover | 故障转移
   - Automatic switchover to backup
   - 自动切换到备份

4. Circuit Breaker | 断路器
   - Prevent cascading failures
   - 防止级联故障
```

**Example - High Availability Architecture | 示例 - 高可用架构**:
```
┌────────────────────────────────────────────────────┐
│              Load Balancer (HA Pair)               │
│              负载均衡器（高可用对）                │
├─────────────────┬──────────────────┬───────────────┤
        │                 │                  │
   ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
   │ App     │       │ App     │       │ App     │
   │ Server 1│       │ Server 2│       │ Server 3│
   │ 应用    │       │ 应用    │       │ 应用    │
   │ 服务器1 │       │ 服务器2 │       │ 服务器3 │
   └────┬────┘       └────┬────┘       └────┬────┘
        │                 │                  │
        └─────────────────┼──────────────────┘
                          │
           ┌──────────────▼───────────────┐
           │    Database (Master-Slave)   │
           │    数据库（主从复制）        │
           │                              │
           │  ┌──────────┐  ┌──────────┐ │
           │  │ Master   │─→│ Slave 1  │ │
           │  │ 主库     │  │ 从库1    │ │
           │  └──────────┘  └──────────┘ │
           │       │         ┌──────────┐ │
           │       └────────→│ Slave 2  │ │
           │                 │ 从库2    │ │
           │                 └──────────┘ │
           └──────────────────────────────┘

Availability: 99.99%
可用性: 99.99%
Downtime: ~52 minutes/year
停机时间: 约52分钟/年
```

#### 4. Security | 安全性

**Definition | 定义**: System's ability to protect data and prevent unauthorized access

**Security Principles | 安全原则**:
```
CIA Triad | CIA三元组:

Confidentiality (机密性)
- Only authorized users access data
- Encryption, access control

Integrity (完整性)
- Data is accurate and unaltered
- Checksums, digital signatures

Availability (可用性)
- System is accessible when needed
- DDoS protection, redundancy
```

**Security Tactics | 安全策略**:
```
1. Authentication | 认证
   - Verify user identity
   - OAuth, JWT, SAML

2. Authorization | 授权
   - Control access to resources
   - RBAC (Role-Based Access Control)
   - ABAC (Attribute-Based Access Control)

3. Encryption | 加密
   - Data at rest: AES, RSA
   - Data in transit: TLS/SSL

4. Input Validation | 输入验证
   - Prevent SQL injection, XSS
   - Sanitize user inputs

5. Audit Logging | 审计日志
   - Track access and changes
   - Forensics and compliance
```

#### 5. Maintainability | 可维护性

**Definition | 定义**: Ease of making changes to the system

**Aspects | 方面**:
```
1. Modularity | 模块化
   - Loosely coupled components
   - High cohesion within components

2. Testability | 可测试性
   - Unit tests, integration tests
   - Test coverage

3. Readability | 可读性
   - Clear code structure
   - Documentation

4. Extensibility | 可扩展性
   - Easy to add new features
   - Open-Closed Principle
```

**Quality Attribute Trade-offs | 质量属性权衡**:

| Improve<br/>提升 | May Harm<br/>可能损害     | Reason<br/>原因                      |
| ---------------- | ------------------------- | ------------------------------------ |
| **Performance**  | Security, Maintainability | Caching, optimization reduce clarity |
| **性能**         | 安全性、可维护性          | 缓存、优化降低清晰度                 |
| **Security**     | Performance, Usability    | Encryption, checks add overhead      |
| **安全性**       | 性能、可用性              | 加密、检查增加开销                   |
| **Scalability**  | Complexity, Cost          | Distributed systems more complex     |
| **可扩展性**     | 复杂性、成本              | 分布式系统更复杂                     |
| **Availability** | Cost, Complexity          | Redundancy increases resources       |
| **可用性**       | 成本、复杂性              | 冗余增加资源                         |

**Quality Attribute Scenario Template | 质量属性场景模板**:
```
Source: Who/what generates the event
刺激源: 谁/什么生成事件

Stimulus: Event or action
刺激: 事件或动作

Artifact: What is affected
制品: 受影响的内容

Environment: Context/conditions
环境: 上下文/条件

Response: System's reaction
响应: 系统反应

Response Measure: Quantifiable metric
响应度量: 可量化的指标

Example - Availability Scenario:
Source: Server failure
Stimulus: Server crashes
Artifact: Application service
Environment: Normal operation
Response: Failover to standby server
Response Measure: Recovery within 30 seconds

示例 - 可用性场景:
刺激源: 服务器故障
刺激: 服务器崩溃
制品: 应用服务
环境: 正常操作
响应: 故障转移到备用服务器
响应度量: 30秒内恢复
```

**中文:**

**质量属性**（非功能需求）是系统的可测量属性，表明系统实现其预期目的的程度。

**关键质量属性**: 性能、可扩展性、可用性、安全性、可维护性

**权衡**: 提升一个质量属性可能损害另一个（如性能vs安全性）

**[Exam Focus | 考试重点]**: 
- Understand key quality attributes (performance, scalability, availability, security, maintainability)
- Recognize quality attribute tactics and patterns
- Identify trade-offs between quality attributes
- Apply quality attribute scenario template
- Calculate availability (uptime/downtime)

---

## Classic Architecture Styles | 经典架构风格

### 2.1 Layered Architecture | 分层架构

**English:**

**Layered Architecture** (N-Tier Architecture) organizes the system into horizontal layers, each providing a specific level of abstraction and set of services.

**Core Principle | 核心原则**: **Separation of Concerns | 关注点分离**

**Typical Layers | 典型分层**:

```
┌─────────────────────────────────────────────────────┐
│            Presentation Layer                       │
│            表示层                                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐         │
│  │ Web UI   │  │Mobile UI │  │ Admin UI │         │
│  │ (React)  │  │(React    │  │(Vue.js)  │         │
│  │          │  │ Native)  │  │          │         │
│  └──────────┘  └──────────┘  └──────────┘         │
│                                                     │
│  Responsibilities: User interaction, display logic │
│  职责: 用户交互、显示逻辑                          │
├─────────────────────────────────────────────────────┤
│            Business Logic Layer (Service Layer)     │
│            业务逻辑层（服务层）                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐         │
│  │UserService│ │OrderSvc  │  │ProductSvc│         │
│  │用户服务  │  │订单服务  │  │产品服务  │         │
│  └──────────┘  └──────────┘  └──────────┘         │
│                                                     │
│  Responsibilities: Business rules, workflows,      │
│                    domain logic                     │
│  职责: 业务规则、工作流、领域逻辑                  │
├─────────────────────────────────────────────────────┤
│            Data Access Layer (Persistence Layer)    │
│            数据访问层（持久化层）                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐         │
│  │UserRepo  │  │OrderRepo │  │ProductRep│         │
│  │用户仓库  │  │订单仓库  │  │产品仓库  │         │
│  └──────────┘  └──────────┘  └──────────┘         │
│                                                     │
│  Responsibilities: CRUD operations, ORM, queries   │
│  职责: CRUD操作、ORM、查询                         │
├─────────────────────────────────────────────────────┤
│            Database Layer                           │
│            数据库层                                 │
│  ┌────────────────────────────────────────────┐   │
│  │       PostgreSQL / MySQL / Oracle          │   │
│  │       关系型数据库                         │   │
│  └────────────────────────────────────────────┘   │
│                                                     │
│  Responsibilities: Data storage and retrieval      │
│  职责: 数据存储和检索                              │
└─────────────────────────────────────────────────────┘

Communication Flow | 通信流:
Request: UI → Business Logic → Data Access → Database
Response: Database → Data Access → Business Logic → UI

请求: UI → 业务逻辑 → 数据访问 → 数据库
响应: 数据库 → 数据访问 → 业务逻辑 → UI
```

**Closed Layer vs. Open Layer | 封闭层vs开放层**:

**Closed Layer (Default) | 封闭层（默认）**:
```
┌─────────────────┐
│  Layer 1        │
│  第一层         │
└────────┬────────┘
         │ (must go through)
         │ (必须经过)
         ▼
┌─────────────────┐
│  Layer 2        │
│  第二层         │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Layer 3        │
│  第三层         │
└─────────────────┘

Benefits | 优势:
- Clear dependencies
- Easier to understand and maintain
- Changes isolated to specific layers

- 清晰的依赖关系
- 更容易理解和维护
- 变更隔离到特定层
```

**Open Layer (Exception for utility layers) | 开放层（工具层例外）**:
```
┌─────────────────┐
│  Layer 1        │
│  第一层         │
└────────┬────────┘
         │
         ├─────────────────┐
         │                 │
         ▼                 │
┌─────────────────┐        │
│  Layer 2        │        │ (skip if needed)
│  (Utility)      │        │ (如需要可跳过)
│  第二层(工具)   │        │
└────────┬────────┘        │
         │                 │
         ▼                 ▼
┌─────────────────────────────┐
│  Layer 3                    │
│  第三层                     │
└─────────────────────────────┘

Use Case: Logging, caching utilities
使用场景: 日志、缓存工具
```

**Implementation Example | 实现示例**:

**1. Presentation Layer (REST Controller) | 表示层（REST控制器）**:
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // Get user by ID
    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        if (user == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(UserDTO.fromEntity(user));
    }
    
    // Create new user
    @PostMapping
    public ResponseEntity<UserDTO> createUser(
        @Valid @RequestBody UserCreateRequest request
    ) {
        User user = userService.createUser(
            request.getName(),
            request.getEmail(),
            request.getPassword()
        );
        
        URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{id}")
            .buildAndExpand(user.getId())
            .toUri();
            
        return ResponseEntity.created(location)
                             .body(UserDTO.fromEntity(user));
    }
    
    // Update user
    @PutMapping("/{id}")
    public ResponseEntity<UserDTO> updateUser(
        @PathVariable Long id,
        @Valid @RequestBody UserUpdateRequest request
    ) {
        User user = userService.updateUser(
            id,
            request.getName(),
            request.getEmail()
        );
        return ResponseEntity.ok(UserDTO.fromEntity(user));
    }
    
    // Delete user
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
```

**2. Business Logic Layer (Service) | 业务逻辑层（服务）**:
```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    /**
     * Find user by ID
     */
    @Transactional(readOnly = true)
    public User findById(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException("User not found: " + id));
    }
    
    /**
     * Create new user with validation and email notification
     */
    public User createUser(String name, String email, String password) {
        // Business validation
        validateUserInput(name, email, password);
        
        // Check for duplicate email
        if (userRepository.existsByEmail(email)) {
            throw new DuplicateEmailException("Email already exists: " + email);
        }
        
        // Create user entity
        User user = new User();
        user.setName(name);
        user.setEmail(email);
        user.setPassword(passwordEncoder.encode(password));
        user.setStatus(UserStatus.ACTIVE);
        user.setCreatedAt(LocalDateTime.now());
        
        // Save to database
        User savedUser = userRepository.save(user);
        
        // Send welcome email (asynchronous)
        emailService.sendWelcomeEmail(savedUser);
        
        // Log business event
        log.info("New user created: {}", savedUser.getId());
        
        return savedUser;
    }
    
    /**
     * Update user information
     */
    public User updateUser(Long id, String name, String email) {
        User user = findById(id);
        
        // Validate new email if changed
        if (!user.getEmail().equals(email)) {
            if (userRepository.existsByEmail(email)) {
                throw new DuplicateEmailException("Email already exists: " + email);
            }
            user.setEmail(email);
        }
        
        user.setName(name);
        user.setUpdatedAt(LocalDateTime.now());
        
        return userRepository.save(user);
    }
    
    /**
     * Delete user (soft delete)
     */
    public void deleteUser(Long id) {
        User user = findById(id);
        user.setStatus(UserStatus.DELETED);
        user.setDeletedAt(LocalDateTime.now());
        userRepository.save(user);
        
        log.info("User deleted: {}", id);
    }
    
    /**
     * Business validation logic
     */
    private void validateUserInput(String name, String email, String password) {
        if (name == null || name.trim().isEmpty()) {
            throw new ValidationException("Name cannot be empty");
        }
        
        if (email == null || !email.matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
            throw new ValidationException("Invalid email format");
        }
        
        if (password == null || password.length() < 8) {
            throw new ValidationException("Password must be at least 8 characters");
        }
        
        // Check password complexity
        if (!password.matches(".*[A-Z].*") || 
            !password.matches(".*[a-z].*") || 
            !password.matches(".*\\d.*")) {
            throw new ValidationException(
                "Password must contain uppercase, lowercase, and digit"
            );
        }
    }
}
```

**3. Data Access Layer (Repository) | 数据访问层（仓库）**:
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    /**
     * Find user by email
     */
    Optional<User> findByEmail(String email);
    
    /**
     * Check if email exists
     */
    boolean existsByEmail(String email);
    
    /**
     * Find all active users
     */
    @Query("SELECT u FROM User u WHERE u.status = :status")
    List<User> findByStatus(@Param("status") UserStatus status);
    
    /**
     * Find users created after specific date
     */
    List<User> findByCreatedAtAfter(LocalDateTime date);
    
    /**
     * Count users by status
     */
    @Query("SELECT COUNT(u) FROM User u WHERE u.status = :status")
    long countByStatus(@Param("status") UserStatus status);
    
    /**
     * Custom query: Find users with pagination
     */
    @Query("SELECT u FROM User u WHERE u.name LIKE %:name% ORDER BY u.createdAt DESC")
    Page<User> searchByName(@Param("name") String name, Pageable pageable);
}

/**
 * Custom repository implementation for complex queries
 */
@Repository
public class UserRepositoryCustomImpl implements UserRepositoryCustom {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    @Override
    public List<User> findUsersWithOrders(LocalDateTime since) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<User> query = cb.createQuery(User.class);
        Root<User> user = query.from(User.class);
        Join<User, Order> orders = user.join("orders");
        
        query.select(user).distinct(true)
             .where(cb.greaterThan(orders.get("createdAt"), since));
        
        return entityManager.createQuery(query).getResultList();
    }
}
```

**4. Domain Model (Entity) | 领域模型（实体）**:
```java
@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_email", columnList = "email"),
    @Index(name = "idx_status", columnList = "status")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(nullable = false, unique = true, length = 255)
    private String email;
    
    @Column(nullable = false)
    private String password;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private UserStatus status;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    // Relationships
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private List<Order> orders;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

public enum UserStatus {
    ACTIVE,
    INACTIVE,
    SUSPENDED,
    DELETED
}
```

**Advantages | 优势**:

**1. Separation of Concerns | 关注点分离**
```
✓ Each layer has a specific responsibility
✓ UI changes don't affect business logic
✓ Database changes isolated to data layer

✓ 每层有特定职责
✓ UI变更不影响业务逻辑
✓ 数据库变更隔离到数据层
```

**2. Testability | 可测试性**
```
✓ Layers can be tested independently
✓ Mock dependencies easily

Example:
// Test business logic without database
@Test
public void testCreateUser() {
    // Mock repository
    UserRepository mockRepo = mock(UserRepository.class);
    when(mockRepo.save(any())).thenReturn(new User());
    
    UserService service = new UserService(mockRepo);
    User user = service.createUser("John", "john@example.com", "Pass123");
    
    assertNotNull(user);
    verify(mockRepo, times(1)).save(any());
}

✓ 层可以独立测试
✓ 轻松模拟依赖
```

**3. Reusability | 可复用性**
```
✓ Business logic layer reused by multiple UIs
  (Web, Mobile, Admin)
  
✓ Data access layer reused by multiple services

✓ 业务逻辑层被多个UI复用
  （Web、移动、管理）
  
✓ 数据访问层被多个服务复用
```

**4. Maintainability | 可维护性**
```
✓ Changes localized to specific layers
✓ Easier to understand system structure
✓ Clear dependencies

✓ 变更局限于特定层
✓ 更容易理解系统结构
✓ 清晰的依赖关系
```

**5. Team Organization | 团队组织**
```
✓ Different teams work on different layers
  - UI team: Presentation layer
  - Backend team: Business logic
  - DBA team: Database optimization

✓ 不同团队负责不同层
  - UI团队: 表示层
  - 后端团队: 业务逻辑
  - DBA团队: 数据库优化
```

**Disadvantages | 缺点**:

**1. Performance Overhead | 性能开销**
```
✗ Multiple layer traversals add latency
✗ Unnecessary data transformations (Entity → DTO → ViewModel)

Example:
Request → Controller → Service → Repository → Database
5 hops for simple query

✗ 多层遍历增加延迟
✗ 不必要的数据转换
```

**2. Monolithic Tendency | 单体倾向**
```
✗ Layers tightly coupled within single deployment
✗ Cannot scale layers independently
✗ All-or-nothing deployment

✗ 层在单个部署中紧密耦合
✗ 无法独立扩展层
✗ 全有或全无的部署
```

**3. Layer Leakage | 层泄漏**
```
✗ Lower layer details exposed to upper layers

Anti-pattern Example:
// Controller directly using JPA annotations
@GetMapping("/users")
public List<User> getUsers() {
    return userRepository.findAll(); // Returns JPA entities
}

Problem: UI layer depends on persistence layer details

✗ 下层细节暴露给上层

反模式示例:
// 控制器直接使用JPA注解
问题: UI层依赖持久化层细节
```

**4. Rigidity | 刚性**
```
✗ Cross-cutting changes affect multiple layers

Example: Adding a new field to User
1. Update database schema
2. Update User entity
3. Update UserRepository queries
4. Update UserService
5. Update UserDTO
6. Update UI

6 files to change for one field!

✗ 跨层变更影响多个层

示例: 为User添加新字段
1. 更新数据库模式
2. 更新User实体
3. 更新UserRepository查询
4. 更新UserService
5. 更新UserDTO
6. 更新UI

一个字段要改6个文件！
```

**Use Cases | 适用场景**:

**When to Use Layered Architecture | 何时使用分层架构**:
```
✓ Traditional enterprise applications
✓ E-commerce websites
✓ Content management systems
✓ Banking and financial systems
✓ Applications with clear separation of concerns
✓ Teams familiar with layered approach
✓ Moderate complexity applications

✓ 传统企业应用
✓ 电商网站
✓ 内容管理系统
✓ 银行和金融系统
✓ 有清晰关注点分离的应用
✓ 熟悉分层方法的团队
✓ 中等复杂度应用
```

**When NOT to Use | 何时不使用**:
```
✗ High-performance, low-latency requirements
✗ Microservices architecture (use service-based instead)
✗ Highly dynamic, rapidly changing requirements
✗ Need independent scaling of components

✗ 高性能、低延迟需求
✗ 微服务架构（改用基于服务的）
✗ 高度动态、快速变化的需求
✗ 需要独立扩展组件
```

**Variants | 变体**:

**1. Strict Layered Architecture | 严格分层架构**
```
Each layer only communicates with layer immediately below
每层只与正下方的层通信

Layer 1 → Layer 2 → Layer 3 → Layer 4

Benefits: Clear dependencies, easier to understand
Drawbacks: May require unnecessary layers

优势: 清晰的依赖、更容易理解
缺点: 可能需要不必要的层
```

**2. Relaxed Layered Architecture | 宽松分层架构**
```
Layers can skip intermediate layers
层可以跳过中间层

Layer 1 ──→ Layer 2 ──→ Layer 4
       └────────────────┘

Benefits: Better performance (fewer hops)
Drawbacks: More complex dependencies

优势: 更好的性能（更少跳转）
缺点: 更复杂的依赖
```

**中文:**

**分层架构**（N层架构）将系统组织成水平层，每层提供特定的抽象级别和服务集合。

**核心原则**: 关注点分离

**典型分层**: 表示层、业务逻辑层、数据访问层、数据库层

**优势**: 关注点分离、可测试性、可复用性、可维护性、团队组织

**缺点**: 性能开销、单体倾向、层泄漏、刚性

**适用场景**: 传统企业应用、电商网站、内容管理系统

**[Exam Focus | 考试重点]**: 
- Understand closed vs. open layers
- Recognize layer responsibilities (presentation, business, data)
- Identify advantages (separation of concerns, testability, maintainability)
- Recognize disadvantages (performance overhead, monolithic tendency, layer leakage)
- Apply layered architecture to case scenarios
- Differentiate strict vs. relaxed layering

### 2.2 Pipe-Filter Architecture | 管道-过滤器架构

**English:**

**Pipe-Filter Architecture** decomposes a system into a series of independent processing components (filters) connected by data streams (pipes).

**Core Concepts | 核心概念**:

**1. Filter | 过滤器**
- **Definition | 定义**: Independent processing component that transforms input data to output
- **Characteristics | 特征**:
  - Stateless (no shared state between filters)
  - Independent (doesn't know about upstream/downstream filters)
  - Reusable (can be used in different pipelines)

**2. Pipe | 管道**
- **Definition | 定义**: Connector that transports data between filters
- **Characteristics | 特征**:
  - Unidirectional (data flows one way)
  - Buffered (can queue data)
  - Typed (specific data format)

**Architecture Diagram | 架构图**:
```
Input         Filter 1        Filter 2        Filter 3        Output
输入          过滤器1         过滤器2         过滤器3         输出
  │              │              │              │              │
  │    Pipe 1    │    Pipe 2    │    Pipe 3    │    Pipe 4    │
  ├─────────────→├─────────────→├─────────────→├─────────────→│
  │              │              │              │              │
  │              │              │              │              │

Data Flow (Unidirectional) | 数据流（单向）:
Raw Data → Process 1 → Process 2 → Process 3 → Result
原始数据 → 处理1 → 处理2 → 处理3 → 结果
```

**Classic Example - Unix Shell Pipeline | 经典示例 - Unix Shell管道**:

```bash
# List files, filter by pattern, count lines
# 列出文件、按模式过滤、计数行数

cat access.log | grep "ERROR" | sort | uniq | wc -l

Breakdown | 分解:

┌────────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐
│ cat        │ →│  grep    │ →│  sort    │ →│  uniq    │ →│  wc -l   │
│ (Read file)│   │(Filter)  │   │(Sort)    │   │(Unique)  │   │(Count)   │
│ 读取文件   │   │过滤      │   │排序      │   │去重      │   │计数      │
└────────────┘   └──────────┘   └──────────┘   └──────────┘   └──────────┘
     │                │              │              │              │
     └────────────────┴──────────────┴──────────────┴──────────────┘
                          Data flows through pipes
                          数据通过管道流动
```

**Implementation Example - Data Processing Pipeline | 实现示例 - 数据处理管道**:

**Scenario | 场景**: Process log files (read → parse → filter → transform → save)

```java
/**
 * Filter interface (处理器接口)
 */
public interface Filter<Input, Output> {
    Output process(Input input);
}

/**
 * Filter 1: Read log file (过滤器1: 读取日志文件)
 */
public class FileReaderFilter implements Filter<String, List<String>> {
    @Override
    public List<String> process(String filePath) {
        try {
            return Files.readAllLines(Paths.get(filePath));
        } catch (IOException e) {
            throw new RuntimeException("Failed to read file: " + filePath, e);
        }
    }
}

/**
 * Filter 2: Parse log lines (过滤器2: 解析日志行)
 */
public class LogParserFilter implements Filter<List<String>, List<LogEntry>> {
    private static final Pattern LOG_PATTERN = 
        Pattern.compile("(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}) (\\w+) (.+)");
    
    @Override
    public List<LogEntry> process(List<String> lines) {
        return lines.stream()
            .map(this::parseLine)
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }
    
    private LogEntry parseLine(String line) {
        Matcher matcher = LOG_PATTERN.matcher(line);
        if (matcher.matches()) {
            return new LogEntry(
                LocalDateTime.parse(matcher.group(1), DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")),
                LogLevel.valueOf(matcher.group(2)),
                matcher.group(3)
            );
        }
        return null;
    }
}

/**
 * Filter 3: Filter by log level (过滤器3: 按日志级别过滤)
 */
public class LogLevelFilterFilter implements Filter<List<LogEntry>, List<LogEntry>> {
    private final LogLevel minLevel;
    
    public LogLevelFilterFilter(LogLevel minLevel) {
        this.minLevel = minLevel;
    }
    
    @Override
    public List<LogEntry> process(List<LogEntry> entries) {
        return entries.stream()
            .filter(entry -> entry.getLevel().ordinal() >= minLevel.ordinal())
            .collect(Collectors.toList());
    }
}

/**
 * Filter 4: Transform to JSON (过滤器4: 转换为JSON)
 */
public class JsonTransformFilter implements Filter<List<LogEntry>, List<String>> {
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    @Override
    public List<String> process(List<LogEntry> entries) {
        return entries.stream()
            .map(this::toJson)
            .collect(Collectors.toList());
    }
    
    private String toJson(LogEntry entry) {
        try {
            return objectMapper.writeValueAsString(entry);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to serialize entry", e);
        }
    }
}

/**
 * Filter 5: Write to file (过滤器5: 写入文件)
 */
public class FileWriterFilter implements Filter<List<String>, Boolean> {
    @Override
    public Boolean process(List<String> lines) {
        try {
            Files.write(
                Paths.get("output.json"),
                lines,
                StandardOpenOption.CREATE,
                StandardOpenOption.TRUNCATE_EXISTING
            );
            return true;
        } catch (IOException e) {
            throw new RuntimeException("Failed to write file", e);
        }
    }
}

/**
 * Pipeline composition (管道组合)
 */
public class LogProcessingPipeline {
    public static void main(String[] args) {
        // Create filters (创建过滤器)
        FileReaderFilter reader = new FileReaderFilter();
        LogParserFilter parser = new LogParserFilter();
        LogLevelFilterFilter filter = new LogLevelFilterFilter(LogLevel.ERROR);
        JsonTransformFilter transformer = new JsonTransformFilter();
        FileWriterFilter writer = new FileWriterFilter();
        
        // Execute pipeline (执行管道)
        String inputFile = "access.log";
        
        List<String> rawLines = reader.process(inputFile);
        List<LogEntry> parsedEntries = parser.process(rawLines);
        List<LogEntry> filteredEntries = filter.process(parsedEntries);
        List<String> jsonLines = transformer.process(filteredEntries);
        Boolean success = writer.process(jsonLines);
        
        System.out.println("Pipeline completed: " + success);
    }
}

/**
 * Generic Pipeline Builder (通用管道构建器)
 */
public class Pipeline<Input, Output> {
    private final List<Filter<?, ?>> filters = new ArrayList<>();
    
    public <NewOutput> Pipeline<Input, NewOutput> addFilter(Filter<Output, NewOutput> filter) {
        filters.add(filter);
        return (Pipeline<Input, NewOutput>) this;
    }
    
    @SuppressWarnings("unchecked")
    public Output execute(Input input) {
        Object current = input;
        for (Filter filter : filters) {
            current = filter.process(current);
        }
        return (Output) current;
    }
}

// Usage with fluent API (使用流式API)
Boolean result = new Pipeline<String, Boolean>()
    .addFilter(new FileReaderFilter())
    .addFilter(new LogParserFilter())
    .addFilter(new LogLevelFilterFilter(LogLevel.ERROR))
    .addFilter(new JsonTransformFilter())
    .addFilter(new FileWriterFilter())
    .execute("access.log");
```

**Advantages | 优势**:

**1. Reusability | 可复用性**
```
✓ Filters can be reused in different pipelines
✓ Standard components library

Example:
// Reuse filters in different contexts
Pipeline 1: Read → Parse → Filter → Save
Pipeline 2: Read → Parse → Transform → Email
Pipeline 3: Read → Parse → Aggregate → Report

✓ 过滤器可在不同管道中复用
✓ 标准组件库
```

**2. Maintainability | 可维护性**
```
✓ Each filter is independent and simple
✓ Easy to add/remove/replace filters
✓ Clear data flow

Example: Add new filter without modifying existing ones
Old: Read → Parse → Save
New: Read → Parse → Validate → Save
                      ↑ (New filter)

✓ 每个过滤器独立且简单
✓ 易于添加/移除/替换过滤器
✓ 清晰的数据流
```

**3. Parallelism | 并行性**
```
✓ Independent filters can run in parallel
✓ Multi-threaded processing

Example: Process multiple files concurrently
File 1 → Pipeline 1
File 2 → Pipeline 2  (parallel)
File 3 → Pipeline 3

✓ 独立过滤器可并行运行
✓ 多线程处理
```

**Disadvantages | 缺点**:

**1. Shared State Limitation | 共享状态限制**
```
✗ Filters should be stateless
✗ Hard to share state across filters

Anti-pattern:
// Filter depends on previous filter's state
Filter1.result → Filter2 needs Filter1 state

✗ 过滤器应该是无状态的
✗ 难以在过滤器间共享状态
```

**2. Error Handling | 错误处理**
```
✗ Complex error propagation
✗ Hard to rollback in middle of pipeline

Problem:
Filter1 → Filter2 → [Error in Filter3] → ?
How to handle partial processing?

✗ 复杂的错误传播
✗ 难以在管道中间回滚
```

**3. Data Type Constraints | 数据类型约束**
```
✗ Adjacent filters must agree on data format
✗ Type mismatches cause runtime errors

Example:
Filter1 outputs List<String>
Filter2 expects Map<String, Integer>
→ Type mismatch!

✗ 相邻过滤器必须约定数据格式
✗ 类型不匹配导致运行时错误
```

**Use Cases | 适用场景**:

```
✓ Data processing pipelines (ETL)
✓ Signal processing
✓ Image processing
✓ Compiler design (lexer → parser → optimizer → code generator)
✓ Stream processing
✓ Unix command-line tools

✓ 数据处理管道（ETL）
✓ 信号处理
✓ 图像处理
✓ 编译器设计（词法分析→语法分析→优化→代码生成）
✓ 流处理
✓ Unix命令行工具
```

**中文:**

**管道-过滤器架构**将系统分解为一系列由数据流（管道）连接的独立处理组件（过滤器）。

**核心概念**: 过滤器（独立处理组件）、管道（数据传输连接器）

**优势**: 可复用性、可维护性、并行性

**缺点**: 共享状态限制、错误处理复杂、数据类型约束

**适用场景**: 数据处理管道、信号处理、图像处理、编译器设计

**[Exam Focus | 考试重点]**: 
- Understand pipe and filter components
- Recognize Unix shell pipeline as classic example
- Identify advantages (reusability, maintainability, parallelism)
- Recognize disadvantages (shared state, error handling)
- Apply pipe-filter to data processing scenarios

---

## Distributed Architecture Styles | 分布式架构风格

### 3.1 Service-Oriented Architecture (SOA) | 面向服务架构

**English:**

**Service-Oriented Architecture (SOA)** is an architectural style where functionality is grouped into distinct, loosely coupled services that communicate over a network.

**Core Principles | 核心原则**:

1. **Standardized Service Contract | 标准化服务契约**
   - Services have well-defined interfaces (WSDL)
   - Clear API contracts

2. **Service Loose Coupling | 服务松耦合**
   - Services minimize dependencies
   - Independent evolution

3. **Service Abstraction | 服务抽象**
   - Hide implementation details
   - Expose only necessary information

4. **Service Reusability | 服务可复用性**
   - Services designed for reuse across applications
   - Business logic encapsulated

5. **Service Autonomy | 服务自治性**
   - Services control their own logic and data
   - Independent deployment

6. **Service Discoverability | 服务可发现性**
   - Services registered in service registry
   - Metadata for discovery

**SOA Architecture Diagram | SOA架构图**:

```
┌─────────────────────────────────────────────────────────┐
│                  Service Consumers                      │
│                  服务消费者                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │ Web App  │  │Mobile App│  │ Portal   │             │
│  │ Web应用  │  │移动应用  │  │ 门户     │             │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘             │
└───────┼─────────────┼─────────────┼────────────────────┘
        │             │             │
        └─────────────┼─────────────┘
                      │
        ┌─────────────▼──────────────┐
        │  Enterprise Service Bus    │
        │  (ESB)                     │
        │  企业服务总线              │
        │                            │
        │  - Message Routing         │
        │  - Protocol Transformation │
        │  - Service Orchestration   │
        │  - Security                │
        │  - Monitoring              │
        │                            │
        │  - 消息路由                │
        │  - 协议转换                │
        │  - 服务编排                │
        │  - 安全                    │
        │  - 监控                    │
        └─────────────┬──────────────┘
                      │
      ┌───────────────┼───────────────┐
      │               │               │
┌─────▼──────┐  ┌────▼─────┐  ┌──────▼──────┐
│ Customer   │  │ Order    │  │ Inventory   │
│ Service    │  │ Service  │  │ Service     │
│ 客户服务   │  │ 订单服务 │  │ 库存服务    │
│            │  │          │  │             │
│ ┌────────┐ │  │┌────────┐│  │ ┌────────┐  │
│ │Customer│ │  ││ Order  ││  │ │Inventory│ │
│ │DB      │ │  ││ DB     ││  │ │ DB      │  │
│ │客户数据│ │  ││订单数据││  │ │库存数据 │  │
│ └────────┘ │  │└────────┘│  │ └────────┘  │
└────────────┘  └──────────┘  └─────────────┘
```

**Enterprise Service Bus (ESB) | 企业服务总线**:

**ESB Responsibilities | ESB职责**:
```
1. Message Routing | 消息路由
   - Route messages to appropriate services
   - Content-based routing

2. Protocol Transformation | 协议转换
   - SOAP ↔ REST ↔ JMS
   - XML ↔ JSON

3. Service Orchestration | 服务编排
   - Coordinate multiple service calls
   - Business process execution

4. Message Transformation | 消息转换
   - Data format conversion
   - Canonical data model

5. Security | 安全
   - Authentication and authorization
   - Encryption

6. Monitoring | 监控
   - Service health checks
   - Performance monitoring
```

**Web Services Technologies | Web服务技术**:

**SOAP (Simple Object Access Protocol) | SOAP（简单对象访问协议）**:
```xml
<!-- SOAP Request Example (SOAP请求示例) -->
<?xml version="1.0"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">
  <soap:Header>
    <auth:Authentication xmlns:auth="http://example.com/auth">
      <auth:username>admin</auth:username>
      <auth:password>pass123</auth:password>
    </auth:Authentication>
  </soap:Header>
  <soap:Body>
    <m:GetCustomer xmlns:m="http://example.com/customer">
      <m:customerId>12345</m:customerId>
    </m:GetCustomer>
  </soap:Body>
</soap:Envelope>

<!-- SOAP Response (SOAP响应) -->
<?xml version="1.0"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">
  <soap:Body>
    <m:GetCustomerResponse xmlns:m="http://example.com/customer">
      <m:customer>
        <m:id>12345</m:id>
        <m:name>John Doe</m:name>
        <m:email>john@example.com</m:email>
      </m:customer>
    </m:GetCustomerResponse>
  </soap:Body>
</soap:Envelope>
```

**WSDL (Web Services Description Language) | WSDL（Web服务描述语言）**:
```xml
<!-- WSDL Example (WSDL示例) -->
<?xml version="1.0"?>
<definitions xmlns="http://schemas.xmlsoap.org/wsdl/"
             targetNamespace="http://example.com/customer">
  
  <!-- Message definitions (消息定义) -->
  <message name="GetCustomerRequest">
    <part name="customerId" type="xsd:string"/>
  </message>
  
  <message name="GetCustomerResponse">
    <part name="customer" type="tns:Customer"/>
  </message>
  
  <!-- Port type (operations) (端口类型（操作）) -->
  <portType name="CustomerServicePortType">
    <operation name="GetCustomer">
      <input message="tns:GetCustomerRequest"/>
      <output message="tns:GetCustomerResponse"/>
    </operation>
  </portType>
  
  <!-- Binding (protocol details) (绑定（协议详情）) -->
  <binding name="CustomerServiceBinding" type="tns:CustomerServicePortType">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http"/>
    <operation name="GetCustomer">
      <soap:operation soapAction="http://example.com/GetCustomer"/>
    </operation>
  </binding>
  
  <!-- Service endpoint (服务端点) -->
  <service name="CustomerService">
    <port name="CustomerServicePort" binding="tns:CustomerServiceBinding">
      <soap:address location="http://example.com/services/customer"/>
    </port>
  </service>
</definitions>
```

**Advantages | 优势**:

```
✓ Service Reusability | 服务可复用性
  - Services used by multiple applications
  - Reduce duplication

✓ Interoperability | 互操作性
  - Language-agnostic (SOAP, WSDL)
  - Platform-independent

✓ Centralized Governance | 集中治理
  - ESB provides single point of control
  - Consistent security, monitoring

✓ Legacy Integration | 遗留系统集成
  - Integrate old and new systems
  - Protocol transformation
```

**Disadvantages | 缺点**:

```
✗ ESB Single Point of Failure | ESB单点故障
  - If ESB fails, entire system affected
  - Performance bottleneck

✗ Complexity | 复杂性
  - Heavy XML processing (SOAP, WSDL)
  - Complex configuration

✗ Performance Overhead | 性能开销
  - XML parsing and transformation
  - Multiple hops through ESB

✗ Vendor Lock-in | 供应商锁定
  - Proprietary ESB products
  - Migration difficult
```

**Use Cases | 适用场景**:

```
✓ Enterprise application integration
✓ Legacy system modernization
✓ B2B integration
✓ Systems with complex orchestration needs

✓ 企业应用集成
✓ 遗留系统现代化
✓ B2B集成
✓ 具有复杂编排需求的系统
```

**中文:**

**面向服务架构(SOA)**是一种将功能分组为不同的、松耦合的服务的架构风格，这些服务通过网络进行通信。

**核心原则**: 标准化服务契约、服务松耦合、服务抽象、服务可复用性、服务自治性、服务可发现性

**关键组件**: 企业服务总线(ESB)、SOAP、WSDL、UDDI

**优势**: 服务可复用性、互操作性、集中治理、遗留系统集成

**缺点**: ESB单点故障、复杂性、性能开销、供应商锁定

**[Exam Focus | 考试重点]**: 
- Understand SOA principles and ESB role
- Recognize SOAP, WSDL, UDDI technologies
- Identify advantages (reusability, interoperability, governance)
- Recognize disadvantages (ESB bottleneck, complexity, performance)
- Compare SOA vs. microservices (next section)

### 3.2 Microservices Architecture | 微服务架构

**English:**

**Microservices Architecture** structures an application as a collection of small, autonomous services modeled around a business domain.

**Core Principles | 核心原则**:

1. **Single Responsibility | 单一职责**
   - Each service owns one business capability
   - Example: User Service, Order Service, Payment Service

2. **Autonomous | 自治性**
   - Independently deployable and scalable
   - Own data storage (database per service)

3. **Decentralized | 去中心化**
   - Decentralized data management
   - Decentralized governance

4. **Resilience | 弹性**
   - Failure isolation
   - Circuit breakers, bulkheads

5. **Observable | 可观测性**
   - Centralized logging and monitoring
   - Distributed tracing

**Microservices Architecture Diagram | 微服务架构图**:

```
                    ┌───────────────────┐
                    │   API Gateway     │
                    │   API网关         │
                    │                   │
                    │ - Routing         │
                    │ - Authentication  │
                    │ - Rate Limiting   │
                    │ - Load Balancing  │
                    └─────────┬─────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
   ┌────▼────┐           ┌───▼─────┐          ┌───▼──────┐
   │ User    │           │ Order   │          │ Product  │
   │ Service │           │ Service │          │ Service  │
   │ 用户服务│           │订单服务 │          │产品服务  │
   │         │           │         │          │          │
   │ Node.js │           │ Java    │          │ Python   │
   └────┬────┘           └────┬────┘          └────┬─────┘
        │                     │                    │
   ┌────▼────┐           ┌───▼─────┐          ┌───▼──────┐
   │MongoDB  │           │MySQL    │          │PostgreSQL│
   │用户数据 │           │订单数据 │          │产品数据  │
   └─────────┘           └─────────┘          └──────────┘

   ┌────────────────────────────────────────────────┐
   │     Message Queue (Kafka / RabbitMQ)          │
   │     消息队列                                   │
   │                                                │
   │  Event Bus for async communication            │
   │  异步通信的事件总线                           │
   └────────────────────────────────────────────────┘

   ┌────────────────────────────────────────────────┐
   │     Service Registry (Eureka / Consul)        │
   │     服务注册中心                               │
   │                                                │
   │  Service discovery and health checks          │
   │  服务发现和健康检查                           │
   └────────────────────────────────────────────────┘
```

**Microservices vs. SOA | 微服务vs SOA**:

| Aspect<br/>方面               | SOA<br/>SOA                                    | Microservices<br/>微服务                   |
| ----------------------------- | ---------------------------------------------- | ------------------------------------------ |
| **Service Size<br/>服务大小** | Larger, enterprise services<br/>较大的企业服务 | Small, focused services<br/>小型、聚焦服务 |
| **Communication<br/>通信**    | ESB (centralized)<br/>ESB（集中式）            | Lightweight (REST, gRPC)<br/>轻量级        |
| **Data<br/>数据**             | Shared database<br/>共享数据库                 | Database per service<br/>每服务独立数据库  |
| **Deployment<br/>部署**       | Monolithic, infrequent<br/>单体、不频繁        | Independent, frequent<br/>独立、频繁       |
| **Governance<br/>治理**       | Centralized (ESB)<br/>集中式（ESB）            | Decentralized<br/>去中心化                 |
| **Technology<br/>技术**       | Standardized (SOAP, WSDL)<br/>标准化           | Polyglot (多语言)<br/>多语言               |
| **Coupling<br/>耦合**         | Tightly coupled via ESB<br/>通过ESB紧耦合      | Loosely coupled<br/>松耦合                 |
| **Scalability<br/>可扩展性**  | Vertical scaling<br/>垂直扩展                  | Horizontal scaling<br/>水平扩展            |

**Microservices vs. Monolith | 微服务vs单体**:

```
Monolithic Application | 单体应用:
┌────────────────────────────────────────┐
│          Single Deployment Unit        │
│          单一部署单元                  │
│                                        │
│  ┌──────┐  ┌──────┐  ┌──────┐        │
│  │User  │  │Order │  │Product│        │
│  │Module│  │Module│  │Module │        │
│  └───┬──┘  └───┬──┘  └───┬───┘        │
│      │         │         │            │
│      └─────────┼─────────┘            │
│                │                      │
│         ┌──────▼──────┐               │
│         │  Database   │               │
│         │  数据库     │               │
│         └─────────────┘               │
└────────────────────────────────────────┘

Pros: Simple to develop, test, deploy initially
Cons: Hard to scale, technology lock-in, long deployment cycles

优点: 初期开发、测试、部署简单
缺点: 难以扩展、技术锁定、部署周期长

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Microservices Application | 微服务应用:

┌───────────┐  ┌───────────┐  ┌───────────┐
│   User    │  │   Order   │  │  Product  │
│  Service  │  │  Service  │  │  Service  │
│           │  │           │  │           │
│ ┌───────┐ │  │ ┌───────┐ │  │ ┌───────┐ │
│ │User DB│ │  │ │OrderDB│ │  │ │ProdDB │ │
│ └───────┘ │  │ └───────┘ │  │ └───────┘ │
└───────────┘  └───────────┘  └───────────┘

Pros: Independent scaling, technology freedom, faster deployment
Cons: Distributed complexity, operational overhead

优点: 独立扩展、技术自由、更快部署
缺点: 分布式复杂性、运维开销
```

**Service Decomposition Strategies | 服务拆分策略**:

**Domain-Driven Design (DDD) | 领域驱动设计**:
```
1. Identify Bounded Contexts | 识别限界上下文
   - User Management (用户管理)
   - Order Processing (订单处理)
   - Inventory Management (库存管理)
   - Payment Processing (支付处理)

2. Define Aggregates | 定义聚合
   - User Aggregate: User, Profile, Preferences
   - Order Aggregate: Order, OrderLine, Shipping

3. Map to Microservices | 映射到微服务
   - One service per bounded context
   - Or one service per aggregate (smaller services)
```

**Inter-Service Communication | 服务间通信**:

**1. Synchronous Communication (REST, gRPC) | 同步通信**:
```java
// REST API Example (REST API示例)
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @PostMapping
    public Order createOrder(@RequestBody OrderRequest request) {
        // Call User Service to validate user
        // 调用用户服务验证用户
        String userServiceUrl = "http://user-service/api/users/" + request.getUserId();
        User user = restTemplate.getForObject(userServiceUrl, User.class);
        
        if (user == null) {
            throw new UserNotFoundException("Invalid user");
        }
        
        // Call Product Service to check inventory
        // 调用产品服务检查库存
        String productServiceUrl = "http://product-service/api/products/" + request.getProductId();
        Product product = restTemplate.getForObject(productServiceUrl, Product.class);
        
        if (product.getStock() < request.getQuantity()) {
            throw new InsufficientStockException("Not enough stock");
        }
        
        // Create order
        Order order = new Order();
        order.setUserId(user.getId());
        order.setProductId(product.getId());
        order.setQuantity(request.getQuantity());
        order.setTotalPrice(product.getPrice() * request.getQuantity());
        
        return orderRepository.save(order);
    }
}

Pros: Simple, immediate response
Cons: Tight coupling, cascading failures

优点: 简单、即时响应
缺点: 紧耦合、级联故障
```

**2. Asynchronous Communication (Message Queue) | 异步通信（消息队列）**:
```java
// Event-driven approach (事件驱动方法)
@Service
public class OrderService {
    
    @Autowired
    private KafkaTemplate<String, OrderCreatedEvent> kafkaTemplate;
    
    public Order createOrder(OrderRequest request) {
        // Create order
        Order order = new Order();
        order.setUserId(request.getUserId());
        order.setProductId(request.getProductId());
        order.setQuantity(request.getQuantity());
        
        Order savedOrder = orderRepository.save(order);
        
        // Publish event (发布事件)
        OrderCreatedEvent event = new OrderCreatedEvent(
            savedOrder.getId(),
            savedOrder.getUserId(),
            savedOrder.getProductId(),
            savedOrder.getQuantity()
        );
        
        kafkaTemplate.send("order-events", event);
        
        return savedOrder;
    }
}

// Inventory Service listens for order events
// 库存服务监听订单事件
@Service
public class InventoryService {
    
    @KafkaListener(topics = "order-events")
    public void handleOrderCreated(OrderCreatedEvent event) {
        // Reduce inventory (减少库存)
        Product product = productRepository.findById(event.getProductId())
            .orElseThrow(() -> new ProductNotFoundException());
        
        product.setStock(product.getStock() - event.getQuantity());
        productRepository.save(product);
        
        log.info("Inventory updated for product: {}", event.getProductId());
    }
}

Pros: Loose coupling, resilience, scalability
Cons: Eventual consistency, complexity

优点: 松耦合、弹性、可扩展性
缺点: 最终一致性、复杂性
```

**Service Discovery | 服务发现**:

```java
// Using Eureka for service discovery
// 使用Eureka进行服务发现

// 1. Eureka Server
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}

// 2. Service Registration (服务注册)
// application.yml in User Service
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
  instance:
    prefer-ip-address: true

spring:
  application:
    name: user-service

// 3. Service Discovery (服务发现)
@RestController
public class OrderController {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @GetMapping("/orders/{id}")
    public Order getOrder(@PathVariable Long id) {
        // Discover User Service instances
        // 发现用户服务实例
        List<ServiceInstance> instances = 
            discoveryClient.getInstances("user-service");
        
        if (instances.isEmpty()) {
            throw new ServiceUnavailableException("User service not available");
        }
        
        // Use first available instance
        ServiceInstance instance = instances.get(0);
        String userServiceUrl = instance.getUri() + "/api/users/" + userId;
        
        User user = restTemplate.getForObject(userServiceUrl, User.class);
        // ...
    }
}
```

**API Gateway Pattern | API网关模式**:

```
Client Request
      │
      ▼
┌─────────────────────────────────────┐
│         API Gateway                 │
│         API网关                     │
│                                     │
│  Responsibilities:                  │
│  - Routing (路由)                   │
│  - Authentication (认证)            │
│  - Rate Limiting (限流)             │
│  - Load Balancing (负载均衡)        │
│  - Caching (缓存)                   │
│  - Request/Response Transformation  │
│    (请求/响应转换)                  │
└──────┬────────────┬─────────────┬───┘
       │            │             │
   ┌───▼──┐    ┌───▼──┐     ┌────▼───┐
   │User  │    │Order │     │Product │
   │Svc   │    │Svc   │     │Svc     │
   └──────┘    └──────┘     └────────┘
```

**Distributed Transaction Handling | 分布式事务处理**:

**Saga Pattern | Saga模式**:
```
Scenario: Place Order (下单场景)

Steps:
1. Create Order (创建订单)
2. Reserve Inventory (预留库存)
3. Process Payment (处理支付)
4. Confirm Order (确认订单)

Choreography-based Saga (编排式Saga):

Order Service:
  1. Create Order → Publish OrderCreated event
     ↓
Inventory Service:
  2. Listen OrderCreated → Reserve Inventory → Publish InventoryReserved
     ↓
Payment Service:
  3. Listen InventoryReserved → Process Payment → Publish PaymentProcessed
     ↓
Order Service:
  4. Listen PaymentProcessed → Confirm Order

Compensating Transactions (补偿事务):
If Payment fails:
  Payment Service → Publish PaymentFailed
  Inventory Service → Release Reserved Inventory
  Order Service → Cancel Order
```

**Advantages | 优势**:

```
✓ Independent Deployment | 独立部署
  - Deploy services independently
  - Faster release cycles

✓ Technology Freedom | 技术自由
  - Choose best tech for each service
  - Polyglot persistence

✓ Fault Isolation | 故障隔离
  - Failure in one service doesn't affect others
  - Circuit breakers prevent cascading failures

✓ Scalability | 可扩展性
  - Scale services independently
  - Scale only bottleneck services

✓ Team Autonomy | 团队自治
  - Small teams own services
  - Faster decision making
```

**Disadvantages | 缺点**:

```
✗ Distributed System Complexity | 分布式系统复杂性
  - Network latency, failures
  - Distributed tracing needed

✗ Data Consistency | 数据一致性
  - No ACID transactions across services
  - Eventual consistency

✗ Operational Overhead | 运维开销
  - More services to deploy, monitor, manage
  - Requires DevOps maturity

✗ Testing Complexity | 测试复杂性
  - Integration testing harder
  - End-to-end testing challenging
```

**Use Cases | 适用场景**:

```
✓ Large, complex applications
✓ Multiple teams working independently
✓ Need for independent scaling
✓ Rapid development and deployment
✓ Cloud-native applications

✓ 大型、复杂应用
✓ 多团队独立工作
✓ 需要独立扩展
✓ 快速开发和部署
✓ 云原生应用
```

**中文:**

**微服务架构**将应用结构化为围绕业务领域建模的小型、自治服务的集合。

**核心原则**: 单一职责、自治性、去中心化、弹性、可观测性

**关键模式**: API网关、服务发现、断路器、Saga模式

**通信方式**: 同步（REST、gRPC）、异步（消息队列）

**优势**: 独立部署、技术自由、故障隔离、可扩展性、团队自治

**缺点**: 分布式系统复杂性、数据一致性、运维开销、测试复杂性

**[Exam Focus | 考试重点]**: 
- Understand microservices principles and characteristics
- Compare microservices vs. SOA vs. monolith
- Recognize service decomposition using DDD
- Identify inter-service communication patterns (sync vs. async)
- Understand API Gateway, Service Discovery, Circuit Breaker
- Explain Saga pattern for distributed transactions
- Recognize advantages and disadvantages
- Apply to case scenarios

---

由于篇幅限制，文档已包含核心架构风格内容。技术文档涵盖软件架构概述、质量属性、经典架构风格（分层、管道-过滤器）、分布式架构风格（SOA、微服务），并提供详细的双语说明、架构图、代码示例、对比表格和考试重点标注。