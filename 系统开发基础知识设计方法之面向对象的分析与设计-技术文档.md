# Object-Oriented Analysis and Design: A Comprehensive Technical Guide

# 面向对象的分析与设计：完整技术文档

---

## 1. Fundamentals of Object-Oriented Paradigm

### 1.1 Origins and Evolution of OO Thinking

**Object-Oriented Programming (OOP)** emerged in the 1960s with the development of Simula, the first language to introduce the concept of objects and classes. The paradigm gained widespread adoption in the 1980s and 1990s with languages like Smalltalk, C++, and Java.

**面向对象编程（OOP）**起源于20世纪60年代Simula语言的发展，这是第一种引入对象和类概念的语言。该范式在20世纪80年代和90年代随着Smalltalk、C++和Java等语言的出现而获得广泛采用。

**Key Milestones:**

**关键里程碑：**

- **1960s**: Simula introduces objects and classes
  **20世纪60年代**：Simula引入对象和类
- **1970s**: Smalltalk develops pure OO environment
  **20世纪70年代**：Smalltalk发展纯面向对象环境
- **1980s**: C++ brings OO to mainstream, Booch method emerges
  **20世纪80年代**：C++将面向对象带入主流，Booch方法出现
- **1990s**: UML standardization, Java popularizes OO
  **20世纪90年代**：UML标准化，Java普及面向对象
- **2000s**: Design patterns mature, Agile OO practices evolve
  **21世纪初**：设计模式成熟，敏捷面向对象实践演化

### 1.2 Objects and Classes

**Object** is the fundamental unit in object-oriented paradigm. An object encapsulates both data (attributes/properties) and behavior (methods/operations).

**对象**是面向对象范式中的基本单元。对象封装了数据（属性/特性）和行为（方法/操作）。

**Object Characteristics:**

**对象特征：**

**1) Identity**
Each object has a unique identity that distinguishes it from other objects, even if they have identical attribute values.

**1) 标识**
每个对象都有唯一的标识，使其与其他对象区分开来，即使它们具有相同的属性值。

**2) State**
The state of an object is defined by the values of its attributes at a given time.

**2) 状态**
对象的状态由其属性在给定时间的值定义。

**3) Behavior**
Behavior is defined by the operations/methods the object can perform and how it responds to messages.

**3) 行为**
行为由对象可以执行的操作/方法以及它如何响应消息定义。

**Class** is a template or blueprint for creating objects. It defines the structure (attributes) and behavior (methods) that its objects will have.

**类**是创建对象的模板或蓝图。它定义了其对象将具有的结构（属性）和行为（方法）。

**Example:**

**示例：**

```java
// Class definition (类定义)
public class BankAccount {
    // Attributes (属性)
    private String accountNumber;
    private double balance;
    private String ownerName;
    
    // Constructor (构造函数)
    public BankAccount(String accountNumber, String ownerName) {
        this.accountNumber = accountNumber;
        this.ownerName = ownerName;
        this.balance = 0.0;
    }
    
    // Methods/Behavior (方法/行为)
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }
    
    public boolean withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;
    }
    
    public double getBalance() {
        return balance;
    }
}

// Object creation (对象创建)
BankAccount account1 = new BankAccount("ACC001", "John Doe");
BankAccount account2 = new BankAccount("ACC002", "Jane Smith");
```

### 1.3 Core OO Principles: Encapsulation, Inheritance, Polymorphism

**Encapsulation (封装)**

Encapsulation is the bundling of data and methods that operate on that data within a single unit (class), and restricting direct access to some of the object's components.

封装是将数据和操作该数据的方法捆绑在单个单元（类）中，并限制对对象某些组件的直接访问。

**Benefits:**
- **Information hiding**: Internal implementation details are hidden
- **Data protection**: Prevents unauthorized access and modification
- **Modularity**: Changes to internal implementation don't affect external code
- **Flexibility**: Easy to change implementation without breaking client code

**好处：**
- **信息隐藏**：隐藏内部实现细节
- **数据保护**：防止未经授权的访问和修改
- **模块化**：对内部实现的更改不会影响外部代码
- **灵活性**：易于更改实现而不破坏客户端代码

**Example:**

**示例：**

```java
public class Employee {
    // Private attributes (私有属性) - encapsulated
    private String name;
    private double salary;
    
    // Public methods (公共方法) - controlled access
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public double getSalary() {
        return salary;
    }
    
    public void setSalary(double salary) {
        // Business rule enforcement (业务规则强制)
        if (salary >= 0) {
            this.salary = salary;
        }
    }
}
```

**Inheritance (继承)**

Inheritance allows a class (subclass/child) to inherit attributes and methods from another class (superclass/parent), promoting code reuse and establishing hierarchical relationships.

继承允许一个类（子类/子类）从另一个类（超类/父类）继承属性和方法，促进代码重用并建立层次关系。

**Types of Inheritance:**
- **Single Inheritance**: Class inherits from one parent
- **Multiple Inheritance**: Class inherits from multiple parents (not supported in Java, supported in C++)
- **Multilevel Inheritance**: Class inherits from a class that inherits from another
- **Hierarchical Inheritance**: Multiple classes inherit from one parent

**继承类型：**
- **单继承**：类从一个父类继承
- **多重继承**：类从多个父类继承（Java不支持，C++支持）
- **多层继承**：类从继承自另一个类的类继承
- **分层继承**：多个类从一个父类继承

**Example:**

**示例：**

```java
// Parent class (父类)
public class Vehicle {
    protected String brand;
    protected int year;
    
    public void start() {
        System.out.println("Vehicle starting...");
    }
}

// Child class (子类)
public class Car extends Vehicle {
    private int numberOfDoors;
    
    // Inherited: brand, year, start()
    // Added: numberOfDoors
    
    @Override
    public void start() {
        System.out.println("Car engine starting...");
    }
    
    public void openTrunk() {
        System.out.println("Trunk opened");
    }
}
```

**Polymorphism (多态)**

Polymorphism allows objects of different classes to be treated as objects of a common superclass, and enables the same operation to behave differently on different classes.

多态允许不同类的对象被视为公共超类的对象，并使相同的操作在不同类上表现不同。

**Types of Polymorphism:**

**多态类型：**

**1) Compile-time Polymorphism (Static Binding)**
- Method overloading
- Operator overloading

**1) 编译时多态（静态绑定）**
- 方法重载
- 运算符重载

**2) Runtime Polymorphism (Dynamic Binding)**
- Method overriding
- Interface implementation

**2) 运行时多态（动态绑定）**
- 方法重写
- 接口实现

**Example:**

**示例：**

```java
// Polymorphism through inheritance (通过继承的多态)
public class Animal {
    public void makeSound() {
        System.out.println("Animal sound");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof!");
    }
}

public class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Meow!");
    }
}

// Usage (使用)
Animal animal1 = new Dog();
Animal animal2 = new Cat();

animal1.makeSound(); // Output: Woof!
animal2.makeSound(); // Output: Meow!
```

### 1.4 Abstraction and Interfaces

**Abstraction** is the process of hiding complex implementation details and showing only essential features of an object.

**抽象**是隐藏复杂实现细节并仅显示对象基本特征的过程。

**Abstract Classes:**
- Cannot be instantiated
- May contain abstract methods (without implementation)
- May contain concrete methods (with implementation)
- Used for common behavior across subclasses

**抽象类：**
- 不能被实例化
- 可以包含抽象方法（无实现）
- 可以包含具体方法（有实现）
- 用于子类之间的公共行为

**Interfaces:**
- Pure abstraction (all methods are abstract in traditional definition)
- Defines a contract that implementing classes must fulfill
- Supports multiple inheritance of type
- Promotes loose coupling

**接口：**
- 纯抽象（传统定义中所有方法都是抽象的）
- 定义实现类必须履行的契约
- 支持类型的多重继承
- 促进松耦合

**Example:**

**示例：**

```java
// Interface (接口)
public interface Drawable {
    void draw();
    void resize(int width, int height);
}

// Abstract class (抽象类)
public abstract class Shape {
    protected String color;
    
    public Shape(String color) {
        this.color = color;
    }
    
    // Abstract method (抽象方法)
    public abstract double calculateArea();
    
    // Concrete method (具体方法)
    public String getColor() {
        return color;
    }
}

// Concrete class (具体类)
public class Circle extends Shape implements Drawable {
    private double radius;
    
    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a " + color + " circle");
    }
    
    @Override
    public void resize(int width, int height) {
        // Resize logic
    }
}
```

### 1.5 OO vs. Procedural Programming

**Comparison Table:**

**对比表：**

| Aspect           | Procedural Programming  | Object-Oriented Programming |
| ---------------- | ----------------------- | --------------------------- |
| **Focus**        | Functions/procedures    | Objects and classes         |
| **Data**         | Separate from functions | Encapsulated with methods   |
| **Approach**     | Top-down                | Bottom-up                   |
| **Code Reuse**   | Function calls          | Inheritance, composition    |
| **Modification** | Affects entire program  | Localized to classes        |
| **Security**     | Low (data exposed)      | High (encapsulation)        |
| **Examples**     | C, Pascal, Fortran      | Java, C++, Python, C#       |

| 方面         | 面向过程编程       | 面向对象编程          |
| ------------ | ------------------ | --------------------- |
| **关注点**   | 函数/过程          | 对象和类              |
| **数据**     | 与函数分离         | 与方法封装            |
| **方法**     | 自顶向下           | 自底向上              |
| **代码重用** | 函数调用           | 继承、组合            |
| **修改**     | 影响整个程序       | 局限于类              |
| **安全性**   | 低（数据暴露）     | 高（封装）            |
| **示例**     | C、Pascal、Fortran | Java、C++、Python、C# |

---

## 2. Object-Oriented Analysis (OOA)

### 2.1 Definition, Goals, and Value

**Object-Oriented Analysis (OOA)** is the process of examining and understanding the problem domain, identifying objects, classes, and their relationships to create a conceptual model of the system.

**面向对象分析（OOA）**是检查和理解问题域、识别对象、类及其关系以创建系统概念模型的过程。

**Goals of OOA:**

**OOA的目标：**

**1) Problem Domain Understanding**
Gain deep insight into the business domain and requirements.

**1) 问题域理解**
深入了解业务领域和需求。

**2) Identify Key Abstractions**
Discover the essential objects, classes, and concepts.

**2) 识别关键抽象**
发现基本对象、类和概念。

**3) Define Relationships**
Establish how objects interact and relate to each other.

**3) 定义关系**
建立对象如何交互和相互关联。

**4) Capture Behavior**
Model dynamic aspects and system behavior.

**4) 捕获行为**
建模动态方面和系统行为。

**5) Create Foundation for Design**
Provide a solid basis for subsequent design activities.

**5) 为设计创建基础**
为后续设计活动提供坚实基础。

**Value Proposition:**

**价值主张：**

- **Alignment with real world**: Models mirror domain concepts
  **与现实世界对齐**：模型反映领域概念
- **Communication**: Common vocabulary for stakeholders
  **沟通**：利益相关者的共同词汇
- **Traceability**: Clear path from requirements to implementation
  **可追溯性**：从需求到实现的清晰路径
- **Reusability**: Analysis models can be reused across projects
  **可重用性**：分析模型可以跨项目重用

### 2.2 Problem Domain Modeling

**Problem domain** is the specific area of expertise or knowledge that the software system addresses.

**问题域**是软件系统解决的特定专业或知识领域。

**Domain Modeling Process:**

**领域建模过程：**

**Step 1: Identify Domain Concepts**
Extract nouns from requirements documents, user stories, and domain expert interviews.

**步骤1：识别领域概念**
从需求文档、用户故事和领域专家访谈中提取名词。

**Step 2: Define Attributes**
Determine the properties that describe each concept.

**步骤2：定义属性**
确定描述每个概念的属性。

**Step 3: Establish Relationships**
Identify associations, aggregations, and generalizations.

**步骤3：建立关系**
识别关联、聚合和泛化。

**Step 4: Validate with Stakeholders**
Review and refine the model with domain experts.

**步骤4：与利益相关者验证**
与领域专家审查和精化模型。

**Example: Library System Domain Model**

**示例：图书馆系统领域模型**

**Key Concepts:**
- Book (书籍)
- Member (会员)
- Loan (借阅)
- Librarian (图书管理员)
- Publisher (出版商)

**Attributes:**
- Book: title, ISBN, author, publicationYear
- Member: memberID, name, address, phone
- Loan: loanDate, dueDate, returnDate

**Relationships:**
- Member borrows Book (多对多)
- Book is published by Publisher (多对一)
- Librarian manages Loan (一对多)

### 2.3 Use Case Analysis and Modeling

**Use Case** describes how a system interacts with external actors to achieve specific goals.

**用例**描述系统如何与外部参与者交互以实现特定目标。

**Use Case Components:**

**用例组成部分：**

**1) Actor**
External entity that interacts with the system (user, external system, timer).

**1) 参与者**
与系统交互的外部实体（用户、外部系统、定时器）。

**2) Use Case**
A specific functionality or service provided by the system.

**2) 用例**
系统提供的特定功能或服务。

**3) System Boundary**
Defines what is inside and outside the system.

**3) 系统边界**
定义系统内部和外部的内容。

**4) Relationships**
- **Include**: Common behavior extracted to separate use case
- **Extend**: Optional behavior added conditionally
- **Generalization**: Specialized use case inherits from general one

**4) 关系**
- **包含**：提取到单独用例的公共行为
- **扩展**：有条件添加的可选行为
- **泛化**：专门化用例从一般用例继承

**Use Case Diagram Example: Online Shopping**

**用例图示例：在线购物**

```
Actor: Customer (顾客)

Use Cases:
- Browse Products (浏览产品)
- Search Products (搜索产品)
- Add to Cart (添加到购物车)
- Checkout (结账)
  <<include>> Process Payment (处理支付)
  <<include>> Verify Stock (验证库存)
- Track Order (跟踪订单)

Actor: Admin (管理员)

Use Cases:
- Manage Products (管理产品)
- View Reports (查看报告)
```

**Use Case Description Template:**

**用例描述模板：**

```
Use Case Name: Checkout (结账)
ID: UC-003
Actor: Customer (顾客)
Preconditions: Customer has items in cart (顾客购物车中有商品)
Postconditions: Order is placed (订单已下达)

Main Flow (主流程):
1. Customer selects checkout (顾客选择结账)
2. System displays order summary (系统显示订单摘要)
3. Customer enters shipping address (顾客输入收货地址)
4. Customer selects payment method (顾客选择支付方式)
5. System processes payment (系统处理支付)
6. System confirms order (系统确认订单)

Alternative Flows (替代流程):
- 5a. Payment fails (支付失败)
  - 5a1. System displays error message (系统显示错误消息)
  - 5a2. Return to step 4 (返回步骤4)
```

### 2.4 Domain Model and Conceptual Class Diagram

**Domain Model** (also called Conceptual Model) represents real-world concepts, not software objects.

**领域模型**（也称为概念模型）表示现实世界的概念，而不是软件对象。

**Characteristics:**
- Focus on understanding, not design
- Uses domain terminology
- Shows conceptual classes, not implementation classes
- Depicts relationships and multiplicities

**特征：**
- 专注于理解，而不是设计
- 使用领域术语
- 显示概念类，而不是实现类
- 描述关系和多重性

**Conceptual Class Diagram Elements:**

**概念类图元素：**

**1) Conceptual Classes**
Boxes with class name and optionally attributes.

**1) 概念类**
带有类名和可选属性的框。

**2) Associations**
Lines connecting classes with relationship names.

**2) 关联**
连接具有关系名称的类的线。

**3) Multiplicity**
Numbers indicating how many instances participate in a relationship.
- 1: Exactly one
- 0..1: Zero or one
- *: Zero or more
- 1..*: One or more
- m..n: Between m and n

**3) 多重性**
指示有多少实例参与关系的数字。
- 1：恰好一个
- 0..1：零或一个
- *：零或多个
- 1..*：一个或多个
- m..n：m到n之间

**Example: E-commerce Domain Model**

**示例：电子商务领域模型**

```
[Customer] 1 -------- places -------- * [Order]
    |                                      |
    | has                                  | contains
    |                                      |
    * [Address]                            * [OrderLine]
                                           |
                                           | refers to
                                           |
                                           * [Product]
                                           |
                                           | belongs to
                                           |
                                           * [Category]
```

### 2.5 Identifying Objects and Classes

**Techniques for Identifying Classes:**

**识别类的技术：**

**1) Noun Analysis**
Extract nouns from requirements and use case descriptions.

**1) 名词分析**
从需求和用例描述中提取名词。

**Example:**
"A *customer* can search for *products* by *category*, add them to a *shopping cart*, and complete a *purchase* using a *credit card*."

**示例：**
"*顾客*可以按*类别*搜索*产品*，将它们添加到*购物车*，并使用*信用卡*完成*购买*。"

**Identified Classes:** Customer, Product, Category, ShoppingCart, Purchase, CreditCard

**识别的类：** Customer（顾客）、Product（产品）、Category（类别）、ShoppingCart（购物车）、Purchase（购买）、CreditCard（信用卡）

**2) Scenario Walkthrough**
Trace through scenarios and identify participating entities.

**2) 场景演练**
追踪场景并识别参与实体。

**3) CRC Cards (Class-Responsibility-Collaborator)**
Brainstorming technique to identify classes, their responsibilities, and collaborations.

**3) CRC卡（类-职责-协作者）**
识别类、其职责和协作的头脑风暴技术。

**4) Domain Expert Consultation**
Interview subject matter experts to understand domain concepts.

**4) 领域专家咨询**
采访主题专家以了解领域概念。

**Filtering Criteria:**

**筛选标准：**

**Include as Class if:**
- Has identity and state
- Has behavior or responsibilities
- Multiple instances exist
- Persists over time

**作为类包含，如果：**
- 具有标识和状态
- 具有行为或职责
- 存在多个实例
- 随时间持续

**Exclude if:**
- Attribute of another class (e.g., "color" → attribute of Product)
- Redundant or synonym
- Vague or too abstract
- Implementation detail

**排除，如果：**
- 另一个类的属性（例如，"颜色" → Product的属性）
- 冗余或同义词
- 模糊或太抽象
- 实现细节

### 2.6 Determining Object Relationships

**Types of Relationships:**

**关系类型：**

**1) Association (关联)**
A structural relationship indicating that objects of one class are connected to objects of another class.

**1) 关联**
结构关系，表示一个类的对象与另一个类的对象连接。

**Notation:** Solid line
**Example:** Student enrolls in Course

**表示法：** 实线
**示例：** 学生注册课程

**2) Aggregation (聚合)**
A "has-a" relationship representing a whole-part relationship where the part can exist independently of the whole.

**2) 聚合**
"具有"关系，表示整体-部分关系，其中部分可以独立于整体存在。

**Notation:** Hollow diamond on the whole side
**Example:** Department has Employee (employee can exist without department)

**表示法：** 整体侧的空心菱形
**示例：** 部门有员工（员工可以在没有部门的情况下存在）

**3) Composition (组合)**
A stronger form of aggregation where the part cannot exist independently of the whole.

**3) 组合**
聚合的更强形式，其中部分不能独立于整体存在。

**Notation:** Filled diamond on the whole side
**Example:** House has Room (room cannot exist without house)

**表示法：** 整体侧的实心菱形
**示例：** 房子有房间（房间不能在没有房子的情况下存在）

**4) Dependency (依赖)**
A weaker relationship where one class uses or depends on another class temporarily.

**4) 依赖**
较弱的关系，其中一个类临时使用或依赖于另一个类。

**Notation:** Dashed arrow
**Example:** PaymentProcessor uses PaymentGateway

**表示法：** 虚线箭头
**示例：** PaymentProcessor使用PaymentGateway

**5) Generalization (泛化/继承)**
An "is-a" relationship representing inheritance hierarchy.

**5) 泛化（继承）**
"是"关系，表示继承层次结构。

**Notation:** Hollow arrow pointing to parent
**Example:** Car is a Vehicle

**表示法：** 指向父类的空心箭头
**示例：** 汽车是车辆

**6) Realization (实现)**
A relationship where a class implements an interface.

**6) 实现**
类实现接口的关系。

**Notation:** Dashed line with hollow arrow
**Example:** ArrayList implements List interface

**表示法：** 带空心箭头的虚线
**示例：** ArrayList实现List接口

**Relationship Selection Guide:**

**关系选择指南：**

| Relationship   | Question to Ask                                | Example                 |
| -------------- | ---------------------------------------------- | ----------------------- |
| Association    | Are they simply related?                       | Customer places Order   |
| Aggregation    | Is it a whole-part where part survives?        | Team has Player         |
| Composition    | Is it a whole-part where part dies with whole? | Order has OrderLine     |
| Dependency     | Does one temporarily use another?              | Controller uses Service |
| Generalization | Is one a specialized version of another?       | Manager is an Employee  |

| 关系 | 要问的问题                        | 示例           |
| ---- | --------------------------------- | -------------- |
| 关联 | 它们是否简单相关？                | 顾客下订单     |
| 聚合 | 是否是整体-部分，部分可以存活？   | 团队有球员     |
| 组合 | 是否是整体-部分，部分随整体消亡？ | 订单有订单行   |
| 依赖 | 一个是否临时使用另一个？          | 控制器使用服务 |
| 泛化 | 一个是否是另一个的专门化版本？    | 经理是员工     |

### 2.7 Behavioral Modeling

**Behavioral modeling** captures dynamic aspects of the system—how objects interact over time and respond to events.

**行为建模**捕获系统的动态方面——对象如何随时间交互并响应事件。

**Key UML Diagrams for Behavior:**

**行为的关键UML图：**

**1) State Machine Diagram (状态机图)**

Shows the different states an object can be in and transitions between states triggered by events.

显示对象可以处于的不同状态以及由事件触发的状态之间的转换。

**Components:**
- **State**: A condition or situation during the life of an object
- **Transition**: Movement from one state to another
- **Event**: Trigger that causes a transition
- **Action**: Operation executed during a transition
- **Guard Condition**: Condition that must be true for transition to occur

**组成部分：**
- **状态**：对象生命期间的条件或情况
- **转换**：从一个状态移动到另一个状态
- **事件**：导致转换的触发器
- **动作**：在转换期间执行的操作
- **保护条件**：必须为真才能发生转换的条件

**Example: Order State Machine**

**示例：订单状态机**

```
[Initial] → [Created]
              |
              | submit / validate
              ↓
            [Pending Approval]
              |           |
  approved /  |           | rejected
  charge     |           |
              ↓           ↓
            [Approved]  [Rejected]
              |
              | shipped
              ↓
            [Shipped]
              |
              | delivered
              ↓
            [Completed]
```

**2) Activity Diagram (活动图)**

Shows the workflow or flow of control in a process, similar to flowcharts but with richer notation.

显示过程中的工作流或控制流，类似于流程图但具有更丰富的表示法。

**Components:**
- **Activity**: Work to be performed
- **Decision Node**: Branching based on conditions
- **Merge Node**: Bringing branches together
- **Fork**: Splitting into parallel flows
- **Join**: Synchronizing parallel flows
- **Swimlanes**: Partitioning activities by actor/system

**组成部分：**
- **活动**：要执行的工作
- **决策节点**：基于条件的分支
- **合并节点**：将分支汇集在一起
- **分叉**：分成并行流
- **连接**：同步并行流
- **泳道**：按参与者/系统划分活动

**Example: Order Processing Activity**

**示例：订单处理活动**

```
[Start]
  ↓
(Receive Order) 接收订单
  ↓
<Check Stock> 检查库存
  ↓         ↓
[Yes]      [No]
  ↓         ↓
(Process  (Notify Customer) 通知顾客
 Payment)   ↓
  ↓        [End]
(Ship 
 Order)
  ↓
[End]
```

**3) Sequence Diagram (序列图)**

Depicts object interactions arranged in time sequence, showing how objects collaborate to realize a use case.

描述按时间顺序排列的对象交互，显示对象如何协作实现用例。

**Components:**
- **Lifeline**: Vertical dashed line representing object existence
- **Activation**: Rectangle on lifeline showing when object is active
- **Message**: Horizontal arrow showing communication between objects
- **Return Message**: Dashed arrow showing return from a call

**组成部分：**
- **生命线**：表示对象存在的垂直虚线
- **激活**：生命线上的矩形，显示对象何时处于活动状态
- **消息**：显示对象之间通信的水平箭头
- **返回消息**：显示从调用返回的虚线箭头

**Example: Login Sequence**

**示例：登录序列**

```
User          UI          Controller      AuthService     Database
  |            |               |               |              |
  |--login---->|               |               |              |
  |            |--authenticate->|               |              |
  |            |               |--verify------->|              |
  |            |               |               |--query------>|
  |            |               |               |<--result-----|
  |            |               |<--valid/invalid|              |
  |            |<--result------|               |              |
  |<--display--|               |               |              |
```

---

## 3. Object-Oriented Design (OOD)

### 3.1 Definition, Goals, and Principles

**Object-Oriented Design (OOD)** is the process of refining the analysis model and defining how the system will be implemented, including detailed class structures, interfaces, and interactions.

**面向对象设计（OOD）**是精化分析模型并定义系统将如何实现的过程，包括详细的类结构、接口和交互。

**Goals of OOD:**

**OOD的目标：**

**1) Bridge Analysis and Implementation**
Transform conceptual models into implementable structures.

**1) 连接分析和实现**
将概念模型转换为可实现的结构。

**2) Define Software Architecture**
Establish high-level organization and component structure.

**2) 定义软件架构**
建立高级组织和组件结构。

**3) Apply Design Principles**
Ensure code is maintainable, extensible, and robust.

**3) 应用设计原则**
确保代码可维护、可扩展和健壮。

**4) Optimize for Quality Attributes**
Address performance, security, scalability, etc.

**4) 针对质量属性优化**
解决性能、安全性、可扩展性等。

**5) Prepare for Implementation**
Create detailed specifications developers can code from.

**5) 为实现做准备**
创建开发人员可以编码的详细规范。

**Key Principles:**

**关键原则：**

- **Separation of Concerns**: Divide system into distinct features with minimal overlap
  **关注点分离**：将系统划分为重叠最少的不同功能
- **High Cohesion**: Keep related functionality together within a class/module
  **高内聚**：将相关功能保持在类/模块中
- **Low Coupling**: Minimize dependencies between classes/modules
  **低耦合**：最小化类/模块之间的依赖关系
- **Information Hiding**: Hide implementation details behind interfaces
  **信息隐藏**：在接口后面隐藏实现细节
- **Design for Change**: Anticipate future modifications
  **为变化而设计**：预测未来的修改

### 3.2 From Analysis to Design Transformation

**Transformation Activities:**

**转换活动：**

**1) Add Technical Details**
- Data types for attributes
- Method signatures (parameters, return types)
- Access modifiers (public, private, protected)
- Exception handling

**1) 添加技术细节**
- 属性的数据类型
- 方法签名（参数、返回类型）
- 访问修饰符（公共、私有、受保护）
- 异常处理

**Example Transformation:**

**示例转换：**

**Analysis Model (分析模型):**
```
Customer
- name
- address
+ placeOrder()
```

**Design Model (设计模型):**
```java
public class Customer {
    private String customerID;
    private String name;
    private Address shippingAddress;
    private Address billingAddress;
    private List<Order> orderHistory;
    
    public Order placeOrder(List<OrderLine> items) 
        throws InsufficientStockException, PaymentFailedException {
        // Implementation
    }
    
    public void updateProfile(String name, Address address) {
        // Implementation
    }
}
```

**2) Introduce Design Patterns**
Apply proven solutions to common design problems.

**2) 引入设计模式**
将经过验证的解决方案应用于常见设计问题。

**3) Define Architectural Layers**
Organize classes into layers (presentation, business logic, data access).

**3) 定义架构层**
将类组织成层（表示、业务逻辑、数据访问）。

**4) Specify Interfaces and Contracts**
Define clear contracts between components.

**4) 指定接口和契约**
定义组件之间的明确契约。

**5) Address Non-Functional Requirements**
Incorporate security, performance, and other quality attributes.

**5) 解决非功能需求**
纳入安全性、性能和其他质量属性。

### 3.3 Architectural Design and Layered Architecture

**Layered Architecture** is a fundamental architectural pattern that organizes system into horizontal layers, each providing services to the layer above.

**分层架构**是一种基本的架构模式，将系统组织成水平层，每层为上层提供服务。

**Common Layers:**

**常见层：**

**1) Presentation Layer (表示层)**
- Handles user interface and user interaction
- Displays information to users
- Captures user input
- Technologies: HTML, CSS, JavaScript, Mobile UI frameworks

**1) 表示层**
- 处理用户界面和用户交互
- 向用户显示信息
- 捕获用户输入
- 技术：HTML、CSS、JavaScript、移动UI框架

**2) Business Logic Layer (业务逻辑层) / Domain Layer**
- Contains core business rules and processes
- Implements use cases
- Domain objects and services
- Independent of UI and data storage

**2) 业务逻辑层/领域层**
- 包含核心业务规则和流程
- 实现用例
- 领域对象和服务
- 独立于UI和数据存储

**3) Data Access Layer (数据访问层) / Persistence Layer**
- Manages data storage and retrieval
- Database operations (CRUD)
- ORM (Object-Relational Mapping)
- Repository pattern implementation

**3) 数据访问层/持久层**
- 管理数据存储和检索
- 数据库操作（CRUD）
- ORM（对象关系映射）
- 仓储模式实现

**4) Infrastructure Layer (基础设施层)**
- Supporting services (logging, configuration, caching)
- Third-party integrations
- Security and authentication

**4) 基础设施层**
- 支持服务（日志记录、配置、缓存）
- 第三方集成
- 安全和身份验证

**Benefits:**
- **Separation of concerns**: Each layer has distinct responsibility
- **Testability**: Layers can be tested independently
- **Maintainability**: Changes are localized to specific layers
- **Reusability**: Business logic can be reused across different UIs
- **Scalability**: Layers can be deployed separately

**好处：**
- **关注点分离**：每层有不同的职责
- **可测试性**：层可以独立测试
- **可维护性**：更改局限于特定层
- **可重用性**：业务逻辑可以跨不同UI重用
- **可扩展性**：层可以单独部署

**Example Architecture:**

**示例架构：**

```
┌─────────────────────────────────────┐
│  Presentation Layer (表示层)         │
│  - Web Controllers                   │
│  - View Models                       │
│  - UI Components                     │
└────────────┬────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│  Application Layer (应用层)          │
│  - Use Case Coordinators             │
│  - Application Services              │
│  - DTOs (Data Transfer Objects)      │
└────────────┬────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│  Domain Layer (领域层)                │
│  - Domain Entities                   │
│  - Domain Services                   │
│  - Business Rules                    │
└────────────┬────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│  Infrastructure Layer (基础设施层)    │
│  - Repositories (具体实现)            │
│  - ORM / Database Access             │
│  - External Service Clients          │
└─────────────────────────────────────┘
```

### 3.4 Detailed Design and Class Design

**Detailed design** specifies the internal structure of classes, including all attributes, methods, and their implementations.

**详细设计**指定类的内部结构，包括所有属性、方法及其实现。

**Class Design Checklist:**

**类设计检查表：**

**1) Attributes**
- Data type specified
- Visibility defined (private, protected, public)
- Default values determined
- Constraints documented

**1) 属性**
- 指定数据类型
- 定义可见性（私有、受保护、公共）
- 确定默认值
- 记录约束

**2) Methods**
- Complete signature (name, parameters, return type)
- Preconditions and postconditions
- Exception handling
- Algorithm/pseudocode

**2) 方法**
- 完整签名（名称、参数、返回类型）
- 前置条件和后置条件
- 异常处理
- 算法/伪代码

**3) Relationships**
- Navigability specified
- Multiplicity clarified
- Role names assigned

**3) 关系**
- 指定导航性
- 澄清多重性
- 分配角色名称

**4) Responsibilities**
- Single Responsibility Principle applied
- Cohesive functionality

**4) 职责**
- 应用单一职责原则
- 内聚功能

**Design Class Diagram Example:**

**设计类图示例：**

```java
public class ShoppingCart {
    // Attributes (属性)
    private String cartID;
    private Customer owner;
    private List<CartItem> items;
    private LocalDateTime createdDate;
    private LocalDateTime lastModified;
    
    // Constructor (构造函数)
    public ShoppingCart(Customer owner) {
        this.cartID = UUID.randomUUID().toString();
        this.owner = owner;
        this.items = new ArrayList<>();
        this.createdDate = LocalDateTime.now();
        this.lastModified = LocalDateTime.now();
    }
    
    // Methods (方法)
    public void addItem(Product product, int quantity) 
        throws InvalidQuantityException {
        if (quantity <= 0) {
            throw new InvalidQuantityException("Quantity must be positive");
        }
        
        // Check if product already in cart
        Optional<CartItem> existing = items.stream()
            .filter(item -> item.getProduct().equals(product))
            .findFirst();
            
        if (existing.isPresent()) {
            existing.get().increaseQuantity(quantity);
        } else {
            items.add(new CartItem(product, quantity));
        }
        
        updateLastModified();
    }
    
    public void removeItem(String productID) {
        items.removeIf(item -> 
            item.getProduct().getProductID().equals(productID));
        updateLastModified();
    }
    
    public BigDecimal calculateTotal() {
        return items.stream()
            .map(CartItem::getSubtotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    public int getItemCount() {
        return items.stream()
            .mapToInt(CartItem::getQuantity)
            .sum();
    }
    
    private void updateLastModified() {
        this.lastModified = LocalDateTime.now();
    }
    
    // Getters (获取器)
    public String getCartID() { return cartID; }
    public Customer getOwner() { return owner; }
    public List<CartItem> getItems() { 
        return Collections.unmodifiableList(items); 
    }
}
```

### 3.5 Interface Design and Contracts

**Interface** defines a contract—a set of method signatures that implementing classes must provide.

**接口**定义契约——实现类必须提供的一组方法签名。

**Design by Contract Principles:**

**契约设计原则：**

**1) Preconditions**
Conditions that must be true before a method executes. Client's responsibility to satisfy.

**1) 前置条件**
在方法执行之前必须为真的条件。客户端有责任满足。

**2) Postconditions**
Conditions guaranteed to be true after method executes successfully.

**2) 后置条件**
方法成功执行后保证为真的条件。

**3) Invariants**
Conditions that must always be true for the object.

**3) 不变式**
对象必须始终为真的条件。

**Interface Design Best Practices:**

**接口设计最佳实践：**

- **Interface Segregation**: Create focused, specific interfaces rather than large, general ones
  **接口隔离**：创建专注、特定的接口而不是大而通用的接口
- **Dependency Inversion**: Depend on abstractions (interfaces) not concretions
  **依赖倒置**：依赖抽象（接口）而不是具体实现
- **Explicit Contracts**: Document preconditions, postconditions, exceptions
  **明确契约**：记录前置条件、后置条件、异常
- **Stability**: Interfaces should be more stable than implementations
  **稳定性**：接口应该比实现更稳定

**Example:**

**示例：**

```java
/**
 * Payment processing interface
 * 支付处理接口
 */
public interface PaymentProcessor {
    /**
     * Process a payment transaction
     * 处理支付交易
     * 
     * @param amount Payment amount (must be positive) 支付金额（必须为正）
     * @param paymentMethod Payment method details 支付方式详情
     * @return Transaction confirmation 交易确认
     * @throws InvalidAmountException if amount <= 0
     * @throws PaymentDeclinedException if payment is declined
     * @throws PaymentGatewayException if gateway communication fails
     * 
     * Preconditions (前置条件):
     * - amount > 0
     * - paymentMethod is valid and not expired
     * 
     * Postconditions (后置条件):
     * - If successful, transaction ID is generated
     * - Payment is recorded in the system
     */
    TransactionConfirmation processPayment(
        BigDecimal amount, 
        PaymentMethod paymentMethod
    ) throws InvalidAmountException, 
             PaymentDeclinedException, 
             PaymentGatewayException;
    
    /**
     * Refund a previous transaction
     * 退款之前的交易
     * 
     * @param transactionID Original transaction to refund
     * @param amount Refund amount (must not exceed original)
     * @return Refund confirmation
     */
    RefundConfirmation refundPayment(
        String transactionID, 
        BigDecimal amount
    ) throws TransactionNotFoundException, 
             RefundException;
}

// Concrete implementation (具体实现)
public class StripePaymentProcessor implements PaymentProcessor {
    private final StripeClient stripeClient;
    
    public StripePaymentProcessor(StripeClient client) {
        this.stripeClient = client;
    }
    
    @Override
    public TransactionConfirmation processPayment(
        BigDecimal amount, 
        PaymentMethod paymentMethod
    ) throws InvalidAmountException, 
             PaymentDeclinedException, 
             PaymentGatewayException {
        // Validate preconditions (验证前置条件)
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new InvalidAmountException("Amount must be positive");
        }
        
        if (paymentMethod == null || paymentMethod.isExpired()) {
            throw new IllegalArgumentException("Invalid payment method");
        }
        
        try {
            // Process with Stripe (使用Stripe处理)
            StripeCharge charge = stripeClient.charge(amount, paymentMethod);
            
            // Ensure postconditions (确保后置条件)
            return new TransactionConfirmation(
                charge.getId(),
                amount,
                LocalDateTime.now()
            );
        } catch (StripeException e) {
            throw new PaymentGatewayException("Stripe processing failed", e);
        }
    }
    
    @Override
    public RefundConfirmation refundPayment(
        String transactionID, 
        BigDecimal amount
    ) throws TransactionNotFoundException, RefundException {
        // Implementation
    }
}
```

### 3.6 Package and Component Diagrams

**Package Diagram** shows how classes are organized into packages (namespaces) and dependencies between packages.

**包图**显示类如何组织成包（命名空间）以及包之间的依赖关系。

**Package Design Principles:**

**包设计原则：**

**1) Reuse-Release Equivalence Principle (REP)**
The unit of reuse is the unit of release.

**1) 重用-发布等价原则（REP）**
重用的单元是发布的单元。

**2) Common Closure Principle (CCP)**
Classes that change together should be packaged together.

**2) 共同封闭原则（CCP）**
一起更改的类应该打包在一起。

**3) Common Reuse Principle (CRP)**
Classes that are used together should be in the same package.

**3) 共同重用原则（CRP）**
一起使用的类应该在同一个包中。

**4) Acyclic Dependencies Principle (ADP)**
The dependency graph of packages must be acyclic.

**4) 无环依赖原则（ADP）**
包的依赖图必须是无环的。

**5) Stable Dependencies Principle (SDP)**
Depend in the direction of stability.

**5) 稳定依赖原则（SDP）**
依赖于稳定的方向。

**6) Stable Abstractions Principle (SAP)**
A package should be as abstract as it is stable.

**6) 稳定抽象原则（SAP）**
包应该与其稳定性一样抽象。

**Example Package Structure:**

**示例包结构：**

```
com.example.ecommerce
│
├── presentation
│   ├── controllers
│   ├── viewmodels
│   └── views
│
├── application
│   ├── services
│   ├── dto
│   └── mappers
│
├── domain
│   ├── model
│   │   ├── customer
│   │   ├── order
│   │   └── product
│   ├── service
│   └── repository (interfaces)
│
└── infrastructure
    ├── persistence
    │   ├── jpa
    │   └── repositories (implementations)
    ├── messaging
    └── security
```

**Component Diagram** represents larger-scale organization, showing how major system parts (components) are structured and interact.

**组件图**表示更大规模的组织，显示主要系统部分（组件）如何构造和交互。

**Component:**
- Modular, replaceable, and reusable unit
- Encapsulates implementation and exposes interfaces
- Can be deployed independently

**组件：**
- 模块化、可替换和可重用的单元
- 封装实现并公开接口
- 可以独立部署

**Example Component Diagram:**

**示例组件图：**

```
┌─────────────────────┐
│  Web UI Component   │
│  (网页UI组件)        │
│  Provides: HTTP API │
└──────────┬──────────┘
           ↓ uses
┌─────────────────────┐       ┌──────────────────┐
│  Order Management   │←uses──│  Payment Gateway │
│  Component          │       │  Component       │
│  (订单管理组件)      │       │  (支付网关组件)   │
│  Requires: DB Access│       │  Provides: API   │
└──────────┬──────────┘       └──────────────────┘
           ↓ uses
┌─────────────────────┐
│  Database Component │
│  (数据库组件)        │
│  Provides: Data     │
│  Persistence        │
└─────────────────────┘
```

---

## 4. UML Unified Modeling Language

### 4.1 History and Standards

**Unified Modeling Language (UML)** is a standardized visual modeling language for specifying, visualizing, constructing, and documenting software systems.

**统一建模语言（UML）**是用于指定、可视化、构造和记录软件系统的标准化可视建模语言。

**History:**

**历史：**

- **1994-1995**: Grady Booch, James Rumbaugh, and Ivar Jacobson ("Three Amigos") begin unification
  **1994-1995**：Grady Booch、James Rumbaugh和Ivar Jacobson（"三巨头"）开始统一
- **1996**: UML 0.9 released
  **1996**：发布UML 0.9
- **1997**: UML 1.0 submitted to OMG (Object Management Group)
  **1997**：UML 1.0提交给OMG（对象管理组）
- **2005**: UML 2.0 released with major updates
  **2005**：发布UML 2.0，进行重大更新
- **2017**: UML 2.5.1 current standard
  **2017**：UML 2.5.1当前标准

**UML 2.x Diagram Types:**

**UML 2.x图类型：**

**Structure Diagrams (结构图) - 7 types:**
1. Class Diagram (类图)
2. Object Diagram (对象图)
3. Component Diagram (组件图)
4. Deployment Diagram (部署图)
5. Package Diagram (包图)
6. Composite Structure Diagram (组合结构图)
7. Profile Diagram (剖面图)

**Behavior Diagrams (行为图) - 7 types:**
1. Use Case Diagram (用例图)
2. State Machine Diagram (状态机图)
3. Activity Diagram (活动图)
4. Sequence Diagram (序列图)
5. Communication Diagram (通信图)
6. Timing Diagram (时序图)
7. Interaction Overview Diagram (交互概览图)

### 4.2 Class Diagram Deep Dive

**Class Diagram** is the most commonly used UML diagram, showing classes, attributes, methods, and relationships.

**类图**是最常用的UML图，显示类、属性、方法和关系。

**Notation Elements:**

**表示法元素：**

**Class Box (类框):**
```
┌─────────────────────┐
│    ClassName        │ ← Class name (类名)
├─────────────────────┤
│ - attribute1: Type  │ ← Attributes (属性)
│ # attribute2: Type  │
│ + attribute3: Type  │
├─────────────────────┤
│ + method1(): Type   │ ← Methods (方法)
│ - method2(): Type   │
└─────────────────────┘
```

**Visibility Markers (可见性标记):**
- `+` Public (公共)
- `-` Private (私有)
- `#` Protected (受保护)
- `~` Package/Internal (包/内部)

**Stereotypes (构造型):**
- `<<interface>>`: Interface
- `<<abstract>>`: Abstract class
- `<<enum>>`: Enumeration
- `<<entity>>`: Entity class
- `<<boundary>>`: Boundary class
- `<<control>>`: Control class

**Relationship Notations:**

**关系表示法：**

| Relationship         | Notation              | Example                   |
| -------------------- | --------------------- | ------------------------- |
| Association          | Solid line            | Customer ——— Order        |
| Directed Association | Solid line with arrow | Order ———> Product        |
| Aggregation          | Hollow diamond        | Department ◇——— Employee  |
| Composition          | Filled diamond        | Car ◆——— Engine           |
| Generalization       | Hollow arrow          | Dog ———▷ Animal           |
| Realization          | Dashed arrow          | ArrayList - - -▷ List     |
| Dependency           | Dashed line           | Controller - - -> Service |

**Complete Class Diagram Example:**

**完整类图示例：**

```
┌───────────────────────┐
│   <<interface>>       │
│   Payment             │
├───────────────────────┤
│ + processPayment()    │
└───────────┬───────────┘
            △
            │ implements
            │
┌───────────┴───────────┐
│   CreditCardPayment   │
├───────────────────────┤
│ - cardNumber: String  │
│ - cvv: String         │
├───────────────────────┤
│ + processPayment()    │
└───────────────────────┘

┌───────────────────────┐
│   Customer            │
├───────────────────────┤
│ - customerID: String  │
│ - name: String        │
│ - email: String       │
├───────────────────────┤
│ + placeOrder()        │
│ + getOrders(): List   │
└───────┬───────────────┘
        │ 1
        │ places
        │
        │ 0..*
┌───────┴───────────────┐
│   Order               │
├───────────────────────┤
│ - orderID: String     │
│ - orderDate: Date     │
│ - status: Status      │
├───────────────────────┤
│ + addItem()           │
│ + calculateTotal()    │
└───────┬───────────────┘
        │ 1
        │ contains
        │
        │ 1..*
┌───────┴───────────────┐
│   OrderLine           │
├───────────────────────┤
│ - quantity: int       │
│ - unitPrice: decimal  │
├───────────────────────┤
│ + getSubtotal()       │
└───────┬───────────────┘
        │ *
        │ refers to
        │
        │ 1
┌───────┴───────────────┐
│   Product             │
├───────────────────────┤
│ - productID: String   │
│ - name: String        │
│ - price: decimal      │
├───────────────────────┤
│ + getDetails()        │
└───────────────────────┘
```

### 4.3 Sequence Diagram Mastery

**Sequence Diagram** shows object interactions in time sequence, essential for understanding system dynamics.

**序列图**显示时间序列中的对象交互，对理解系统动态至关重要。

**Advanced Elements:**

**高级元素：**

**1) Combined Fragments (组合片段)**

**alt (alternative)** - Conditional logic
```
alt [condition1]
    Message1
else [condition2]
    Message2
else
    Message3
end
```

**opt (optional)** - Optional behavior
```
opt [condition]
    Message
end
```

**loop** - Iteration
```
loop [1, 10]
    Message
end
```

**par (parallel)** - Concurrent execution
```
par
    Message1
and
    Message2
end
```

**2) Interaction Use**
Reference to another sequence diagram.
```
ref OrderProcessing
```

**Complete Sequence Diagram Example: E-commerce Checkout**

**完整序列图示例：电子商务结账**

```
Customer    WebUI    OrderController    PaymentService    InventoryService    Database
  |          |              |                   |                  |             |
  |--click-->|              |                   |                  |             |
  | checkout |              |                   |                  |             |
  |          |--checkout--->|                   |                  |             |
  |          |              |                   |                  |             |
  |          |              |--checkStock------>|                  |             |
  |          |              |                   |--query---------->|             |
  |          |              |                   |                  |--SELECT---->|
  |          |              |                   |                  |<--result----||
  |          |              |                   |<--available------|             |
  |          |              |<--stockOK---------|                  |             |
  |          |              |                   |                  |             |
  |          |              | alt [stock available]               |             |
  |          |              |   |               |                  |             |
  |          |              |   |--processPayment---------------->|             |
  |          |              |   |               |<--success--------|             |
  |          |              |   |               |                  |             |
  |          |              |   |--createOrder----------------------------------->|
  |          |              |   |               |                  |<--orderID---||
  |          |              |   |               |                  |             |
  |          |              |   |--reduceStock---------------->|                 |
  |          |              |   |               |               |--UPDATE------->|
  |          |              |   |               |               |<--success------||
  |          |<--success----|   |               |                  |             |
  |<--display|              |   |               |                  |             |
  | confirm  |              |   |               |                  |             |
  |          |              | else [out of stock]                 |             |
  |          |              |   |               |                  |             |
  |          |<--error------|   |               |                  |             |
  |<--display|              | end               |                  |             |
  | error    |              |                   |                  |             |
```

### 4.4 State Machine Diagram

**State Machine Diagram** models the lifecycle of an object, showing states and transitions.

**状态机图**建模对象的生命周期，显示状态和转换。

**Advanced Concepts:**

**高级概念：**

**1) Composite States (组合状态)**
States that contain other states.

**1) 组合状态**
包含其他状态的状态。

**2) Concurrent States (并发状态)**
Multiple orthogonal regions active simultaneously.

**2) 并发状态**
同时活动的多个正交区域。

**3) Entry/Exit Actions**
Actions executed when entering/exiting a state.
```
State Name
entry / action1
exit / action2
do / activity
```

**4) History States**
Remember the last active substate.
- Shallow history: (H)
- Deep history: (H*)

**Complex State Machine Example: Order Lifecycle**

**复杂状态机示例：订单生命周期**

```
[Initial]
   |
   ↓
┌─────────────────────────────────────────────────────────┐
│ Active (活动)                                            │
│ ┌─────────────────┐  submit   ┌──────────────────┐    │
│ │  Draft          │----------->│  PendingApproval │    │
│ │  (草稿)          │            │  (待审批)         │    │
│ │ entry/create    │            │ entry/notify     │    │
│ └─────────────────┘            └────────┬─────────┘    │
│                                         │               │
│                             approved    │  rejected     │
│                         ┌───────────────┴─────┐         │
│                         ↓                     ↓         │
│                  ┌─────────────┐      ┌──────────────┐ │
│                  │  Processing │      │  Rejected    │ │
│                  │  (处理中)    │      │  (已拒绝)     │ │
│                  │ do/process  │      └──────────────┘ │
│                  └──────┬──────┘                        │
│                         │                               │
│                   shipped                               │
│                         ↓                               │
│                  ┌─────────────┐                        │
│                  │  Shipped    │                        │
│                  │  (已发货)    │                        │
│                  │ entry/track │                        │
│                  └──────┬──────┘                        │
│                         │                               │
│                  delivered                              │
│                         ↓                               │
│                  ┌─────────────┐                        │
│                  │  Delivered  │                        │
│                  │  (已送达)    │                        │
│                  └─────────────┘                        │
└─────────────────────────────────────────────────────────┘
                          │
                      complete
                          ↓
                   ┌─────────────┐
                   │  Completed  │
                   │  (已完成)    │
                   └─────────────┘
                          │
                     [Final State]
```

---

## 5. Object-Oriented Design Principles

### 5.1 SOLID Principles

**SOLID** is an acronym for five design principles that make software more maintainable and flexible.

**SOLID**是五个设计原则的首字母缩写，使软件更易维护和灵活。

**1) Single Responsibility Principle (SRP) - 单一职责原则**

**Definition:** A class should have only one reason to change.

**定义：** 一个类应该只有一个改变的理由。

**Explanation:** Each class should have only one responsibility or job. If a class has multiple responsibilities, changes to one responsibility may affect the others.

**解释：** 每个类应该只有一个职责或工作。如果一个类有多个职责，对一个职责的更改可能会影响其他职责。

**Bad Example (违反SRP):**
```java
public class Employee {
    private String name;
    private double salary;
    
    // Business logic (业务逻辑)
    public void calculateSalary() {
        // Calculation logic
    }
    
    // Persistence logic (持久化逻辑) - WRONG!
    public void saveToDatabase() {
        // Database operations
    }
    
    // Reporting logic (报告逻辑) - WRONG!
    public void generateReport() {
        // Report generation
    }
}
```

**Good Example (遵循SRP):**
```java
// Single responsibility: Employee data (员工数据)
public class Employee {
    private String name;
    private double salary;
    
    public void calculateSalary() {
        // Business logic only
    }
    
    // Getters and setters
}

// Single responsibility: Persistence (持久化)
public class EmployeeRepository {
    public void save(Employee employee) {
        // Database operations
    }
}

// Single responsibility: Reporting (报告)
public class EmployeeReportGenerator {
    public Report generate(Employee employee) {
        // Report generation
    }
}
```

**2) Open-Closed Principle (OCP) - 开闭原则**

**Definition:** Software entities should be open for extension but closed for modification.

**定义：** 软件实体应该对扩展开放，对修改关闭。

**Explanation:** You should be able to add new functionality without changing existing code.

**解释：** 您应该能够在不更改现有代码的情况下添加新功能。

**Bad Example (违反OCP):**
```java
public class DiscountCalculator {
    public double calculateDiscount(Customer customer, double price) {
        if (customer.getType().equals("Regular")) {
            return price * 0.95; // 5% discount
        } else if (customer.getType().equals("Premium")) {
            return price * 0.90; // 10% discount
        } else if (customer.getType().equals("VIP")) {
            return price * 0.80; // 20% discount
        }
        return price;
    }
}
// Adding new customer type requires modifying this class (添加新客户类型需要修改此类)
```

**Good Example (遵循OCP):**
```java
// Abstract discount strategy (抽象折扣策略)
public interface DiscountStrategy {
    double calculate(double price);
}

public class RegularCustomerDiscount implements DiscountStrategy {
    public double calculate(double price) {
        return price * 0.95;
    }
}

public class PremiumCustomerDiscount implements DiscountStrategy {
    public double calculate(double price) {
        return price * 0.90;
    }
}

public class VIPCustomerDiscount implements DiscountStrategy {
    public double calculate(double price) {
        return price * 0.80;
    }
}

public class DiscountCalculator {
    public double calculateDiscount(DiscountStrategy strategy, double price) {
        return strategy.calculate(price);
    }
}
// Adding new customer type: just create new class (添加新客户类型：只需创建新类)
```

**3) Liskov Substitution Principle (LSP) - 里氏替换原则**

**Definition:** Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.

**定义：** 超类的对象应该能够被其子类的对象替换而不破坏应用程序。

**Explanation:** Derived classes must be substitutable for their base classes. Subclasses should extend behavior, not change it.

**解释：** 派生类必须能够替代其基类。子类应该扩展行为，而不是改变它。

**Bad Example (违反LSP):**
```java
public class Bird {
    public void fly() {
        System.out.println("Flying...");
    }
}

public class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly!");
    }
}

// Problem: Penguin can't substitute Bird (问题：Penguin不能替代Bird)
void makeBirdFly(Bird bird) {
    bird.fly(); // Breaks if bird is Penguin (如果bird是Penguin则中断)
}
```

**Good Example (遵循LSP):**
```java
public abstract class Bird {
    public abstract void move();
}

public class FlyingBird extends Bird {
    @Override
    public void move() {
        fly();
    }
    
    private void fly() {
        System.out.println("Flying...");
    }
}

public class Penguin extends Bird {
    @Override
    public void move() {
        swim();
    }
    
    private void swim() {
        System.out.println("Swimming...");
    }
}

// Now any Bird can be used (现在任何Bird都可以使用)
void makeBirdMove(Bird bird) {
    bird.move(); // Works for all birds (适用于所有鸟类)
}
```

**4) Interface Segregation Principle (ISP) - 接口隔离原则**

**Definition:** Clients should not be forced to depend on interfaces they don't use.

**定义：** 客户端不应被迫依赖于它们不使用的接口。

**Explanation:** Create specific, focused interfaces rather than large, general-purpose ones.

**解释：** 创建特定的、专注的接口，而不是大而通用的接口。

**Bad Example (违反ISP):**
```java
public interface Worker {
    void work();
    void eat();
    void sleep();
}

public class HumanWorker implements Worker {
    public void work() { /* implementation */ }
    public void eat() { /* implementation */ }
    public void sleep() { /* implementation */ }
}

public class RobotWorker implements Worker {
    public void work() { /* implementation */ }
    public void eat() { /* Robot doesn't eat (机器人不吃饭) */ }
    public void sleep() { /* Robot doesn't sleep (机器人不睡觉) */ }
}
```

**Good Example (遵循ISP):**
```java
public interface Workable {
    void work();
}

public interface Eatable {
    void eat();
}

public interface Sleepable {
    void sleep();
}

public class HumanWorker implements Workable, Eatable, Sleepable {
    public void work() { /* implementation */ }
    public void eat() { /* implementation */ }
    public void sleep() { /* implementation */ }
}

public class RobotWorker implements Workable {
    public void work() { /* implementation */ }
    // No need to implement eat() and sleep() (无需实现eat()和sleep())
}
```

**5) Dependency Inversion Principle (DIP) - 依赖倒置原则**

**Definition:** 
- High-level modules should not depend on low-level modules. Both should depend on abstractions.
- Abstractions should not depend on details. Details should depend on abstractions.

**定义：**
- 高层模块不应依赖于低层模块。两者都应依赖于抽象。
- 抽象不应依赖于细节。细节应依赖于抽象。

**Bad Example (违反DIP):**
```java
public class EmailService {
    public void sendEmail(String message) {
        // Send email (发送电子邮件)
    }
}

public class NotificationService {
    private EmailService emailService = new EmailService();
    
    public void notify(String message) {
        emailService.sendEmail(message);
    }
}
// NotificationService is tightly coupled to EmailService
// (NotificationService与EmailService紧密耦合)
```

**Good Example (遵循DIP):**
```java
// Abstraction (抽象)
public interface MessageService {
    void send(String message);
}

// Low-level module (低层模块)
public class EmailService implements MessageService {
    public void send(String message) {
        // Send email (发送电子邮件)
    }
}

public class SMSService implements MessageService {
    public void send(String message) {
        // Send SMS (发送短信)
    }
}

// High-level module (高层模块)
public class NotificationService {
    private MessageService messageService;
    
    // Dependency injection (依赖注入)
    public NotificationService(MessageService messageService) {
        this.messageService = messageService;
    }
    
    public void notify(String message) {
        messageService.send(message);
    }
}

// Usage (使用)
MessageService emailService = new EmailService();
NotificationService notifier = new NotificationService(emailService);
// Easy to switch to SMS (易于切换到短信)
MessageService smsService = new SMSService();
NotificationService smsNotifier = new NotificationService(smsService);
```

### 5.2 GRASP Principles

**GRASP (General Responsibility Assignment Software Patterns)** provides guidelines for assigning responsibilities to classes and objects.

**GRASP（通用职责分配软件模式）**提供将职责分配给类和对象的指南。

**1) Information Expert (信息专家)**

Assign responsibility to the class that has the information necessary to fulfill it.

将职责分配给具有履行该职责所需信息的类。

**Example:**
```java
public class Order {
    private List<OrderLine> orderLines;
    
    // Order has the information to calculate total (Order有计算总额的信息)
    public BigDecimal calculateTotal() {
        return orderLines.stream()
            .map(OrderLine::getSubtotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}
```

**2) Creator (创建者)**

Assign class B the responsibility to create instance of class A if one of these is true:
- B contains or aggregates A
- B closely uses A
- B has initializing data for A

如果以下之一为真，则将创建类A实例的职责分配给类B：
- B包含或聚合A
- B密切使用A
- B具有A的初始化数据

**Example:**
```java
public class ShoppingCart {
    private List<CartItem> items;
    
    // ShoppingCart creates CartItem (ShoppingCart创建CartItem)
    public void addProduct(Product product, int quantity) {
        CartItem item = new CartItem(product, quantity);
        items.add(item);
    }
}
```

**3) Controller (控制器)**

Assign the responsibility of handling system events to a controller class.

将处理系统事件的职责分配给控制器类。

**Example:**
```java
public class OrderController {
    private OrderService orderService;
    
    public void createOrder(OrderRequest request) {
        // Coordinate use case (协调用例)
        orderService.processOrder(request);
    }
}
```

**4) Low Coupling (低耦合)**

Minimize dependencies between classes.

最小化类之间的依赖关系。

**5) High Cohesion (高内聚)**

Keep related responsibilities together in a class.

将相关职责保持在一个类中。

**6) Polymorphism (多态)**

Use polymorphic operations instead of conditional logic based on type.

使用多态操作而不是基于类型的条件逻辑。

**7) Pure Fabrication (纯虚构)**

Create a class that doesn't represent a domain concept to achieve low coupling and high cohesion.

创建不代表领域概念的类以实现低耦合和高内聚。

**Example:** Service classes, Repository classes

**示例：** 服务类、仓储类

**8) Indirection (间接)**

Introduce an intermediate object to mediate between other components.

引入中间对象在其他组件之间进行中介。

**Example:** Adapter, Facade patterns

**示例：** 适配器、外观模式

**9) Protected Variations (受保护变化)**

Identify points of predicted variation and create a stable interface around them.

识别预测变化的点并围绕它们创建稳定的接口。

### 5.3 Other Important Principles

**DRY (Don't Repeat Yourself) - 不要重复自己**

Every piece of knowledge must have a single, unambiguous, authoritative representation.

每一条知识都必须有一个单一、明确、权威的表示。

**KISS (Keep It Simple, Stupid) - 保持简单**

Simplicity should be a key goal; avoid unnecessary complexity.

简单应该是关键目标；避免不必要的复杂性。

**YAGNI (You Aren't Gonna Need It) - 你不会需要它**

Don't add functionality until it's necessary.

在必要之前不要添加功能。

**Law of Demeter (LoD) - 迪米特法则 / Principle of Least Knowledge - 最少知识原则**

A method should only call:
- Methods of its own class
- Methods of objects passed as parameters
- Methods of objects it creates
- Methods of contained objects

方法只应调用：
- 自己类的方法
- 作为参数传递的对象的方法
- 它创建的对象的方法
- 包含对象的方法

**Bad Example (违反):**
```java
// "Train wreck" - multiple chained calls ("火车失事" - 多个链式调用)
String city = customer.getAddress().getCity().getName();
```

**Good Example (遵循):**
```java
// Encapsulate navigation (封装导航)
String city = customer.getCityName();

// In Customer class (在Customer类中):
public String getCityName() {
    return address.getCity().getName();
}
```

**Composition Over Inheritance - 组合优于继承**

Favor object composition over class inheritance to achieve more flexible designs.

优先使用对象组合而不是类继承以实现更灵活的设计。

**Example:**
```java
// Instead of inheritance (而不是继承):
public class Car extends Engine { } // WRONG

// Use composition (使用组合):
public class Car {
    private Engine engine; // Correct
    
    public void start() {
        engine.start();
    }
}
```

---

## 6. Design Patterns

### 6.1 Introduction to Design Patterns

**Design Pattern** is a general, reusable solution to a commonly occurring problem in software design.

**设计模式**是软件设计中常见问题的通用、可重用解决方案。

**Origins:**
- **1977**: Christopher Alexander introduces patterns in architecture
  **1977**：Christopher Alexander在建筑中引入模式
- **1987**: Kent Beck and Ward Cunningham apply patterns to programming
  **1987**：Kent Beck和Ward Cunningham将模式应用于编程
- **1994**: "Gang of Four" (GoF) publishes "Design Patterns: Elements of Reusable Object-Oriented Software"
  **1994**："四人帮"（GoF）出版《设计模式：可复用面向对象软件的基础》

**Pattern Elements:**

**模式元素：**

1. **Pattern Name** (模式名称): Vocabulary for design
2. **Problem** (问题): When to apply the pattern
3. **Solution** (解决方案): Design structure, participants, collaborations
4. **Consequences** (后果): Trade-offs, benefits, costs

**GoF 23 Design Patterns Classification:**

**GoF 23种设计模式分类：**

**Creational Patterns (创建型模式) - 5 patterns:**
Focus on object creation mechanisms.

1. Singleton (单例)
2. Factory Method (工厂方法)
3. Abstract Factory (抽象工厂)
4. Builder (建造者)
5. Prototype (原型)

**Structural Patterns (结构型模式) - 7 patterns:**
Focus on object composition and relationships.

1. Adapter (适配器)
2. Bridge (桥接)
3. Composite (组合)
4. Decorator (装饰)
5. Facade (外观)
6. Flyweight (享元)
7. Proxy (代理)

**Behavioral Patterns (行为型模式) - 11 patterns:**
Focus on algorithms and responsibility assignment.

1. Chain of Responsibility (责任链)
2. Command (命令)
3. Interpreter (解释器)
4. Iterator (迭代器)
5. Mediator (中介者)
6. Memento (备忘录)
7. Observer (观察者)
8. State (状态)
9. Strategy (策略)
10. Template Method (模板方法)
11. Visitor (访问者)

### 6.2 Key Creational Patterns

**1) Singleton Pattern (单例模式)**

**Intent:** Ensure a class has only one instance and provide a global point of access to it.

**意图：** 确保类只有一个实例，并提供一个全局访问点。

**Use When:**
- Need exactly one instance of a class
- Global access point required
- Example: Configuration manager, Database connection pool

**何时使用：**
- 需要类的唯一实例
- 需要全局访问点
- 示例：配置管理器、数据库连接池

**Implementation:**

**实现：**

```java
// Thread-safe Singleton (线程安全的单例)
public class DatabaseConnection {
    // Eager initialization (饿汉式)
    private static final DatabaseConnection INSTANCE = new DatabaseConnection();
    
    private DatabaseConnection() {
        // Private constructor (私有构造函数)
    }
    
    public static DatabaseConnection getInstance() {
        return INSTANCE;
    }
    
    public void connect() {
        // Connection logic
    }
}

// Alternative: Lazy initialization with double-checked locking
// (替代方案：带双重检查锁定的懒汉式)
public class ConfigurationManager {
    private static volatile ConfigurationManager instance;
    
    private ConfigurationManager() { }
    
    public static ConfigurationManager getInstance() {
        if (instance == null) {
            synchronized (ConfigurationManager.class) {
                if (instance == null) {
                    instance = new ConfigurationManager();
                }
            }
        }
        return instance;
    }
}
```

**2) Factory Method Pattern (工厂方法模式)**

**Intent:** Define an interface for creating an object, but let subclasses decide which class to instantiate.

**意图：** 定义创建对象的接口，但让子类决定实例化哪个类。

**Use When:**
- Class can't anticipate the type of objects it must create
- Want to delegate object creation to subclasses

**何时使用：**
- 类无法预测它必须创建的对象类型
- 希望将对象创建委托给子类

**Implementation:**

**实现：**

```java
// Product interface (产品接口)
public interface Payment {
    void processPayment(double amount);
}

// Concrete products (具体产品)
public class CreditCardPayment implements Payment {
    public void processPayment(double amount) {
        System.out.println("Processing credit card payment: " + amount);
    }
}

public class PayPalPayment implements Payment {
    public void processPayment(double amount) {
        System.out.println("Processing PayPal payment: " + amount);
    }
}

// Creator (创建者)
public abstract class PaymentFactory {
    // Factory method (工厂方法)
    public abstract Payment createPayment();
    
    // Template method using factory method (使用工厂方法的模板方法)
    public void processTransaction(double amount) {
        Payment payment = createPayment();
        payment.processPayment(amount);
    }
}

// Concrete creators (具体创建者)
public class CreditCardPaymentFactory extends PaymentFactory {
    public Payment createPayment() {
        return new CreditCardPayment();
    }
}

public class PayPalPaymentFactory extends PaymentFactory {
    public Payment createPayment() {
        return new PayPalPayment();
    }
}

// Usage (使用)
PaymentFactory factory = new CreditCardPaymentFactory();
factory.processTransaction(100.00);
```

**3) Abstract Factory Pattern (抽象工厂模式)**

**Intent:** Provide an interface for creating families of related or dependent objects without specifying their concrete classes.

**意图：** 提供用于创建相关或依赖对象族的接口，而无需指定其具体类。

**Implementation:**

**实现：**

```java
// Abstract products (抽象产品)
public interface Button {
    void render();
}

public interface TextField {
    void render();
}

// Concrete products for Windows (Windows的具体产品)
public class WindowsButton implements Button {
    public void render() {
        System.out.println("Rendering Windows button");
    }
}

public class WindowsTextField implements TextField {
    public void render() {
        System.out.println("Rendering Windows text field");
    }
}

// Concrete products for Mac (Mac的具体产品)
public class MacButton implements Button {
    public void render() {
        System.out.println("Rendering Mac button");
    }
}

public class MacTextField implements TextField {
    public void render() {
        System.out.println("Rendering Mac text field");
    }
}

// Abstract factory (抽象工厂)
public interface GUIFactory {
    Button createButton();
    TextField createTextField();
}

// Concrete factories (具体工厂)
public class WindowsFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    
    public TextField createTextField() {
        return new WindowsTextField();
    }
}

public class MacFactory implements GUIFactory {
    public Button createButton() {
        return new MacButton();
    }
    
    public TextField createTextField() {
        return new MacTextField();
    }
}

// Usage (使用)
public class Application {
    private Button button;
    private TextField textField;
    
    public Application(GUIFactory factory) {
        button = factory.createButton();
        textField = factory.createTextField();
    }
    
    public void render() {
        button.render();
        textField.render();
    }
}

// Client code (客户端代码)
GUIFactory factory = new WindowsFactory(); // or MacFactory
Application app = new Application(factory);
app.render();
```

### 6.3 Key Structural Patterns

**1) Adapter Pattern (适配器模式)**

**Intent:** Convert the interface of a class into another interface clients expect.

**意图：** 将类的接口转换为客户端期望的另一个接口。

**Implementation:**

**实现：**

```java
// Target interface (目标接口)
public interface MediaPlayer {
    void play(String filename);
}

// Adaptee (被适配者)
public class AdvancedMediaPlayer {
    public void playVlc(String filename) {
        System.out.println("Playing VLC: " + filename);
    }
    
    public void playMp4(String filename) {
        System.out.println("Playing MP4: " + filename);
    }
}

// Adapter (适配器)
public class MediaAdapter implements MediaPlayer {
    private AdvancedMediaPlayer advancedPlayer;
    
    public MediaAdapter(String audioType) {
        advancedPlayer = new AdvancedMediaPlayer();
    }
    
    public void play(String filename) {
        if (filename.endsWith(".vlc")) {
            advancedPlayer.playVlc(filename);
        } else if (filename.endsWith(".mp4")) {
            advancedPlayer.playMp4(filename);
        }
    }
}

// Client (客户端)
public class AudioPlayer implements MediaPlayer {
    public void play(String filename) {
        if (filename.endsWith(".mp3")) {
            System.out.println("Playing MP3: " + filename);
        } else if (filename.endsWith(".vlc") || filename.endsWith(".mp4")) {
            MediaAdapter adapter = new MediaAdapter(filename);
            adapter.play(filename);
        }
    }
}
```

**2) Decorator Pattern (装饰模式)**

**Intent:** Attach additional responsibilities to an object dynamically.

**意图：** 动态地向对象添加额外的职责。

**Implementation:**

**实现：**

```java
// Component interface (组件接口)
public interface Coffee {
    String getDescription();
    double getCost();
}

// Concrete component (具体组件)
public class SimpleCoffee implements Coffee {
    public String getDescription() {
        return "Simple coffee";
    }
    
    public double getCost() {
        return 2.0;
    }
}

// Decorator base class (装饰器基类)
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

// Concrete decorators (具体装饰器)
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", milk";
    }
    
    public double getCost() {
        return coffee.getCost() + 0.5;
    }
}

public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", sugar";
    }
    
    public double getCost() {
        return coffee.getCost() + 0.2;
    }
}

// Usage (使用)
Coffee coffee = new SimpleCoffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);
System.out.println(coffee.getDescription() + " costs " + coffee.getCost());
// Output: Simple coffee, milk, sugar costs 2.7
```

### 6.4 Key Behavioral Patterns

**1) Strategy Pattern (策略模式)**

**Intent:** Define a family of algorithms, encapsulate each one, and make them interchangeable.

**意图：** 定义一系列算法，封装每一个，并使它们可互换。

**Implementation:**

**实现：**

```java
// Strategy interface (策略接口)
public interface SortingStrategy {
    void sort(int[] array);
}

// Concrete strategies (具体策略)
public class BubbleSortStrategy implements SortingStrategy {
    public void sort(int[] array) {
        // Bubble sort implementation
        System.out.println("Sorting using bubble sort");
    }
}

public class QuickSortStrategy implements SortingStrategy {
    public void sort(int[] array) {
        // Quick sort implementation
        System.out.println("Sorting using quick sort");
    }
}

// Context (上下文)
public class Sorter {
    private SortingStrategy strategy;
    
    public void setStrategy(SortingStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void sort(int[] array) {
        strategy.sort(array);
    }
}

// Usage (使用)
Sorter sorter = new Sorter();
sorter.setStrategy(new BubbleSortStrategy());
sorter.sort(new int[]{5, 3, 8, 1});

sorter.setStrategy(new QuickSortStrategy());
sorter.sort(new int[]{5, 3, 8, 1});
```

**2) Observer Pattern (观察者模式)**

**Intent:** Define a one-to-many dependency so that when one object changes state, all dependents are notified.

**意图：** 定义一对多依赖关系，当一个对象改变状态时，所有依赖者都会收到通知。

**Implementation:**

**实现：**

```java
// Observer interface (观察者接口)
public interface Observer {
    void update(String message);
}

// Subject (主题)
public class NewsAgency {
    private List<Observer> observers = new ArrayList<>();
    private String news;
    
    public void addObserver(Observer observer) {
        observers.add(observer);
    }
    
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }
    
    public void setNews(String news) {
        this.news = news;
        notifyObservers();
    }
    
    private void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(news);
        }
    }
}

// Concrete observers (具体观察者)
public class NewsChannel implements Observer {
    private String channelName;
    
    public NewsChannel(String name) {
        this.channelName = name;
    }
    
    public void update(String news) {
        System.out.println(channelName + " received news: " + news);
    }
}

// Usage (使用)
NewsAgency agency = new NewsAgency();
NewsChannel channel1 = new NewsChannel("CNN");
NewsChannel channel2 = new NewsChannel("BBC");

agency.addObserver(channel1);
agency.addObserver(channel2);

agency.setNews("Breaking news!");
// Output:
// CNN received news: Breaking news!
// BBC received news: Breaking news!
```

---

## 7. Exam Focus and Practice

### 7.1 High-Frequency Exam Points

**软考架构师考试高频考点：**

**1) OO基本概念 (30%)**
- 封装、继承、多态的原理和应用
- 对象和类的区别
- 抽象和接口的使用

**2) UML图 (25%)**
- 类图的绘制和识别（关系类型、多重性）
- 序列图的时序理解
- 状态图的状态转换
- 用例图的参与者和关系

**3) 设计原则 (20%)**
- SOLID原则的应用
- 高内聚低耦合
- 组合优于继承

**4) 设计模式 (15%)**
- 识别常见模式（单例、工厂、观察者、策略）
- 模式的适用场景
- 模式的UML表示

**5) OOA/OOD过程 (10%)**
- 从需求到设计的转换
- 领域建模
- 职责分配

### 7.2 Typical Question Types

**类型1：概念辨析**

**问题：** 以下哪项不是面向对象的特征？
A) 封装
B) 继承
C) 多态
D) 模块化

**答案：** D（模块化是结构化方法的特征）

**类型2：UML图识别**

**问题：** 在类图中，实心菱形表示什么关系？
A) 关联
B) 聚合
C) 组合
D) 泛化

**答案：** C

**类型3：设计原则应用**

**问题：** "一个类应该只有一个引起它变化的原因"，这是哪个原则？
A) 开闭原则
B) 单一职责原则
C) 里氏替换原则
D) 依赖倒置原则

**答案：** B

**类型4：设计模式识别**

**问题：** 以下哪个模式用于确保类只有一个实例？
A) 工厂模式
B) 单例模式
C) 代理模式
D) 外观模式

**答案：** B

### 7.3 Memory Tips

**记忆技巧：**

**SOLID原则记忆：**
- **S** - Single (单一) - 单一职责
- **O** - Open (开放) - 开闭原则
- **L** - Liskov (里氏) - 里氏替换
- **I** - Interface (接口) - 接口隔离
- **D** - Dependency (依赖) - 依赖倒置

**UML关系记忆（从弱到强）：**
依赖 < 关联 < 聚合 < 组合 < 继承

**创建型模式记忆（5个）：**
单工抽建原（单例、工厂方法、抽象工厂、建造者、原型）

**结构型模式记忆（7个）：**
适桥组装外享代（适配器、桥接、组合、装饰、外观、享元、代理）

**行为型模式记忆（11个）：**
责命解迭中备观状策模访（责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法、访问者）

### 7.4 Case Study Example

**案例：电子商务系统设计**

**需求：**
设计一个在线购物系统，支持用户浏览商品、添加到购物车、下单和支付。系统需要支持多种支付方式，并能够方便地添加新的支付方式。

**问题：**
1. 请画出系统的领域类图
2. 如何应用设计模式处理多种支付方式？
3. 如何应用SOLID原则？

**参考答案：**

**1) 领域类图：**
```
Customer (1) ----places---- (*) Order
                               |
                               | contains
                               |
                               (*) OrderLine
                                    |
                                    | refers to
                                    |
                                    (1) Product

Order (1) ----uses---- (1) Payment <<interface>>
                                |
                                | implements
                    ┌───────────┴───────────┐
                    |                       |
            CreditCardPayment      PayPalPayment
```

**2) 设计模式应用：**
- **策略模式**：将不同的支付方式定义为不同的策略
- **工厂模式**：使用工厂创建相应的支付对象

**3) SOLID原则应用：**
- **SRP**：Payment接口只负责支付处理
- **OCP**：通过添加新的Payment实现类扩展支付方式，无需修改Order类
- **LSP**：所有Payment实现可以互换使用
- **ISP**：Payment接口专注，不包含不必要的方法
- **DIP**：Order依赖Payment接口，而非具体实现

---

## 8. Summary and Key Takeaways

### 8.1 核心知识点总结

**面向对象三大特征：**
1. **封装**：隐藏实现细节，提供公共接口
2. **继承**：代码重用，建立层次关系
3. **多态**：同一接口，不同实现

**OOA/OOD关键活动：**
- **OOA**：识别对象和类、定义关系、建立领域模型
- **OOD**：细化类结构、应用设计原则、选择设计模式

**设计原则优先级：**
1. 单一职责原则（最基础）
2. 开闭原则（最重要）
3. 依赖倒置原则（最灵活）
4. 接口隔离原则
5. 里氏替换原则

**设计模式选择指南：**
- 创建对象 → 创建型模式
- 组织结构 → 结构型模式
- 对象协作 → 行为型模式

### 8.2 实践建议

**对于软件架构师：**

1. **深入理解原则**：原则比模式更重要
2. **适度设计**：避免过度设计和过度抽象
3. **迭代演化**：设计应随需求演化
4. **平衡取舍**：在灵活性和简单性间找平衡
5. **文档化**：使用UML记录设计决策

**对于考试准备：**

1. **掌握UML**：能识别和绘制常见图
2. **理解SOLID**：理解每个原则的含义和应用
3. **熟悉模式**：至少掌握10个常用模式
4. **练习案例**：多做设计题和案例分析
5. **关注细节**：注意关系类型、多重性等细节

---

**Document Version**: 1.0  
**Last Updated**: 2025  
**Target Audience**: Software Architecture Exam Candidates  
**文档版本**：1.0  
**最后更新**：2025年  
**目标受众**：软件架构师考试考生

**References (参考文献):**
- "Design Patterns: Elements of Reusable Object-Oriented Software" by Gang of Four
- "UML Distilled" by Martin Fowler
- "Clean Architecture" by Robert C. Martin
- "Domain-Driven Design" by Eric Evans
- "Applying UML and Patterns" by Craig Larman
