# Module Design - Comprehensive Technical Documentation
# 模块设计 - 完整技术文档

---

## Table of Contents | 目录

1. [Introduction](#1-introduction)
2. [Module Fundamentals](#2-module-fundamentals)
3. [Module Design Principles](#3-module-design-principles)
4. [Cohesion](#4-cohesion)
5. [Coupling](#5-coupling)
6. [Module Structure](#6-module-structure)
7. [Module Interface Design](#7-module-interface-design)
8. [Design Heuristics and Guidelines](#8-design-heuristics-and-guidelines)
9. [Module Complexity Metrics](#9-module-complexity-metrics)
10. [Design Patterns for Modularization](#10-design-patterns-for-modularization)
11. [Practical Examples and Refactoring](#11-practical-examples-and-refactoring)
12. [Best Practices and Anti-Patterns](#12-best-practices-and-anti-patterns)
13. [Examination Guide](#13-examination-guide)

---

## 1. Introduction

### 1.1 What is a Module?

**English:**
A **module** is a self-contained unit of software that:
- Performs a specific function or set of related functions
- Has a well-defined interface
- Encapsulates implementation details
- Can be developed, tested, and maintained independently
- Is a building block for larger systems

Modules can be:
- **Functions/Procedures** (in procedural programming)
- **Classes/Objects** (in object-oriented programming)
- **Packages/Libraries** (collection of related modules)
- **Components** (larger architectural units)
- **Services** (in microservices architecture)

**中文:**
**模块**是自包含的软件单元，它：
- 执行特定功能或一组相关功能
- 具有明确定义的接口
- 封装实现细节
- 可以独立开发、测试和维护
- 是更大系统的构建块

模块可以是：
- **函数/过程**（在过程式编程中）
- **类/对象**（在面向对象编程中）
- **包/库**（相关模块的集合）
- **组件**（更大的架构单元）
- **服务**（在微服务架构中）

### 1.2 Why Modularization?

**English:**

**Benefits of Modular Design**:

1. **Complexity Management**
   - Divide large systems into manageable pieces
   - Each module handles a limited scope
   - Easier to understand and reason about

2. **Maintainability**
   - Changes localized to specific modules
   - Reduced ripple effects
   - Easier bug fixing and enhancement

3. **Reusability**
   - Modules can be reused across projects
   - Build libraries of common functionality
   - Reduce development time

4. **Parallel Development**
   - Different teams work on different modules
   - Faster development with proper interfaces
   - Reduced integration conflicts

5. **Testability**
   - Test modules in isolation (unit testing)
   - Mock dependencies easily
   - Better test coverage

6. **Replaceability**
   - Swap modules with better implementations
   - Upgrade without full system rewrite
   - Support multiple implementations

**中文:**

**模块化设计的好处**：

1. **复杂性管理**
   - 将大型系统划分为可管理的部分
   - 每个模块处理有限范围
   - 更易于理解和推理

2. **可维护性**
   - 变更局限于特定模块
   - 减少涟漪效应
   - 更容易修复错误和增强

3. **可重用性**
   - 模块可以跨项目重用
   - 构建通用功能库
   - 减少开发时间

4. **并行开发**
   - 不同团队处理不同模块
   - 通过适当接口加快开发
   - 减少集成冲突

5. **可测试性**
   - 隔离测试模块（单元测试）
   - 轻松模拟依赖
   - 更好的测试覆盖率

6. **可替换性**
   - 用更好的实现交换模块
   - 无需完全重写系统即可升级
   - 支持多个实现

---

## 2. Module Fundamentals

### 2.1 Module Characteristics

**English:**

**Essential Module Characteristics**:

1. **Encapsulation**
   - Hide internal implementation
   - Expose only necessary interfaces
   - Protect module internals from external access

2. **Well-Defined Interface**
   - Clear input/output specifications
   - Documented preconditions and postconditions
   - Explicit dependencies

3. **Single Purpose**
   - Each module should have one clear responsibility
   - Focused functionality
   - Avoid "kitchen sink" modules

4. **Independence**
   - Minimal dependencies on other modules
   - Self-sufficient where possible
   - Loose coupling to environment

5. **Completeness**
   - Provide all functionality promised by interface
   - Handle all specified cases
   - Include error handling

**中文:**

**基本模块特征**：

1. **封装**
   - 隐藏内部实现
   - 仅暴露必要接口
   - 保护模块内部免受外部访问

2. **明确定义的接口**
   - 清晰的输入/输出规范
   - 文档化的前置和后置条件
   - 显式依赖

3. **单一目的**
   - 每个模块应有一个明确职责
   - 聚焦功能
   - 避免"大杂烩"模块

4. **独立性**
   - 对其他模块的依赖最小化
   - 尽可能自给自足
   - 与环境松散耦合

5. **完整性**
   - 提供接口承诺的所有功能
   - 处理所有指定情况
   - 包含错误处理

### 2.2 Module Anatomy

**English:**

```
┌─────────────────────────────────────┐
│         MODULE NAME                 │
├─────────────────────────────────────┤
│ PUBLIC INTERFACE                    │
│  - Exported functions/methods       │
│  - Public data types                │
│  - Constants                        │
├─────────────────────────────────────┤
│ PRIVATE IMPLEMENTATION              │
│  - Internal functions               │
│  - Private data structures          │
│  - Helper routines                  │
│  - Implementation details           │
└─────────────────────────────────────┘
```

**Example in Different Languages**:

```python
# Python Module
# file: user_manager.py

# PUBLIC INTERFACE
def create_user(username, email):
    """Create a new user account."""
    if _validate_email(email):
        return _save_user(username, email)
    raise ValueError("Invalid email")

def delete_user(user_id):
    """Delete a user account."""
    return _remove_user(user_id)

# PRIVATE IMPLEMENTATION
def _validate_email(email):
    # Email validation logic
    return "@" in email

def _save_user(username, email):
    # Database save logic
    pass

def _remove_user(user_id):
    # Database delete logic
    pass
```

```java
// Java Module (Class)
public class UserManager {
    // PUBLIC INTERFACE
    public User createUser(String username, String email) {
        if (validateEmail(email)) {
            return saveUser(username, email);
        }
        throw new IllegalArgumentException("Invalid email");
    }
    
    public boolean deleteUser(int userId) {
        return removeUser(userId);
    }
    
    // PRIVATE IMPLEMENTATION
    private boolean validateEmail(String email) {
        return email.contains("@");
    }
    
    private User saveUser(String username, String email) {
        // Database save logic
        return null;
    }
    
    private boolean removeUser(int userId) {
        // Database delete logic
        return false;
    }
}
```

**中文:**

```
┌─────────────────────────────────────┐
│         模块名称                    │
├─────────────────────────────────────┤
│ 公共接口                            │
│  - 导出的函数/方法                  │
│  - 公共数据类型                     │
│  - 常量                             │
├─────────────────────────────────────┤
│ 私有实现                            │
│  - 内部函数                         │
│  - 私有数据结构                     │
│  - 辅助例程                         │
│  - 实现细节                         │
└─────────────────────────────────────┘
```

---

## 3. Module Design Principles

### 3.1 Information Hiding (David Parnas, 1972)

**English:**

**Principle**: Each module should hide a design decision that is likely to change.

**Key Concepts**:
- **Secrets**: Implementation details that may change
- **Public Interface**: Stable contract that doesn't change
- **Changeability**: Changes confined to module internals

**Benefits**:
- Changes don't ripple through system
- Parallel development possible
- Testing easier (mock hidden parts)

**Example**:

**Bad Design** (No Information Hiding):
```python
# Direct database access everywhere
def process_order(order_id):
    connection = mysql.connect(host='localhost', user='root', ...)
    cursor = connection.cursor()
    cursor.execute(f"SELECT * FROM orders WHERE id={order_id}")
    order = cursor.fetchone()
    # Process order...
    connection.close()
```

**Good Design** (Information Hiding):
```python
# database_module.py - Hides DB implementation
class Database:
    def __init__(self):
        self._connection = None  # Hidden
    
    def get_order(self, order_id):
        # Implementation hidden
        return self._execute_query(f"SELECT * FROM orders WHERE id={order_id}")
    
    def _execute_query(self, query):  # Private
        # Can change from MySQL to PostgreSQL without affecting users
        pass

# order_processor.py - Uses abstraction
def process_order(order_id):
    db = Database()
    order = db.get_order(order_id)  # Don't care about DB type
    # Process order...
```

**中文:**

**原则**：每个模块应该隐藏可能变化的设计决策。

**关键概念**：
- **秘密**：可能变化的实现细节
- **公共接口**：不变的稳定契约
- **可变性**：变更限制在模块内部

**好处**：
- 变更不会波及整个系统
- 可能并行开发
- 更易测试（模拟隐藏部分）

### 3.2 Separation of Concerns

**English:**

**Principle**: Different concerns should be handled by different modules.

**Examples of Concerns**:
- **Business Logic** vs. **Data Access** vs. **Presentation**
- **Logging** vs. **Core Functionality**
- **Security** vs. **Business Operations**

**Layered Architecture Example**:
```
┌──────────────────────┐
│ Presentation Layer   │  (UI concerns)
├──────────────────────┤
│ Business Logic Layer │  (Domain concerns)
├──────────────────────┤
│ Data Access Layer    │  (Persistence concerns)
└──────────────────────┘
```

**Code Example**:
```python
# BAD: Mixed concerns
def register_user(username, password):
    # Validation (business logic)
    if len(password) < 8:
        print("Error: Password too short")  # UI concern
        return False
    
    # Database access (data concern)
    conn = db.connect()
    conn.execute("INSERT INTO users...")
    
    # Email (infrastructure concern)
    send_email(username, "Welcome!")
    
    return True

# GOOD: Separated concerns
# business_logic.py
def validate_user_data(username, password):
    if len(password) < 8:
        raise ValidationError("Password too short")

# data_access.py
def save_user(username, password_hash):
    conn = db.connect()
    conn.execute("INSERT INTO users...")

# notification.py
def send_welcome_email(username):
    send_email(username, "Welcome!")

# orchestration.py
def register_user(username, password):
    validate_user_data(username, password)
    password_hash = hash_password(password)
    save_user(username, password_hash)
    send_welcome_email(username)
```

**中文:**

**原则**：不同的关注点应由不同的模块处理。

**关注点示例**：
- **业务逻辑** vs. **数据访问** vs. **表示**
- **日志记录** vs. **核心功能**
- **安全** vs. **业务操作**

### 3.3 Single Responsibility Principle (SRP)

**English:**

**Principle**: A module should have one, and only one, reason to change.

**From SOLID Principles** (Robert C. Martin):
- Each module should have a single responsibility
- A responsibility is a reason to change
- Multiple responsibilities = multiple reasons to change = fragile design

**Example**:

**Bad** (Multiple Responsibilities):
```java
public class Employee {
    // Responsibility 1: Employee data management
    public void setName(String name) { ... }
    public String getName() { ... }
    
    // Responsibility 2: Salary calculation (business logic)
    public double calculateSalary() { ... }
    
    // Responsibility 3: Database persistence
    public void save() {
        // SQL queries
    }
    
    // Responsibility 4: Report generation
    public String generateReport() {
        return "Employee Report...";
    }
}
```

**Good** (Single Responsibility):
```java
// Data model - only represents employee data
public class Employee {
    private String name;
    private double salary;
    
    public void setName(String name) { this.name = name; }
    public String getName() { return name; }
}

// Business logic - salary calculation
public class SalaryCalculator {
    public double calculate(Employee emp) { ... }
}

// Persistence - database operations
public class EmployeeRepository {
    public void save(Employee emp) { ... }
    public Employee findById(int id) { ... }
}

// Reporting - report generation
public class EmployeeReportGenerator {
    public String generate(Employee emp) { ... }
}
```

**中文:**

**原则**：一个模块应该有且仅有一个改变的理由。

**来自SOLID原则**（Robert C. Martin）：
- 每个模块应该有单一职责
- 职责是改变的理由
- 多重职责 = 多重改变理由 = 脆弱设计

---

## 4. Cohesion

### 4.1 Definition

**English:**

**Cohesion** measures how closely the elements within a module are related to each other. It indicates the degree to which the module focuses on a single task.

**High Cohesion** (Good):
- Module elements strongly related
- Single, well-defined purpose
- Easy to understand and maintain

**Low Cohesion** (Bad):
- Module elements unrelated
- Multiple unrelated purposes
- Difficult to understand and reuse

**中文:**

**内聚**衡量模块内元素之间的相关性。它表示模块专注于单一任务的程度。

**高内聚**（好）：
- 模块元素强相关
- 单一、明确定义的目的
- 易于理解和维护

**低内聚**（坏）：
- 模块元素无关
- 多个不相关目的
- 难以理解和重用

### 4.2 Seven Levels of Cohesion

**English:**

**From Worst to Best**:

| Level | Name                | Description                                               | Example                                         |
| ----- | ------------------- | --------------------------------------------------------- | ----------------------------------------------- |
| **1** | **Coincidental**    | Elements have no meaningful relationship                  | Utility module with random functions            |
| **2** | **Logical**         | Elements perform similar operations but on different data | Input module handling keyboard, mouse, file     |
| **3** | **Temporal**        | Elements executed at the same time                        | Initialization module                           |
| **4** | **Procedural**      | Elements part of a sequence                               | Read→Process→Write in order                     |
| **5** | **Communicational** | Elements operate on same data                             | Module that reads and validates customer record |
| **6** | **Sequential**      | Output of one element is input to next                    | Read→Parse→Validate                             |
| **7** | **Functional**      | All elements contribute to a single, well-defined task    | Calculate invoice total                         |

**中文:**

**从最差到最好**：

| 级别  | 名称         | 描述                           | 示例                           |
| ----- | ------------ | ------------------------------ | ------------------------------ |
| **1** | **偶然内聚** | 元素没有有意义的关系           | 包含随机函数的实用模块         |
| **2** | **逻辑内聚** | 元素执行类似操作但针对不同数据 | 处理键盘、鼠标、文件的输入模块 |
| **3** | **时间内聚** | 元素在同一时间执行             | 初始化模块                     |
| **4** | **过程内聚** | 元素是序列的一部分             | 按顺序读取→处理→写入           |
| **5** | **通信内聚** | 元素操作相同数据               | 读取并验证客户记录的模块       |
| **6** | **顺序内聚** | 一个元素的输出是下一个的输入   | 读取→解析→验证                 |
| **7** | **功能内聚** | 所有元素共同完成单一明确任务   | 计算发票总额                   |

### 4.3 Detailed Examples

**English:**

**1. Coincidental Cohesion** (Worst):
```python
# Bad: Unrelated functions grouped together
class Utilities:
    def calculate_tax(self, amount):
        return amount * 0.1
    
    def send_email(self, address, message):
        # Email sending code
        pass
    
    def sort_array(self, arr):
        return sorted(arr)
    
    def format_date(self, date):
        return date.strftime("%Y-%m-%d")

# Why bad: No logical connection between functions
# Hard to name, understand, or maintain
```

**2. Logical Cohesion**:
```python
# Medium-Bad: Similar operations on different types
class InputHandler:
    def handle_input(self, input_type):
        if input_type == 'keyboard':
            return self.read_keyboard()
        elif input_type == 'mouse':
            return self.read_mouse()
        elif input_type == 'file':
            return self.read_file()
    
    def read_keyboard(self): ...
    def read_mouse(self): ...
    def read_file(self): ...

# Better: Separate modules for each input type
```

**3. Temporal Cohesion**:
```python
# Medium: Elements executed at same time
class SystemInitializer:
    def initialize(self):
        self.init_database()
        self.init_logger()
        self.init_cache()
        self.load_config()

# OK for startup, but functions are unrelated otherwise
```

**4. Procedural Cohesion**:
```python
# Medium-Good: Steps in a procedure
class DataProcessor:
    def process_file(self, filename):
        data = self.read_file(filename)
        cleaned = self.clean_data(data)
        self.write_file(cleaned, filename + ".out")
    
    def read_file(self, filename): ...
    def clean_data(self, data): ...
    def write_file(self, data, filename): ...

# Related by procedure, but elements can work independently
```

**5. Communicational Cohesion**:
```python
# Good: Operate on same data structure
class CustomerRecordProcessor:
    def process_customer(self, customer_id):
        record = self.fetch_record(customer_id)
        self.validate_record(record)
        self.update_record(record)
    
    def fetch_record(self, customer_id): ...
    def validate_record(self, record): ...
    def update_record(self, record): ...

# All functions work with customer record
```

**6. Sequential Cohesion**:
```python
# Better: Output → Input chain
class DataValidator:
    def validate_and_parse(self, raw_data):
        cleaned = self.clean(raw_data)      # Step 1
        parsed = self.parse(cleaned)        # Step 2 uses Step 1 output
        validated = self.validate(parsed)   # Step 3 uses Step 2 output
        return validated
    
    def clean(self, data): ...
    def parse(self, data): ...
    def validate(self, data): ...
```

**7. Functional Cohesion** (Best):
```python
# Best: Single, well-defined function
class InvoiceCalculator:
    def calculate_total(self, items, tax_rate, discount):
        """Calculate invoice total - one clear purpose."""
        subtotal = self._sum_items(items)
        tax = self._calculate_tax(subtotal, tax_rate)
        final = self._apply_discount(subtotal + tax, discount)
        return final
    
    # Helper methods support main function
    def _sum_items(self, items):
        return sum(item.price * item.quantity for item in items)
    
    def _calculate_tax(self, amount, rate):
        return amount * rate
    
    def _apply_discount(self, amount, discount):
        return amount * (1 - discount)

# All methods contribute to ONE task: calculating invoice total
```

**中文:**

**1. 偶然内聚**（最差）：
```python
# 坏：不相关的函数组合在一起
class Utilities:
    def calculate_tax(self, amount):
        return amount * 0.1
    
    def send_email(self, address, message):
        # 发送邮件代码
        pass
    
    def sort_array(self, arr):
        return sorted(arr)
    
    def format_date(self, date):
        return date.strftime("%Y-%m-%d")

# 为什么坏：函数之间没有逻辑连接
# 难以命名、理解或维护
```

**7. 功能内聚**（最好）：
```python
# 最好：单一、明确定义的功能
class InvoiceCalculator:
    def calculate_total(self, items, tax_rate, discount):
        """计算发票总额 - 一个明确目的。"""
        subtotal = self._sum_items(items)
        tax = self._calculate_tax(subtotal, tax_rate)
        final = self._apply_discount(subtotal + tax, discount)
        return final
    
    # 辅助方法支持主要功能
    def _sum_items(self, items):
        return sum(item.price * item.quantity for item in items)
    
    def _calculate_tax(self, amount, rate):
        return amount * rate
    
    def _apply_discount(self, amount, discount):
        return amount * (1 - discount)

# 所有方法都为一个任务做贡献：计算发票总额
```

### 4.4 Measuring Cohesion

**English:**

While cohesion is primarily qualitative, some metrics exist:

**LCOM (Lack of Cohesion of Methods)**:
- Measures how many methods access the same instance variables
- Lower LCOM = Higher cohesion

**Formula** (simplified):
```
LCOM = (Number of method pairs with no shared attributes) - 
       (Number of method pairs with shared attributes)

If LCOM < 0, set to 0
Higher LCOM = Lower cohesion (bad)
```

**Example**:
```java
public class Customer {
    private String name;
    private String address;
    private double balance;
    
    // Method 1: uses name, address
    public void updateProfile(String name, String address) {
        this.name = name;
        this.address = address;
    }
    
    // Method 2: uses balance
    public void deposit(double amount) {
        this.balance += amount;
    }
    
    // Method 3: uses balance
    public void withdraw(double amount) {
        this.balance -= amount;
    }
}

// LCOM analysis:
// Method pairs:
// (updateProfile, deposit) - no shared attributes
// (updateProfile, withdraw) - no shared attributes  
// (deposit, withdraw) - shared attribute: balance
// LCOM = 2 - 1 = 1 (medium cohesion)

// Better: Split into two classes
class CustomerProfile {  // High cohesion
    private String name;
    private String address;
    public void update(String name, String address) { ... }
}

class Account {  // High cohesion
    private double balance;
    public void deposit(double amount) { ... }
    public void withdraw(double amount) { ... }
}
```

**中文:**

虽然内聚主要是定性的，但存在一些度量：

**LCOM（方法缺乏内聚性）**：
- 衡量有多少方法访问相同的实例变量
- 较低的LCOM = 较高的内聚

---

## 5. Coupling

### 5.1 Definition

**English:**

**Coupling** measures the degree of interdependence between modules. It indicates how much one module relies on another.

**Low Coupling** (Good):
- Modules are largely independent
- Changes in one module don't affect others
- Easy to understand, test, and modify

**High Coupling** (Bad):
- Modules heavily dependent on each other
- Changes ripple through system
- Difficult to test and modify

**Goal**: Minimize coupling while maintaining necessary module interactions.

**中文:**

**耦合**衡量模块之间的相互依赖程度。它表示一个模块对另一个模块的依赖程度。

**低耦合**（好）：
- 模块基本独立
- 一个模块的变更不影响其他模块
- 易于理解、测试和修改

**高耦合**（坏）：
- 模块高度相互依赖
- 变更波及整个系统
- 难以测试和修改

**目标**：在维持必要模块交互的同时最小化耦合。

### 5.2 Six Types of Coupling

**English:**

**From Worst to Best**:

| Level | Type         | Description                                 | Example                                    |
| ----- | ------------ | ------------------------------------------- | ------------------------------------------ |
| **1** | **Content**  | One module modifies another's internal data | Direct access to module internals          |
| **2** | **Common**   | Modules share global data                   | Global variables                           |
| **3** | **External** | Modules depend on external format/protocol  | File format, API contract                  |
| **4** | **Control**  | One module controls another's flow          | Passing flags                              |
| **5** | **Stamp**    | Modules share composite data structure      | Passing whole object when only part needed |
| **6** | **Data**     | Modules share only simple data              | Passing parameters                         |

**中文:**

**从最差到最好**：

| 级别  | 类型         | 描述                             | 示例                     |
| ----- | ------------ | -------------------------------- | ------------------------ |
| **1** | **内容耦合** | 一个模块修改另一个模块的内部数据 | 直接访问模块内部         |
| **2** | **公共耦合** | 模块共享全局数据                 | 全局变量                 |
| **3** | **外部耦合** | 模块依赖外部格式/协议            | 文件格式、API契约        |
| **4** | **控制耦合** | 一个模块控制另一个的流程         | 传递标志                 |
| **5** | **标记耦合** | 模块共享复合数据结构             | 传递整个对象但只需要部分 |
| **6** | **数据耦合** | 模块仅共享简单数据               | 传递参数                 |

### 5.3 Detailed Examples

**English:**

**1. Content Coupling** (Worst):
```python
# VERY BAD: Module A directly accesses Module B's internals
class ModuleA:
    def do_something(self):
        b = ModuleB()
        # Directly modifying B's internal state - TERRIBLE!
        b._internal_counter = 10  # Accessing private member
        b._secret_data[0] = "hack"  # Modifying private data

# This breaks encapsulation completely
# If ModuleB changes internals, ModuleA breaks
```

**2. Common Coupling** (Very Bad):
```python
# BAD: Global variable shared by multiple modules
# global_data.py
current_user = None  # Global variable
transaction_id = 0

# module_a.py
import global_data
def login(user):
    global_data.current_user = user  # Modifying global

# module_b.py  
import global_data
def process_order():
    if global_data.current_user:  # Depends on global
        # Process...
        global_data.transaction_id += 1

# Problems:
# - Hard to track who modifies what
# - Difficult to test in isolation
# - Race conditions in concurrent code
# - Unclear dependencies
```

**3. External Coupling**:
```python
# MEDIUM: Dependence on external format
class ReportGenerator:
    def save_report(self, data, filename):
        # Tightly coupled to CSV format
        with open(filename, 'w') as f:
            f.write("Name,Age,Salary\n")
            for row in data:
                f.write(f"{row['name']},{row['age']},{row['salary']}\n")

# If CSV format changes, module must change
# Better: Use abstraction for format
```

**4. Control Coupling**:
```python
# MEDIUM-BAD: Passing control flags
def process_data(data, operation_type):
    if operation_type == 'validate':
        # Validate data
        pass
    elif operation_type == 'transform':
        # Transform data
        pass
    elif operation_type == 'store':
        # Store data
        pass

# Caller controls internal logic of callee
# Better: Separate functions or strategy pattern

# BETTER:
def validate_data(data): ...
def transform_data(data): ...
def store_data(data): ...
```

**5. Stamp Coupling**:
```python
# MEDIUM: Passing whole object when part needed
class Customer:
    def __init__(self, id, name, address, phone, email, history):
        self.id = id
        self.name = name
        self.address = address
        self.phone = phone
        self.email = email
        self.purchase_history = history

# BAD: Passing whole customer object
def send_promotional_email(customer):
    # Only needs email, but gets everything
    email_service.send(customer.email, "Promotion!")

# BETTER: Pass only what's needed
def send_promotional_email(email_address):
    email_service.send(email_address, "Promotion!")

# Benefits:
# - Clearer dependencies
# - Easier to test
# - More reusable
```

**6. Data Coupling** (Best):
```python
# GOOD: Simple data passed as parameters
def calculate_discount(price, discount_rate):
    """
    Calculate discounted price.
    
    Args:
        price: Original price (float)
        discount_rate: Discount as decimal (0.1 = 10%)
    
    Returns:
        Discounted price (float)
    """
    return price * (1 - discount_rate)

# Minimal coupling:
# - Only needs two simple values
# - No shared state
# - No control flow manipulation
# - Easy to understand and test
# - Completely independent

# Usage:
final_price = calculate_discount(100.0, 0.15)
```

**中文:**

**1. 内容耦合**（最差）：
```python
# 非常坏：模块A直接访问模块B的内部
class ModuleA:
    def do_something(self):
        b = ModuleB()
        # 直接修改B的内部状态 - 可怕！
        b._internal_counter = 10  # 访问私有成员
        b._secret_data[0] = "hack"  # 修改私有数据

# 这完全破坏了封装
# 如果ModuleB更改内部，ModuleA就会崩溃
```

**6. 数据耦合**（最好）：
```python
# 好：作为参数传递的简单数据
def calculate_discount(price, discount_rate):
    """
    计算折扣价格。
    
    参数:
        price: 原价 (float)
        discount_rate: 折扣为小数 (0.1 = 10%)
    
    返回:
        折扣价格 (float)
    """
    return price * (1 - discount_rate)

# 最小耦合:
# - 仅需要两个简单值
# - 没有共享状态
# - 没有控制流操作
# - 易于理解和测试
# - 完全独立

# 使用：
final_price = calculate_discount(100.0, 0.15)
```

### 5.4 Reducing Coupling

**English:**

**Strategies to Reduce Coupling**:

1. **Use Interfaces/Abstract Classes**
```python
# Bad: Direct dependency
class OrderProcessor:
    def __init__(self):
        self.db = MySQLDatabase()  # Tightly coupled to MySQL
    
    def process(self, order):
        self.db.save(order)

# Good: Dependency on abstraction
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def save(self, data):
        pass

class MySQLDatabase(Database):
    def save(self, data):
        # MySQL implementation
        pass

class OrderProcessor:
    def __init__(self, database: Database):  # Depends on interface
        self.db = database
    
    def process(self, order):
        self.db.save(order)

# Can easily swap implementations
processor = OrderProcessor(MySQLDatabase())
# or
processor = OrderProcessor(PostgreSQLDatabase())
```

2. **Dependency Injection**
```python
# Instead of creating dependencies internally
class bad_email_service:
    def __init__(self):
        self.smtp = SMTPClient()  # Created internally - tight coupling
    
    def send(self, email):
        self.smtp.send(email)

# Inject dependencies from outside
class EmailService:
    def __init__(self, smtp_client):  # Injected - loose coupling
        self.smtp = smtp_client
    
    def send(self, email):
        self.smtp.send(email)

# Usage
smtp = SMTPClient()
service = EmailService(smtp)  # Dependency injected
```

3. **Use Events/Observers**
```python
# Instead of direct calls (tight coupling)
class Order:
    def place(self):
        # ... order logic
        email_service.send_confirmation()  # Direct coupling
        inventory_system.update_stock()    # Direct coupling
        analytics.track_order()            # Direct coupling

# Use event system (loose coupling)
class Order:
    def __init__(self):
        self.observers = []
    
    def attach(self, observer):
        self.observers.append(observer)
    
    def place(self):
        # ... order logic
        self.notify_all('order_placed', self)
    
    def notify_all(self, event, data):
        for observer in self.observers:
            observer.update(event, data)

# Observers register themselves
order = Order()
order.attach(EmailNotifier())
order.attach(InventoryManager())
order.attach(AnalyticsTracker())
```

**中文:**

**减少耦合的策略**：

1. **使用接口/抽象类**
2. **依赖注入**
3. **使用事件/观察者**

---

## 6. Module Structure

### 6.1 Fan-In and Fan-Out

**English:**

**Fan-In**: Number of modules that call a given module
- **High fan-in** (Good): Module is widely reused
- Indicates useful, general-purpose functionality

**Fan-Out**: Number of modules a given module calls
- **High fan-out** (Often Bad): Module depends on many others
- Complex module with many dependencies
- **Low fan-out** (Good): Module is more independent

**Ideal Structure**:
```
        High Fan-In
            ↓
    ┌───────────────┐
    │  Utility      │ ← Called by many (reusable)
    │  Module       │
    └───────────────┘
            ↑
         Low Fan-Out
```

**Example**:
```python
# High fan-in utility (good - widely reused)
def validate_email(email):
    return "@" in email and "." in email

# Used by:
# - UserRegistration module
# - ProfileUpdate module  
# - ContactForm module
# - NewsletterSubscription module
# Fan-in = 4 (good - reusable utility)

# High fan-out module (potential problem)
class ComplexOrderProcessor:
    def __init__(self):
        self.db = Database()
        self.email = EmailService()
        self.payment = PaymentGateway()
        self.inventory = InventorySystem()
        self.shipping = ShippingService()
        self.analytics = AnalyticsTracker()
        self.logger = Logger()
    # Fan-out = 7 (high - many dependencies)
    # Consider: Does this module do too much?
```

**中文:**

**扇入**：调用给定模块的模块数
- **高扇入**（好）：模块被广泛重用
- 表示有用的通用功能

**扇出**：给定模块调用的模块数
- **高扇出**（通常坏）：模块依赖许多其他模块
- 具有许多依赖的复杂模块
- **低扇出**（好）：模块更独立

### 6.2 Hierarchical Structure

**English:**

**Well-Designed Module Hierarchy**:
```
Level 0: Main/Controller
         │
Level 1: ├── Business Logic Layer
         ├── Data Access Layer
         └── Presentation Layer
         │
Level 2: ├── Specific Business Modules
         ├── Database Modules
         └── UI Components
         │
Level 3: └── Utility Functions
```

**Principles**:
- **Top levels**: High-level, abstract, policy
- **Bottom levels**: Low-level, concrete, mechanisms
- **Dependencies flow downward**: Higher levels depend on lower, not vice versa

**Example**:
```python
# Level 3: Utilities (lowest, no dependencies)
def format_currency(amount):
    return f"${amount:.2f}"

# Level 2: Data Access
class ProductRepository:
    def get_product(self, id):
        # Database access
        pass

# Level 1: Business Logic
class PricingService:
    def __init__(self, product_repo):
        self.repo = product_repo
    
    def calculate_price(self, product_id, quantity):
        product = self.repo.get_product(product_id)
        return product.price * quantity

# Level 0: Controller
class OrderController:
    def __init__(self, pricing_service):
        self.pricing = pricing_service
    
    def create_order(self, product_id, quantity):
        price = self.pricing.calculate_price(product_id, quantity)
        formatted = format_currency(price)
        return {'total': formatted}
```

**中文:**

**设计良好的模块层次结构**：
```
第0层: 主控/控制器
       │
第1层: ├── 业务逻辑层
      ├── 数据访问层
      └── 表示层
       │
第2层: ├── 特定业务模块
      ├── 数据库模块
      └── UI组件
       │
第3层: └── 实用函数
```

**原则**：
- **顶层**：高级、抽象、策略
- **底层**：低级、具体、机制
- **依赖向下流动**：较高层依赖较低层，反之不然

---

## 7. Module Interface Design

### 7.1 Interface Specifications

**English:**

A good module interface should specify:

1. **Function Signatures**
   - Parameter types and order
   - Return type
   - Exceptions/errors

2. **Preconditions**
   - What must be true before calling
   - Input constraints

3. **Postconditions**
   - What will be true after calling
   - Guaranteed results

4. **Invariants**
   - What remains true throughout

**Example**:
```python
class BankAccount:
    """
    Bank account module.
    
    Invariant: balance >= 0 (never negative)
    """
    
    def __init__(self, initial_balance=0):
        """
        Initialize account.
        
        Precondition: initial_balance >= 0
        Postcondition: self.balance == initial_balance
        """
        if initial_balance < 0:
            raise ValueError("Initial balance cannot be negative")
        self.balance = initial_balance
    
    def deposit(self, amount):
        """
        Deposit money into account.
        
        Parameters:
            amount (float): Amount to deposit
        
        Preconditions:
            - amount > 0
        
        Postconditions:
            - balance increased by amount
            - balance >= 0 (invariant maintained)
        
        Raises:
            ValueError: If amount <= 0
        """
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        self.balance += amount
    
    def withdraw(self, amount):
        """
        Withdraw money from account.
        
        Parameters:
            amount (float): Amount to withdraw
        
        Preconditions:
            - amount > 0
            - amount <= balance (sufficient funds)
        
        Postconditions:
            - balance decreased by amount
            - balance >= 0 (invariant maintained)
        
        Raises:
            ValueError: If amount <= 0
            InsufficientFundsError: If amount > balance
        """
        if amount <= 0:
            raise ValueError("Withdrawal amount must be positive")
        if amount > self.balance:
            raise InsufficientFundsError(f"Cannot withdraw {amount}, balance is {self.balance}")
        self.balance -= amount
```

**中文:**

良好的模块接口应指定：

1. **函数签名**
   - 参数类型和顺序
   - 返回类型
   - 异常/错误

2. **前置条件**
   - 调用前必须为真的条件
   - 输入约束

3. **后置条件**
   - 调用后将为真的条件
   - 保证的结果

4. **不变式**
   - 始终保持为真的条件

### 7.2 Design by Contract

**English:**

**Contract**: Agreement between module and its clients
- **Client obligations**: Ensure preconditions
- **Module obligations**: Ensure postconditions

**Example**:
```python
def divide(numerator, denominator):
    """
    Divide two numbers.
    
    Contract:
        Precondition: denominator != 0
        Postcondition: result * denominator == numerator (approximately)
    """
    assert denominator != 0, "Contract violated: denominator must not be zero"
    result = numerator / denominator
    assert abs(result * denominator - numerator) < 0.0001, "Contract violated: postcondition"
    return result
```

**中文:**

**契约**：模块与其客户端之间的协议
- **客户端义务**：确保前置条件
- **模块义务**：确保后置条件

---

## 8. Design Heuristics and Guidelines

### 8.1 Module Size

**English:**

**Lines of Code (LOC)**:
- **Functions**: 20-50 lines (ideally)
- **Classes**: 200-500 lines (ideally)
- **If larger**: Consider splitting

**Cyclomatic Complexity**:
- **Simple**: 1-10 (good)
- **Moderate**: 11-20 (review)
- **Complex**: 21+ (refactor)

**Number of Methods in Class**:
- **Ideal**: 5-15 methods
- **Warning**: 20+ methods (too many responsibilities?)

**Parameters**:
- **Ideal**: 0-3 parameters
- **Acceptable**: 4-5 parameters
- **Bad**: 6+ parameters (consider parameter object)

**中文:**

**代码行数（LOC）**：
- **函数**：20-50行（理想）
- **类**：200-500行（理想）
- **如果更大**：考虑拆分

**圈复杂度**：
- **简单**：1-10（好）
- **中等**：11-20（审查）
- **复杂**：21+（重构）

**类中的方法数**：
- **理想**：5-15个方法
- **警告**：20+方法（职责太多？）

**参数**：
- **理想**：0-3个参数
- **可接受**：4-5个参数
- **坏**：6+个参数（考虑参数对象）

### 8.2 Naming Conventions

**English:**

**Modules/Classes**: Nouns or noun phrases
- `UserManager`, `ProductCatalog`, `PaymentProcessor`

**Functions/Methods**: Verbs or verb phrases
- `calculate_total()`, `send_email()`, `validate_input()`

**Predicates**: Question format or `is_/has_` prefix
- `is_valid()`, `has_permission()`, `can_process()`

**Constants**: UPPER_CASE
- `MAX_RETRIES`, `DEFAULT_TIMEOUT`

**Private members**: Underscore prefix
- `_internal_helper()`, `_secret_key`

**中文:**

**模块/类**：名词或名词短语
- `UserManager`、`ProductCatalog`、`PaymentProcessor`

**函数/方法**：动词或动词短语
- `calculate_total()`、`send_email()`、`validate_input()`

**谓词**：问题格式或`is_/has_`前缀
- `is_valid()`、`has_permission()`、`can_process()`

**常量**：大写
- `MAX_RETRIES`、`DEFAULT_TIMEOUT`

**私有成员**：下划线前缀
- `_internal_helper()`、`_secret_key`

---

## 9. Module Complexity Metrics

### 9.1 Cyclomatic Complexity

**English:**

**Definition**: Number of linearly independent paths through code

**Formula**:
```
V(G) = E - N + 2P

Where:
E = number of edges in control flow graph
N = number of nodes
P = number of connected components (usually 1)

Simplified: V(G) = Number of decision points + 1
```

**Decision points**: if, while, for, case, &&, ||, ?:

**Example**:
```python
def process_order(order):  # Start: V = 1
    if order.is_valid():    # +1 decision: V = 2
        if order.amount > 100:  # +1 decision: V = 3
            discount = 0.1
        else:
            discount = 0
        
        total = order.amount * (1 - discount)
        
        if order.customer.is_premium():  # +1 decision: V = 4
            shipping = 0
        else:
            shipping = 10
        
        return total + shipping
    else:
        return None

# Cyclomatic Complexity = 4
# Paths:
# 1. valid=F
# 2. valid=T, amount≤100, not premium
# 3. valid=T, amount≤100, premium
# 4. valid=T, amount>100, not premium
# 5. valid=T, amount>100, premium
# (Actually 5 paths, close to V=4)
```

**Interpretation**:
- **1-10**: Simple, low risk
- **11-20**: Moderate complexity, medium risk
- **21-50**: Complex, high risk
- **50+**: Very complex, very high risk - REFACTOR!

**中文:**

**定义**：通过代码的线性独立路径数

**公式**：
```
V(G) = E - N + 2P

其中：
E = 控制流图中的边数
N = 节点数
P = 连通分量数（通常为1）

简化：V(G) = 决策点数 + 1
```

**决策点**：if、while、for、case、&&、||、?:

**解释**：
- **1-10**：简单，低风险
- **11-20**：中等复杂性，中等风险
- **21-50**：复杂，高风险
- **50+**：非常复杂，非常高风险 - 重构！

### 9.2 Essential Complexity

**English:**

**Definition**: Minimum complexity that cannot be reduced by structured programming

**Calculation**:
1. Draw control flow graph
2. Remove all structured constructs (if-then-else, while loops, etc.)
3. Count remaining decision nodes

**Essential Complexity = 1**: Structured (good)
**Essential Complexity > 1**: Unstructured (bad - has GOTO-like behavior)

**Modern code rarely has essential complexity > 1** (thanks to structured programming)

**中文:**

**定义**：无法通过结构化编程减少的最小复杂性

**计算**：
1. 绘制控制流图
2. 删除所有结构化构造（if-then-else、while循环等）
3. 计算剩余决策节点

**基本复杂度 = 1**：结构化（好）
**基本复杂度 > 1**：非结构化（坏 - 具有类似GOTO的行为）

**现代代码很少有基本复杂度 > 1**（感谢结构化编程）

---

## 10. Design Patterns for Modularization

### 10.1 Facade Pattern

**English:**

**Purpose**: Provide simplified interface to complex subsystem

**Example**:
```python
# Complex subsystem
class CPU:
    def freeze(self): ...
    def jump(self, position): ...
    def execute(self): ...

class Memory:
    def load(self, position, data): ...

class HardDrive:
    def read(self, lba, size): ...

# FACADE: Simplified interface
class ComputerFacade:
    def __init__(self):
        self.cpu = CPU()
        self.memory = Memory()
        self.hd = HardDrive()
    
    def start(self):
        """Simple method hiding complex boot sequence."""
        self.cpu.freeze()
        boot_data = self.hd.read(BOOT_SECTOR, BOOT_SIZE)
        self.memory.load(BOOT_ADDRESS, boot_data)
        self.cpu.jump(BOOT_ADDRESS)
        self.cpu.execute()

# Client code simplified
computer = ComputerFacade()
computer.start()  # Much simpler than manual steps
```

**中文:**

**目的**：为复杂子系统提供简化接口

### 10.2 Adapter Pattern

**English:**

**Purpose**: Convert interface of class into another interface clients expect

**Example**:
```python
# Existing module with incompatible interface
class LegacyPaymentSystem:
    def make_payment(self, account, amount_cents):
        # Payment in cents
        pass

# New interface expected
class PaymentProcessor:
    def process(self, account, amount_dollars):
        pass

# ADAPTER: Makes legacy system compatible
class PaymentAdapter(PaymentProcessor):
    def __init__(self):
        self.legacy = LegacyPaymentSystem()
    
    def process(self, account, amount_dollars):
        # Convert dollars to cents
        amount_cents = int(amount_dollars * 100)
        return self.legacy.make_payment(account, amount_cents)

# Client uses new interface
processor = PaymentAdapter()
processor.process("12345", 99.99)  # Works seamlessly
```

**中文:**

**目的**：将类的接口转换为客户期望的另一个接口

---

## 11. Practical Examples and Refactoring

### 11.1 Example: E-Commerce Order System

**English:**

**Bad Design** (Low Cohesion, High Coupling):
```python
class OrderManager:
    def __init__(self):
        self.db = MySQLDatabase()  # Tight coupling
    
    def create_order(self, user_id, items, payment_info):
        # MULTIPLE RESPONSIBILITIES (low cohesion)
        
        # 1. Validation
        if not items:
            print("Error: No items")  # UI concern
            return False
        
        # 2. Price calculation
        total = 0
        for item in items:
            total += item['price'] * item['qty']
        tax = total * 0.1
        final = total + tax
        
        # 3. Database access
        self.db.connect()
        order_id = self.db.execute("INSERT INTO orders ...")
        
        # 4. Payment processing
        payment_result = self.process_credit_card(payment_info)
        if not payment_result:
            self.db.execute("DELETE FROM orders WHERE id = " + order_id)
            return False
        
        # 5. Email notification
        self.send_email(user_id, f"Order {order_id} confirmed")
        
        # 6. Inventory update
        for item in items:
            self.db.execute(f"UPDATE inventory SET qty = qty - {item['qty']} ...")
        
        return True
```

**Good Design** (High Cohesion, Low Coupling):
```python
# 1. VALIDATION MODULE (Functional Cohesion)
class OrderValidator:
    def validate(self, items):
        if not items:
            raise ValidationError("No items in order")
        for item in items:
            if item['qty'] <= 0:
                raise ValidationError("Invalid quantity")

# 2. PRICING MODULE (Functional Cohesion)
class PricingService:
    TAX_RATE = 0.1
    
    def calculate_total(self, items):
        subtotal = sum(item['price'] * item['qty'] for item in items)
        tax = subtotal * self.TAX_RATE
        return subtotal + tax

# 3. DATA ACCESS MODULE (Functional Cohesion)
class OrderRepository:
    def __init__(self, database):  # Dependency injection
        self.db = database
    
    def save(self, order):
        return self.db.insert('orders', order)
    
    def delete(self, order_id):
        self.db.delete('orders', order_id)

# 4. PAYMENT MODULE (Functional Cohesion)
class PaymentProcessor:
    def process(self, payment_info, amount):
        # Payment processing logic
        return True

# 5. NOTIFICATION MODULE (Functional Cohesion)
class NotificationService:
    def send_order_confirmation(self, user_id, order_id):
        # Email sending logic
        pass

# 6. INVENTORY MODULE (Functional Cohesion)
class InventoryManager:
    def reserve_items(self, items):
        # Inventory update logic
        pass

# 7. ORCHESTRATOR (Coordinating modules - Low Coupling)
class OrderService:
    def __init__(self, validator, pricing, repository, payment, notification, inventory):
        self.validator = validator
        self.pricing = pricing
        self.repository = repository
        self.payment = payment
        self.notification = notification
        self.inventory = inventory
    
    def create_order(self, user_id, items, payment_info):
        try:
            # Use modules with clear responsibilities
            self.validator.validate(items)
            total = self.pricing.calculate_total(items)
            
            order = {'user_id': user_id, 'items': items, 'total': total}
            order_id = self.repository.save(order)
            
            payment_success = self.payment.process(payment_info, total)
            if not payment_success:
                self.repository.delete(order_id)
                raise PaymentError("Payment failed")
            
            self.inventory.reserve_items(items)
            self.notification.send_order_confirmation(user_id, order_id)
            
            return order_id
        except Exception as e:
            # Handle errors
            raise
```

**Benefits of Refactoring**:
- Each module has single responsibility (high cohesion)
- Modules are independent (low coupling)
- Easy to test each module in isolation
- Easy to replace implementations (e.g., swap databases)
- Clear, understandable structure

**中文:**

**坏设计**（低内聚，高耦合）：
（一个巨大的类处理所有事情）

**好设计**（高内