# Database Schema
# 数据库模式

## 1. Fundamental Concepts
## 1. 基础概念

### 1.1 Definition of Database Schema
### 1.1 数据库模式的定义

**Definition:** A database schema is the formal description of the structure of a database, including the definition of tables, columns, data types, relationships, constraints, indexes, and other database objects. It represents the logical blueprint of the database.

**定义：** 数据库模式是数据库结构的形式化描述，包括表、列、数据类型、关系、约束、索引和其他数据库对象的定义。它代表数据库的逻辑蓝图。

**Key Characteristics:**
**关键特性：**

- **Stability**: Schema remains relatively stable while data changes frequently
- **稳定性**：模式相对稳定，而数据经常变化
- **Abstraction**: Provides logical view independent of physical storage
- **抽象性**：提供独立于物理存储的逻辑视图
- **Integrity**: Defines rules to ensure data consistency
- **完整性**：定义确保数据一致性的规则
- **Security**: Basis for access control mechanisms
- **安全性**：访问控制机制的基础

### 1.2 Three-Schema Architecture (ANSI/SPARC)
### 1.2 三级模式架构（ANSI/SPARC）

**Overview:**
**概述：**

The ANSI/SPARC three-schema architecture separates the database into three levels of abstraction, providing data independence and flexibility.

ANSI/SPARC三级模式架构将数据库分为三个抽象层次，提供数据独立性和灵活性。

```
┌─────────────────────────────────────────────────────┐
│                   External Level                     │
│                     外模式层                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐          │
│  │  View 1  │  │  View 2  │  │  View 3  │          │
│  │  视图1   │  │  视图2   │  │  视图3   │          │
│  └──────────┘  └──────────┘  └──────────┘          │
├─────────────────────────────────────────────────────┤
│              External/Conceptual Mapping             │
│                  外模式/概念模式映像                  │
├─────────────────────────────────────────────────────┤
│                 Conceptual Level                     │
│                    概念模式层                        │
│        ┌─────────────────────────────┐              │
│        │    Conceptual Schema        │              │
│        │       概念模式              │              │
│        └─────────────────────────────┘              │
├─────────────────────────────────────────────────────┤
│             Conceptual/Internal Mapping              │
│                 概念模式/内模式映像                   │
├─────────────────────────────────────────────────────┤
│                  Internal Level                      │
│                    内模式层                          │
│        ┌─────────────────────────────┐              │
│        │    Internal Schema          │              │
│        │       内模式                │              │
│        └─────────────────────────────┘              │
├─────────────────────────────────────────────────────┤
│                  Physical Storage                    │
│                    物理存储                          │
└─────────────────────────────────────────────────────┘
```

#### 1.2.1 External Schema (View Level)
#### 1.2.1 外模式（视图层）

**Definition:** The external schema defines user-specific views of the database, showing only the data relevant to particular users or applications.

**定义：** 外模式定义用户特定的数据库视图，只显示与特定用户或应用程序相关的数据。

**Characteristics:**
**特性：**

- Multiple external schemas can exist for one database
- 一个数据库可以存在多个外模式
- Provides customized views for different user groups
- 为不同用户组提供定制视图
- Implements security through data hiding
- 通过数据隐藏实现安全性
- Simplifies complex data structures for users
- 为用户简化复杂的数据结构

**Example:**
**示例：**

```sql
-- External Schema: HR Department View
-- 外模式：人力资源部门视图
CREATE VIEW HR_Employee_View AS
SELECT 
    employee_id,
    first_name,
    last_name,
    hire_date,
    department_name,
    salary
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

-- External Schema: Finance Department View
-- 外模式：财务部门视图
CREATE VIEW Finance_Payroll_View AS
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    commission_pct,
    salary * (1 + COALESCE(commission_pct, 0)) AS total_compensation
FROM employees;
```

#### 1.2.2 Conceptual Schema (Logical Level)
#### 1.2.2 概念模式（逻辑层）

**Definition:** The conceptual schema describes the complete logical structure of the database, including all entities, attributes, relationships, and integrity constraints, independent of how data is physically stored.

**定义：** 概念模式描述数据库的完整逻辑结构，包括所有实体、属性、关系和完整性约束，独立于数据的物理存储方式。

**Characteristics:**
**特性：**

- Only one conceptual schema per database
- 每个数据库只有一个概念模式
- Describes data types, relationships, and constraints
- 描述数据类型、关系和约束
- Independent of specific applications
- 独立于特定应用程序
- Designed by database administrators
- 由数据库管理员设计

**Example:**
**示例：**

```sql
-- Conceptual Schema Definition
-- 概念模式定义

CREATE TABLE departments (
    department_id   INT PRIMARY KEY,
    department_name VARCHAR(100) NOT NULL,
    manager_id      INT,
    location_id     INT
);

CREATE TABLE employees (
    employee_id     INT PRIMARY KEY,
    first_name      VARCHAR(50) NOT NULL,
    last_name       VARCHAR(50) NOT NULL,
    email           VARCHAR(100) UNIQUE NOT NULL,
    hire_date       DATE NOT NULL,
    salary          DECIMAL(10,2) CHECK (salary > 0),
    department_id   INT REFERENCES departments(department_id),
    manager_id      INT REFERENCES employees(employee_id)
);

CREATE TABLE projects (
    project_id      INT PRIMARY KEY,
    project_name    VARCHAR(100) NOT NULL,
    start_date      DATE,
    end_date        DATE,
    budget          DECIMAL(15,2),
    CONSTRAINT chk_dates CHECK (end_date >= start_date)
);
```

#### 1.2.3 Internal Schema (Physical Level)
#### 1.2.3 内模式（物理层）

**Definition:** The internal schema describes how data is physically stored in the database, including storage structures, access paths, indexes, and file organizations.

**定义：** 内模式描述数据在数据库中的物理存储方式，包括存储结构、访问路径、索引和文件组织。

**Characteristics:**
**特性：**

- Only one internal schema per database
- 每个数据库只有一个内模式
- Defines physical storage details
- 定义物理存储细节
- Managed by DBMS automatically
- 由DBMS自动管理
- Optimized for performance
- 针对性能进行优化

**Components:**
**组成部分：**

- Storage allocation (tablespaces, data files)
- 存储分配（表空间、数据文件）
- Index structures (B-tree, hash, bitmap)
- 索引结构（B树、哈希、位图）
- Record formats and compression
- 记录格式和压缩
- Buffer management
- 缓冲区管理

### 1.3 Two-Level Mapping and Data Independence
### 1.3 两级映像与数据独立性

**Mapping Types:**
**映像类型：**

#### 1.3.1 External/Conceptual Mapping
#### 1.3.1 外模式/概念模式映像

**Purpose:** Defines correspondence between external schema and conceptual schema.

**目的：** 定义外模式与概念模式之间的对应关系。

**Provides:** Logical Data Independence
**提供：** 逻辑数据独立性

- Changes to conceptual schema don't affect external schemas
- 概念模式的改变不影响外模式
- Applications remain unchanged when logical structure changes
- 当逻辑结构改变时应用程序保持不变

#### 1.3.2 Conceptual/Internal Mapping
#### 1.3.2 概念模式/内模式映像

**Purpose:** Defines correspondence between conceptual schema and internal schema.

**目的：** 定义概念模式与内模式之间的对应关系。

**Provides:** Physical Data Independence
**提供：** 物理数据独立性

- Changes to physical storage don't affect conceptual schema
- 物理存储的改变不影响概念模式
- Storage reorganization is transparent to applications
- 存储重组对应用程序透明

**Data Independence Comparison:**
**数据独立性比较：**

| Type                  | Level               | Description                                  | Example           |
| --------------------- | ------------------- | -------------------------------------------- | ----------------- |
| Logical Independence  | External/Conceptual | Applications unaffected by logical changes   | Adding new column |
| Physical Independence | Conceptual/Internal | Logical schema unaffected by storage changes | Moving to SSD     |

| 类型       | 层级            | 描述                     | 示例      |
| ---------- | --------------- | ------------------------ | --------- |
| 逻辑独立性 | 外模式/概念模式 | 应用程序不受逻辑变化影响 | 添加新列  |
| 物理独立性 | 概念模式/内模式 | 逻辑模式不受存储变化影响 | 迁移到SSD |

### 1.4 Schema vs Instance
### 1.4 模式与实例

**Schema (模式):**
- The structure or blueprint of the database
- 数据库的结构或蓝图
- Defined at design time
- 在设计时定义
- Rarely changes (metadata)
- 很少改变（元数据）
- Example: Table definitions, constraints
- 示例：表定义、约束

**Instance (实例):**
- The actual data stored at a particular moment
- 在特定时刻存储的实际数据
- Changes frequently (data)
- 经常变化（数据）
- Also called database state or snapshot
- 也称为数据库状态或快照
- Example: Rows in a table
- 示例：表中的行

```
Schema (模式)                    Instance (实例)
┌─────────────────────┐          ┌─────────────────────────────┐
│ employees           │          │ employee_id │ name  │ salary│
│ ├─ employee_id INT  │          ├─────────────┼───────┼───────┤
│ ├─ name VARCHAR(50) │   ───▶   │ 1           │ John  │ 50000 │
│ └─ salary DECIMAL   │          │ 2           │ Jane  │ 60000 │
└─────────────────────┘          │ 3           │ Bob   │ 55000 │
                                 └─────────────────────────────┘
```

## 2. Data Models
## 2. 数据模型

### 2.1 Overview of Data Models
### 2.1 数据模型概述

**Definition:** A data model is a collection of concepts for describing data, data relationships, data semantics, and consistency constraints.

**定义：** 数据模型是描述数据、数据关系、数据语义和一致性约束的概念集合。

**Three Elements of Data Model:**
**数据模型三要素：**

1. **Data Structure**: How data is organized
1. **数据结构**：数据如何组织

2. **Data Operations**: What operations can be performed
2. **数据操作**：可以执行哪些操作

3. **Integrity Constraints**: Rules data must follow
3. **完整性约束**：数据必须遵循的规则

### 2.2 Historical Data Models
### 2.2 历史数据模型

#### 2.2.1 Hierarchical Model
#### 2.2.1 层次模型

**Structure:** Tree structure with parent-child relationships
**结构：** 具有父子关系的树形结构

```
                    Company (公司)
                        │
        ┌───────────────┼───────────────┐
        ▼               ▼               ▼
   Department A    Department B    Department C
   (部门A)         (部门B)         (部门C)
        │               │
    ┌───┴───┐       ┌───┴───┐
    ▼       ▼       ▼       ▼
  Emp 1   Emp 2   Emp 3   Emp 4
  (员工1) (员工2) (员工3) (员工4)
```

**Characteristics:**
**特性：**
- One-to-many relationships only
- 仅支持一对多关系
- Fast navigation through predefined paths
- 通过预定义路径快速导航
- Limited flexibility
- 灵活性有限
- Example: IBM IMS
- 示例：IBM IMS

#### 2.2.2 Network Model
#### 2.2.2 网状模型

**Structure:** Graph structure allowing many-to-many relationships
**结构：** 允许多对多关系的图形结构

```
    ┌─────────┐     ┌─────────┐
    │ Student │     │ Course  │
    │  学生   │     │  课程   │
    └────┬────┘     └────┬────┘
         │               │
         └───────┬───────┘
                 ▼
         ┌─────────────┐
         │ Enrollment  │
         │   选课      │
         └─────────────┘
```

**Characteristics:**
**特性：**
- Supports many-to-many relationships
- 支持多对多关系
- More flexible than hierarchical
- 比层次模型更灵活
- Complex pointer-based navigation
- 复杂的基于指针的导航
- Example: CODASYL DBTG
- 示例：CODASYL DBTG

### 2.3 Relational Model
### 2.3 关系模型

**Definition:** The relational model represents data as a collection of relations (tables), where each relation is a set of tuples (rows).

**定义：** 关系模型将数据表示为关系（表）的集合，每个关系是元组（行）的集合。

**Key Concepts:**
**关键概念：**

| Term        | Alternative Name | Description          |
| ----------- | ---------------- | -------------------- |
| Relation    | Table            | Collection of tuples |
| Tuple       | Row/Record       | Single data entry    |
| Attribute   | Column/Field     | Property of entity   |
| Domain      | Data Type        | Set of valid values  |
| Cardinality | Row count        | Number of tuples     |
| Degree      | Column count     | Number of attributes |

| 术语 | 别名     | 描述         |
| ---- | -------- | ------------ |
| 关系 | 表       | 元组的集合   |
| 元组 | 行/记录  | 单个数据条目 |
| 属性 | 列/字段  | 实体的属性   |
| 域   | 数据类型 | 有效值的集合 |
| 基数 | 行数     | 元组的数量   |
| 度   | 列数     | 属性的数量   |

**Formal Definition:**
**形式化定义：**

```
Relation R is defined over domains D1, D2, ..., Dn:
关系R定义在域D1, D2, ..., Dn上：

R ⊆ D1 × D2 × ... × Dn

Where D1 × D2 × ... × Dn is the Cartesian product
其中D1 × D2 × ... × Dn是笛卡尔积
```

**Properties of Relations:**
**关系的属性：**

1. Each cell contains atomic value
1. 每个单元格包含原子值
2. Each column has unique name
2. 每列有唯一名称
3. Values in column are from same domain
3. 列中的值来自同一个域
4. Each row is unique
4. 每行是唯一的
5. Order of rows is insignificant
5. 行的顺序无关紧要
6. Order of columns is insignificant
6. 列的顺序无关紧要

### 2.4 Entity-Relationship (E-R) Model
### 2.4 实体-关系（E-R）模型

**Purpose:** Conceptual data modeling for database design
**目的：** 用于数据库设计的概念数据建模

**Core Components:**
**核心组件：**

**1. Entity (实体)**
- Real-world object or concept
- 现实世界的对象或概念
- Represented as rectangle
- 用矩形表示

**2. Attribute (属性)**
- Property of entity
- 实体的属性
- Represented as ellipse
- 用椭圆表示

**3. Relationship (关系)**
- Association between entities
- 实体之间的关联
- Represented as diamond
- 用菱形表示

**E-R Diagram Example:**
**E-R图示例：**

```
    ┌─────────────┐           ┌─────────────┐
    │   Student   │           │   Course    │
    │    学生     │           │    课程     │
    └──────┬──────┘           └──────┬──────┘
           │                         │
     ○ ID  ○ Name              ○ Code ○ Title
     ○ 学号 ○ 姓名              ○ 课程号 ○ 课程名
           │                         │
           │        Enrolls          │
           └────────◇────────────────┘
                    │
                  选修
                    │
              ○ Grade (成绩)

Cardinality: M:N (Many-to-Many)
基数：M:N（多对多）
```

**Relationship Types:**
**关系类型：**

| Type | Description  | Example               |
| ---- | ------------ | --------------------- |
| 1:1  | One-to-One   | Person - Passport     |
| 1:N  | One-to-Many  | Department - Employee |
| M:N  | Many-to-Many | Student - Course      |

| 类型 | 描述   | 示例        |
| ---- | ------ | ----------- |
| 1:1  | 一对一 | 人 - 护照   |
| 1:N  | 一对多 | 部门 - 员工 |
| M:N  | 多对多 | 学生 - 课程 |

### 2.5 Object-Relational Model
### 2.5 对象关系模型

**Definition:** Extends relational model with object-oriented features like user-defined types, inheritance, and complex data types.

**定义：** 用面向对象的特性扩展关系模型，如用户定义类型、继承和复杂数据类型。

**Features:**
**特性：**

```sql
-- User-Defined Type (用户定义类型)
CREATE TYPE address_type AS (
    street VARCHAR(100),
    city VARCHAR(50),
    postal_code VARCHAR(20)
);

-- Table with Complex Type (使用复杂类型的表)
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100),
    home_address address_type,
    work_address address_type
);

-- Inheritance (继承)
CREATE TABLE persons (
    person_id INT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE employees (
    salary DECIMAL(10,2),
    department_id INT
) INHERITS (persons);
```

## 3. Relational Schema Design
## 3. 关系模式设计

### 3.1 Formal Definition of Relational Schema
### 3.1 关系模式的形式化定义

**Definition:**
**定义：**

```
Relational Schema: R(A1, A2, ..., An)
关系模式：R(A1, A2, ..., An)

Where:
其中：
- R is the relation name (关系名)
- A1, A2, ..., An are attributes (属性)
- Each Ai has a domain Di (每个Ai有一个域Di)
```

**Example:**
**示例：**

```
Employee(emp_id: INT, name: VARCHAR, dept_id: INT, salary: DECIMAL)
员工(员工号: INT, 姓名: VARCHAR, 部门号: INT, 工资: DECIMAL)
```

### 3.2 Functional Dependencies
### 3.2 函数依赖

**Definition:** A functional dependency X → Y means that for any two tuples t1 and t2, if t1[X] = t2[X], then t1[Y] = t2[Y].

**定义：** 函数依赖X → Y表示对于任意两个元组t1和t2，如果t1[X] = t2[X]，则t1[Y] = t2[Y]。

**Types of Functional Dependencies:**
**函数依赖的类型：**

**1. Full Functional Dependency (完全函数依赖)**
```
X → Y is full if no proper subset of X determines Y
如果X的任何真子集都不能决定Y，则X → Y是完全的

Example: (student_id, course_id) → grade
示例：(学号, 课程号) → 成绩
```

**2. Partial Functional Dependency (部分函数依赖)**
```
X → Y is partial if some proper subset of X determines Y
如果X的某个真子集能决定Y，则X → Y是部分的

Example: (student_id, course_id) → student_name
示例：(学号, 课程号) → 学生姓名
(student_id alone determines student_name)
（仅学号就能决定学生姓名）
```

**3. Transitive Dependency (传递依赖)**
```
X → Y → Z (where Y is not a superkey)
如果X → Y且Y → Z（其中Y不是超键）

Example: emp_id → dept_id → dept_name
示例：员工号 → 部门号 → 部门名
```

### 3.3 Keys
### 3.3 键

**Types of Keys:**
**键的类型：**

| Key Type          | Description                                        |
| ----------------- | -------------------------------------------------- |
| **Super Key**     | Set of attributes that uniquely identifies a tuple |
| **Candidate Key** | Minimal super key                                  |
| **Primary Key**   | Selected candidate key                             |
| **Foreign Key**   | References primary key of another table            |
| **Alternate Key** | Candidate key not chosen as primary                |

| 键类型     | 描述                   |
| ---------- | ---------------------- |
| **超键**   | 能唯一标识元组的属性集 |
| **候选键** | 最小的超键             |
| **主键**   | 选定的候选键           |
| **外键**   | 引用另一个表的主键     |
| **备选键** | 未被选为主键的候选键   |

**Example:**
**示例：**

```sql
CREATE TABLE students (
    student_id INT PRIMARY KEY,      -- Primary Key (主键)
    national_id CHAR(18) UNIQUE,     -- Alternate Key (备选键)
    email VARCHAR(100) UNIQUE,       -- Alternate Key (备选键)
    name VARCHAR(50),
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(dept_id)
    -- Foreign Key (外键)
);
```

### 3.4 Normal Forms
### 3.4 范式

**Purpose:** Reduce data redundancy and avoid update anomalies.
**目的：** 减少数据冗余，避免更新异常。

#### 3.4.1 First Normal Form (1NF)
#### 3.4.1 第一范式（1NF）

**Rule:** All attribute values must be atomic (no repeating groups or arrays).
**规则：** 所有属性值必须是原子的（没有重复组或数组）。

**Violation Example:**
**违反示例：**

```
❌ Not 1NF (非1NF):
┌────────┬─────────────────────────┐
│ emp_id │ phone_numbers           │
├────────┼─────────────────────────┤
│ 1      │ 123-456, 789-012        │
└────────┴─────────────────────────┘

✓ 1NF:
┌────────┬──────────────┐
│ emp_id │ phone_number │
├────────┼──────────────┤
│ 1      │ 123-456      │
│ 1      │ 789-012      │
└────────┴──────────────┘
```

#### 3.4.2 Second Normal Form (2NF)
#### 3.4.2 第二范式（2NF）

**Rule:** Must be in 1NF and every non-key attribute must be fully functionally dependent on the entire primary key.

**规则：** 必须满足1NF，且每个非键属性必须完全函数依赖于整个主键。

**Violation Example:**
**违反示例：**

```
❌ Not 2NF (非2NF):
Order_Items(order_id, product_id, quantity, product_name, product_price)
PK: (order_id, product_id)

Problem: product_name depends only on product_id (partial dependency)
问题：product_name只依赖于product_id（部分依赖）

✓ 2NF Solution:
Order_Items(order_id, product_id, quantity)
Products(product_id, product_name, product_price)
```

#### 3.4.3 Third Normal Form (3NF)
#### 3.4.3 第三范式（3NF）

**Rule:** Must be in 2NF and no transitive dependencies.
**规则：** 必须满足2NF，且没有传递依赖。

**Formal Definition:**
**形式化定义：**

For every FD X → A:
- X is a superkey, OR
- A is part of a candidate key

**Violation Example:**
**违反示例：**

```
❌ Not 3NF (非3NF):
Employees(emp_id, emp_name, dept_id, dept_name, dept_location)

emp_id → dept_id → dept_name (transitive dependency)
员工号 → 部门号 → 部门名（传递依赖）

✓ 3NF Solution:
Employees(emp_id, emp_name, dept_id)
Departments(dept_id, dept_name, dept_location)
```

#### 3.4.4 Boyce-Codd Normal Form (BCNF)
#### 3.4.4 BC范式（BCNF）

**Rule:** For every FD X → Y, X must be a superkey.
**规则：** 对于每个函数依赖X → Y，X必须是超键。

**Stricter than 3NF:**
**比3NF更严格：**

```
❌ 3NF but not BCNF:
Teaching(student_id, subject, teacher)

FDs:
- (student_id, subject) → teacher
- teacher → subject

teacher is not a superkey, violates BCNF
teacher不是超键，违反BCNF

✓ BCNF Solution:
Student_Teacher(student_id, teacher)
Teacher_Subject(teacher, subject)
```

#### 3.4.5 Fourth Normal Form (4NF)
#### 3.4.5 第四范式（4NF）

**Rule:** Must be in BCNF with no multi-valued dependencies.
**规则：** 必须满足BCNF，且没有多值依赖。

**Multi-valued Dependency:**
**多值依赖：**

```
X ↠ Y means: for a given X value, Y values are independent of other attributes
X ↠ Y表示：对于给定的X值，Y的值与其他属性无关

❌ Not 4NF:
Employee_Skills_Languages(emp_id, skill, language)

Problem: skill and language are independent MVDs
问题：skill和language是独立的多值依赖

✓ 4NF Solution:
Employee_Skills(emp_id, skill)
Employee_Languages(emp_id, language)
```

**Normal Forms Summary:**
**范式总结：**

| Normal Form | Key Requirement                     |
| ----------- | ----------------------------------- |
| **1NF**     | Atomic values only                  |
| **2NF**     | 1NF + No partial dependencies       |
| **3NF**     | 2NF + No transitive dependencies    |
| **BCNF**    | All determinants are superkeys      |
| **4NF**     | BCNF + No multi-valued dependencies |
| **5NF**     | No join dependencies                |

| 范式     | 关键要求             |
| -------- | -------------------- |
| **1NF**  | 仅原子值             |
| **2NF**  | 1NF + 无部分依赖     |
| **3NF**  | 2NF + 无传递依赖     |
| **BCNF** | 所有决定因素都是超键 |
| **4NF**  | BCNF + 无多值依赖    |
| **5NF**  | 无连接依赖           |

### 3.5 Normalization vs Denormalization
### 3.5 规范化与反规范化

**Normalization Benefits:**
**规范化优点：**
- Eliminates data redundancy
- 消除数据冗余
- Prevents update anomalies
- 防止更新异常
- Ensures data integrity
- 确保数据完整性
- Reduces storage space
- 减少存储空间

**Denormalization Benefits:**
**反规范化优点：**
- Improves query performance (fewer joins)
- 提高查询性能（更少的连接）
- Simplifies application logic
- 简化应用逻辑
- Better for read-heavy workloads
- 更适合读密集型工作负载

**When to Denormalize:**
**何时反规范化：**

```sql
-- Before (Normalized)
-- 之前（规范化）
SELECT o.order_id, c.customer_name, p.product_name, oi.quantity
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id;

-- After (Denormalized for reporting)
-- 之后（为报表反规范化）
CREATE TABLE order_summary (
    order_id INT,
    customer_name VARCHAR(100),  -- Denormalized (反规范化)
    product_name VARCHAR(100),   -- Denormalized (反规范化)
    quantity INT
);
```

## 4. Physical Schema Design
## 4. 物理模式设计

### 4.1 Storage Structures and File Organization
### 4.1 存储结构和文件组织

**File Organization Types:**
**文件组织类型：**

| Type            | Description                          | Best For                 |
| --------------- | ------------------------------------ | ------------------------ |
| **Heap File**   | Records stored in insertion order    | Bulk loading, full scans |
| **Sorted File** | Records sorted by key                | Range queries            |
| **Hash File**   | Records distributed by hash function | Point queries            |
| **Clustered**   | Related data stored together         | Join operations          |

| 类型         | 描述               | 最适合             |
| ------------ | ------------------ | ------------------ |
| **堆文件**   | 按插入顺序存储记录 | 批量加载、全表扫描 |
| **排序文件** | 按键排序记录       | 范围查询           |
| **哈希文件** | 按哈希函数分布记录 | 点查询             |
| **聚簇**     | 相关数据存储在一起 | 连接操作           |

**Tablespace Management:**
**表空间管理：**

```sql
-- PostgreSQL Example
-- PostgreSQL示例
CREATE TABLESPACE fast_storage
    LOCATION '/ssd/postgres_data';

CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    order_date DATE
) TABLESPACE fast_storage;

-- Oracle Example
-- Oracle示例
CREATE TABLESPACE orders_ts
    DATAFILE '/u01/oradata/orders01.dbf' SIZE 1G
    AUTOEXTEND ON NEXT 100M MAXSIZE 10G;
```

### 4.2 Index Design
### 4.2 索引设计

#### 4.2.1 B+ Tree Index
#### 4.2.1 B+树索引

**Structure:**
**结构：**

```
                    [Root Node]
                    根节点
                    [30 | 60]
                   /    |    \\
                  /     |     \\
        [10|20]    [40|50]    [70|80]
        叶子节点    叶子节点    叶子节点
         /|\\        /|\\        /|\\
        Data       Data       Data
        数据       数据       数据
```

**Characteristics:**
**特性：**
- Balanced tree structure
- 平衡树结构
- All data in leaf nodes
- 所有数据在叶子节点
- Leaf nodes linked for range scans
- 叶子节点链接以便范围扫描
- O(log n) search complexity
- O(log n)搜索复杂度
- Best for range queries and equality
- 最适合范围查询和等值查询

```sql
-- B-Tree Index (default)
-- B树索引（默认）
CREATE INDEX idx_employee_name ON employees(last_name);

-- Composite Index
-- 复合索引
CREATE INDEX idx_emp_dept_name ON employees(department_id, last_name);
```

#### 4.2.2 Hash Index
#### 4.2.2 哈希索引

**Characteristics:**
**特性：**
- O(1) average lookup
- 平均O(1)查找
- Equality comparisons only
- 仅适用于等值比较
- Not suitable for range queries
- 不适合范围查询
- Memory-based typically
- 通常基于内存

```sql
-- Hash Index (PostgreSQL)
-- 哈希索引（PostgreSQL）
CREATE INDEX idx_emp_id_hash ON employees USING hash (employee_id);
```

#### 4.2.3 Bitmap Index
#### 4.2.3 位图索引

**Characteristics:**
**特性：**
- Efficient for low-cardinality columns
- 对低基数列高效
- Excellent for data warehousing
- 非常适合数据仓库
- Supports complex AND/OR operations
- 支持复杂的AND/OR操作
- Not suitable for frequent updates
- 不适合频繁更新

```sql
-- Bitmap Index (Oracle)
-- 位图索引（Oracle）
CREATE BITMAP INDEX idx_emp_gender ON employees(gender);
CREATE BITMAP INDEX idx_emp_status ON employees(status);
```

**Index Selection Guidelines:**
**索引选择指南：**

| Query Type       | Recommended Index |
| ---------------- | ----------------- |
| Equality lookup  | Hash or B-tree    |
| Range query      | B-tree            |
| Pattern matching | B-tree (prefix)   |
| Low cardinality  | Bitmap            |
| Full-text search | Full-text index   |

| 查询类型 | 推荐索引    |
| -------- | ----------- |
| 等值查找 | 哈希或B树   |
| 范围查询 | B树         |
| 模式匹配 | B树（前缀） |
| 低基数   | 位图        |
| 全文搜索 | 全文索引    |

### 4.3 Partitioning Strategies
### 4.3 分区策略

#### 4.3.1 Horizontal Partitioning
#### 4.3.1 水平分区

**Definition:** Divides table rows across partitions.
**定义：** 将表行分布到各分区。

**Types:**
**类型：**

```sql
-- Range Partitioning
-- 范围分区
CREATE TABLE orders (
    order_id INT,
    order_date DATE,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (order_date) (
    PARTITION p2023 VALUES LESS THAN ('2024-01-01'),
    PARTITION p2024 VALUES LESS THAN ('2025-01-01'),
    PARTITION p_future VALUES LESS THAN (MAXVALUE)
);

-- List Partitioning
-- 列表分区
CREATE TABLE customers (
    customer_id INT,
    region VARCHAR(20),
    name VARCHAR(100)
) PARTITION BY LIST (region) (
    PARTITION p_east VALUES IN ('Beijing', 'Shanghai'),
    PARTITION p_west VALUES IN ('Chengdu', 'Xian'),
    PARTITION p_south VALUES IN ('Guangzhou', 'Shenzhen')
);

-- Hash Partitioning
-- 哈希分区
CREATE TABLE sessions (
    session_id INT,
    user_id INT,
    login_time TIMESTAMP
) PARTITION BY HASH (user_id) PARTITIONS 8;
```

#### 4.3.2 Vertical Partitioning
#### 4.3.2 垂直分区

**Definition:** Divides table columns across tables.
**定义：** 将表列分布到各表。

```sql
-- Before (Wide Table)
-- 之前（宽表）
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(100),
    description TEXT,           -- Large, rarely accessed
    image BLOB,                 -- Very large
    price DECIMAL(10,2),
    stock_quantity INT
);

-- After (Vertical Partitioning)
-- 之后（垂直分区）
CREATE TABLE products_core (
    product_id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2),
    stock_quantity INT
);

CREATE TABLE products_details (
    product_id INT PRIMARY KEY REFERENCES products_core,
    description TEXT,
    image BLOB
);
```

## 5. Schema Definition and Management
## 5. 模式定义与管理

### 5.1 DDL Statements
### 5.1 DDL语句

#### 5.1.1 CREATE Statement
#### 5.1.1 CREATE语句

```sql
-- Create Database
-- 创建数据库
CREATE DATABASE company_db
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_unicode_ci;

-- Create Schema (Namespace)
-- 创建模式（命名空间）
CREATE SCHEMA hr_schema;

-- Create Table with Full Constraints
-- 创建带完整约束的表
CREATE TABLE hr_schema.employees (
    employee_id     INT AUTO_INCREMENT,
    first_name      VARCHAR(50) NOT NULL,
    last_name       VARCHAR(50) NOT NULL,
    email           VARCHAR(100) NOT NULL,
    phone           VARCHAR(20),
    hire_date       DATE NOT NULL DEFAULT (CURRENT_DATE),
    salary          DECIMAL(10,2) NOT NULL,
    department_id   INT,
    manager_id      INT,
    
    -- Constraints (约束)
    CONSTRAINT pk_employee PRIMARY KEY (employee_id),
    CONSTRAINT uk_email UNIQUE (email),
    CONSTRAINT chk_salary CHECK (salary > 0),
    CONSTRAINT fk_department 
        FOREIGN KEY (department_id) 
        REFERENCES departments(department_id)
        ON DELETE SET NULL
        ON UPDATE CASCADE,
    CONSTRAINT fk_manager 
        FOREIGN KEY (manager_id) 
        REFERENCES employees(employee_id)
);
```

#### 5.1.2 ALTER Statement
#### 5.1.2 ALTER语句

```sql
-- Add Column
-- 添加列
ALTER TABLE employees 
    ADD COLUMN middle_name VARCHAR(50);

-- Modify Column
-- 修改列
ALTER TABLE employees 
    MODIFY COLUMN phone VARCHAR(30);

-- Add Constraint
-- 添加约束
ALTER TABLE employees 
    ADD CONSTRAINT chk_phone 
    CHECK (phone REGEXP '^[0-9-]+$');

-- Drop Constraint
-- 删除约束
ALTER TABLE employees 
    DROP CONSTRAINT chk_phone;

-- Rename Table
-- 重命名表
ALTER TABLE employees RENAME TO staff;
```

#### 5.1.3 DROP Statement
#### 5.1.3 DROP语句

```sql
-- Drop Index
-- 删除索引
DROP INDEX idx_employee_name ON employees;

-- Drop Table
-- 删除表
DROP TABLE IF EXISTS temp_employees;

-- Drop Table with Dependencies
-- 删除表及其依赖
DROP TABLE orders CASCADE;

-- Drop Schema
-- 删除模式
DROP SCHEMA hr_schema CASCADE;
```

### 5.2 Constraint Definitions
### 5.2 约束定义

**Constraint Types:**
**约束类型：**

| Constraint      | Description                    | Level        |
| --------------- | ------------------------------ | ------------ |
| **NOT NULL**    | Column cannot be null          | Column       |
| **UNIQUE**      | All values must be different   | Column/Table |
| **PRIMARY KEY** | Unique identifier for rows     | Table        |
| **FOREIGN KEY** | References another table       | Table        |
| **CHECK**       | Values must satisfy condition  | Column/Table |
| **DEFAULT**     | Default value if not specified | Column       |

| 约束            | 描述             | 级别  |
| --------------- | ---------------- | ----- |
| **NOT NULL**    | 列不能为空       | 列    |
| **UNIQUE**      | 所有值必须不同   | 列/表 |
| **PRIMARY KEY** | 行的唯一标识符   | 表    |
| **FOREIGN KEY** | 引用另一个表     | 表    |
| **CHECK**       | 值必须满足条件   | 列/表 |
| **DEFAULT**     | 未指定时的默认值 | 列    |

**Foreign Key Actions:**
**外键动作：**

```sql
CONSTRAINT fk_department FOREIGN KEY (department_id) 
    REFERENCES departments(department_id)
    ON DELETE CASCADE      -- Delete child rows
                          -- 删除子行
    ON UPDATE CASCADE;     -- Update child foreign keys
                          -- 更新子外键

-- Other options (其他选项):
-- ON DELETE SET NULL     -- Set to NULL
-- ON DELETE SET DEFAULT  -- Set to default value
-- ON DELETE RESTRICT     -- Prevent deletion
-- ON DELETE NO ACTION    -- Defer check to end of transaction
```

### 5.3 View Design
### 5.3 视图设计

**Types of Views:**
**视图类型：**

```sql
-- Simple View (Updatable)
-- 简单视图（可更新）
CREATE VIEW active_employees AS
SELECT employee_id, first_name, last_name, department_id
FROM employees
WHERE status = 'ACTIVE';

-- Complex View (Read-only)
-- 复杂视图（只读）
CREATE VIEW department_summary AS
SELECT 
    d.department_name,
    COUNT(e.employee_id) AS employee_count,
    AVG(e.salary) AS avg_salary,
    MAX(e.salary) AS max_salary
FROM departments d
LEFT JOIN employees e ON d.department_id = e.department_id
GROUP BY d.department_id, d.department_name;

-- Materialized View (PostgreSQL)
-- 物化视图（PostgreSQL）
CREATE MATERIALIZED VIEW monthly_sales AS
SELECT 
    DATE_TRUNC('month', order_date) AS month,
    SUM(amount) AS total_sales
FROM orders
GROUP BY DATE_TRUNC('month', order_date)
WITH DATA;

-- Refresh Materialized View
-- 刷新物化视图
REFRESH MATERIALIZED VIEW monthly_sales;
```

**View Benefits:**
**视图优点：**
- **Security**: Hide sensitive columns
- **安全性**：隐藏敏感列
- **Simplification**: Abstract complex joins
- **简化**：抽象复杂连接
- **Consistency**: Single source of truth
- **一致性**：单一事实来源
- **Independence**: Logical data independence
- **独立性**：逻辑数据独立性

### 5.4 Schema Version Control and Migration
### 5.4 模式版本控制与迁移

**Migration Tools:**
**迁移工具：**

| Tool           | Language | Description                |
| -------------- | -------- | -------------------------- |
| Flyway         | Java     | Version-based migrations   |
| Liquibase      | Java     | Changelog-based migrations |
| Alembic        | Python   | SQLAlchemy migrations      |
| golang-migrate | Go       | CLI migration tool         |

| 工具           | 语言   | 描述               |
| -------------- | ------ | ------------------ |
| Flyway         | Java   | 基于版本的迁移     |
| Liquibase      | Java   | 基于变更日志的迁移 |
| Alembic        | Python | SQLAlchemy迁移     |
| golang-migrate | Go     | CLI迁移工具        |

**Migration Example (Flyway):**
**迁移示例（Flyway）：**

```sql
-- V1__Create_users_table.sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL
);

-- V2__Add_created_at_column.sql
ALTER TABLE users 
    ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- V3__Create_user_roles_table.sql
CREATE TABLE user_roles (
    user_id INT REFERENCES users(user_id),
    role_name VARCHAR(50),
    PRIMARY KEY (user_id, role_name)
);
```

**Best Practices:**
**最佳实践：**
- Version all schema changes
- 对所有模式更改进行版本控制
- Never modify existing migrations
- 不要修改现有迁移
- Include rollback scripts
- 包含回滚脚本
- Test migrations on staging first
- 先在测试环境测试迁移
- Use backward-compatible changes
- 使用向后兼容的更改

## 6. Advanced Topics
## 6. 高级主题

### 6.1 Distributed Database Schema Design
### 6.1 分布式数据库模式设计

**Fragmentation Types:**
**片段类型：**

**1. Horizontal Fragmentation (水平分片)**
```sql
-- Fragment by region (按地区分片)
-- Node 1: East Region
CREATE TABLE orders_east AS
SELECT * FROM orders WHERE region = 'East';

-- Node 2: West Region
CREATE TABLE orders_west AS
SELECT * FROM orders WHERE region = 'West';
```

**2. Vertical Fragmentation (垂直分片)**
```sql
-- Node 1: Frequently accessed columns
CREATE TABLE customer_core (
    customer_id, name, email
);

-- Node 2: Less frequently accessed columns
CREATE TABLE customer_details (
    customer_id, address, phone, preferences
);
```

**Sharding Strategies:**
**分片策略：**

| Strategy  | Description             | Pros                  | Cons             |
| --------- | ----------------------- | --------------------- | ---------------- |
| Range     | Shard by value range    | Simple, range queries | Hotspots         |
| Hash      | Shard by hash value     | Even distribution     | No range queries |
| Directory | Lookup table for shards | Flexible              | Extra lookup     |

| 策略 | 描述         | 优点           | 缺点       |
| ---- | ------------ | -------------- | ---------- |
| 范围 | 按值范围分片 | 简单，范围查询 | 热点       |
| 哈希 | 按哈希值分片 | 均匀分布       | 无范围查询 |
| 目录 | 分片查找表   | 灵活           | 额外查找   |

### 6.2 Data Warehouse Schema Design
### 6.2 数据仓库模式设计

#### 6.2.1 Star Schema
#### 6.2.1 星型模式

**Structure:**
**结构：**

```
        ┌──────────────┐
        │  dim_time   │
        │  时间维度   │
        └──────┬───────┘
               │
┌─────────┐    │    ┌───────────┐
│dim_product│───▼────│dim_customer│
│ 产品维度  │ ┌────────┐ │  客户维度  │
└────┬────┘ │ FACT  │ └─────┬─────┘
     │       │ SALES │       │
     └──────▶│ 销售事实│◀──────┘
               └───┬────┘
               │
        ┌──────▼───────┐
        │  dim_store  │
        │  门店维度   │
        └──────────────┘
```

```sql
-- Fact Table (事实表)
CREATE TABLE fact_sales (
    sale_id INT PRIMARY KEY,
    date_key INT REFERENCES dim_date,
    product_key INT REFERENCES dim_product,
    customer_key INT REFERENCES dim_customer,
    store_key INT REFERENCES dim_store,
    quantity INT,
    amount DECIMAL(15,2),
    discount DECIMAL(10,2)
);

-- Dimension Table (维度表)
CREATE TABLE dim_product (
    product_key INT PRIMARY KEY,
    product_id VARCHAR(20),
    product_name VARCHAR(100),
    category VARCHAR(50),
    subcategory VARCHAR(50),
    brand VARCHAR(50)
);
```

#### 6.2.2 Snowflake Schema
#### 6.2.2 雪花模式

**Structure:** Normalized dimensions with sub-dimensions.
**结构：** 规范化的维度和子维度。

```sql
-- Snowflake: Normalized Product Dimension
-- 雪花模式：规范化的产品维度

CREATE TABLE dim_product (
    product_key INT PRIMARY KEY,
    product_name VARCHAR(100),
    subcategory_key INT REFERENCES dim_subcategory
);

CREATE TABLE dim_subcategory (
    subcategory_key INT PRIMARY KEY,
    subcategory_name VARCHAR(50),
    category_key INT REFERENCES dim_category
);

CREATE TABLE dim_category (
    category_key INT PRIMARY KEY,
    category_name VARCHAR(50)
);
```

**Star vs Snowflake:**
**星型与雪花对比：**

| Aspect                | Star Schema          | Snowflake Schema    |
| --------------------- | -------------------- | ------------------- |
| **Structure**         | Denormalized         | Normalized          |
| **Query Performance** | Faster (fewer joins) | Slower (more joins) |
| **Storage**           | More space           | Less space          |
| **Maintenance**       | Easier               | More complex        |
| **Use Case**          | OLAP queries         | Storage-constrained |

| 方面         | 星型模式       | 雪花模式       |
| ------------ | -------------- | -------------- |
| **结构**     | 反规范化       | 规范化         |
| **查询性能** | 更快（连接少） | 较慢（连接多） |
| **存储**     | 更多空间       | 更少空间       |
| **维护**     | 更简单         | 更复杂         |
| **应用场景** | OLAP查询       | 存储受限       |

### 6.3 NoSQL Schema Design
### 6.3 NoSQL数据库模式设计

**Schema-less vs Schema-on-Read:**
**无模式与读时模式：**

| Database Type | Schema Approach | Example   |
| ------------- | --------------- | --------- |
| Document      | Schema-on-read  | MongoDB   |
| Key-Value     | Schema-less     | Redis     |
| Wide Column   | Column families | Cassandra |
| Graph         | Nodes and edges | Neo4j     |

| 数据库类型 | 模式方法 | 示例      |
| ---------- | -------- | --------- |
| 文档型     | 读时模式 | MongoDB   |
| 键值型     | 无模式   | Redis     |
| 宽列型     | 列族     | Cassandra |
| 图数据库   | 节点和边 | Neo4j     |

**Document Database Example (MongoDB):**
**文档数据库示例（MongoDB）：**

```javascript
// Embedded Document (嵌入文档)
db.orders.insertOne({
  order_id: "ORD001",
  customer: {
    name: "John Doe",
    email: "john@example.com",
    address: {
      street: "123 Main St",
      city: "Beijing"
    }
  },
  items: [
    { product_id: "P001", name: "Laptop", quantity: 1, price: 999.00 },
    { product_id: "P002", name: "Mouse", quantity: 2, price: 29.99 }
  ],
  total: 1058.98,
  order_date: new Date()
});

// Reference Pattern (引用模式)
db.orders.insertOne({
  order_id: "ORD002",
  customer_id: ObjectId("..."),  // Reference
  items: [
    { product_id: ObjectId("..."), quantity: 1 }
  ]
});
```

**Wide Column Example (Cassandra):**
**宽列示例（Cassandra）：**

```cql
-- Cassandra Table (Query-Driven Design)
-- Cassandra表（查询驱动设计）
CREATE TABLE user_activities (
    user_id UUID,
    activity_date DATE,
    activity_time TIMESTAMP,
    activity_type TEXT,
    details MAP<TEXT, TEXT>,
    PRIMARY KEY ((user_id), activity_date, activity_time)
) WITH CLUSTERING ORDER BY (activity_date DESC, activity_time DESC);
```

### 6.4 Schema Evolution and Online DDL
### 6.4 模式演化和在线DDL

**Online DDL Techniques:**
**在线DDL技术：**

**1. Ghost Tables (pt-online-schema-change):**
**1. 幽灵表（pt-online-schema-change）：**

```bash
# Percona Tool for Online Schema Change
pt-online-schema-change \
  --alter "ADD COLUMN new_col VARCHAR(100)" \
  D=mydb,t=mytable \
  --execute
```

**2. MySQL 8.0+ Online DDL:**
**2. MySQL 8.0+在线DDL：**

```sql
-- Instant ADD COLUMN (MySQL 8.0)
-- 即时添加列（MySQL 8.0）
ALTER TABLE employees 
    ADD COLUMN notes VARCHAR(500), 
    ALGORITHM=INSTANT;

-- Online Index Creation
-- 在线创建索引
ALTER TABLE employees 
    ADD INDEX idx_name (last_name),
    ALGORITHM=INPLACE,
    LOCK=NONE;
```

**3. PostgreSQL Concurrent Operations:**
**3. PostgreSQL并发操作：**

```sql
-- Concurrent Index Creation
-- 并发创建索引
CREATE INDEX CONCURRENTLY idx_email ON users(email);

-- Add Column with Default (no table rewrite in PG 11+)
-- 添加带默认值的列（PG 11+无需重写表）
ALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'active';
```

**Schema Evolution Best Practices:**
**模式演化最佳实践：**

1. **Backward Compatible Changes**
1. **向后兼容的更改**
   - Add nullable columns
   - 添加可空列
   - Add new tables
   - 添加新表
   - Add indexes
   - 添加索引

2. **Avoid Breaking Changes**
2. **避免破坏性更改**
   - Don't rename columns
   - 不要重命名列
   - Don't change data types
   - 不要更改数据类型
   - Don't drop columns immediately
   - 不要立即删除列

3. **Multi-Phase Migration**
3. **多阶段迁移**
   - Phase 1: Add new column
   - 阶段1：添加新列
   - Phase 2: Backfill data
   - 阶段2：回填数据
   - Phase 3: Update application
   - 阶段3：更新应用程序
   - Phase 4: Drop old column
   - 阶段4：删除旧列

## Conclusion
## 结论

Database schema design is a critical skill for architects and developers, directly impacting application performance, data integrity, and system maintainability. Understanding the principles of schema architecture, normalization theory, and practical design patterns enables building robust and scalable data solutions.

数据库模式设计是架构师和开发人员的关键技能，直接影响应用性能、数据完整性和系统可维护性。理解模式架构、规范化理论和实用设计模式的原理，能够构建健壮和可扩展的数据解决方案。

**Key Takeaways:**
**关键要点：**

1. **Three-Schema Architecture**: External, Conceptual, and Internal schemas provide data independence
1. **三级模式架构**：外模式、概念模式和内模式提供数据独立性

2. **Normalization**: Apply 3NF/BCNF for OLTP, consider denormalization for OLAP
2. **规范化**：OLTP应用3NF/BCNF，OLAP考虑反规范化

3. **Physical Design**: Index selection and partitioning are critical for performance
3. **物理设计**：索引选择和分区对性能至关重要

4. **Constraints**: Use database constraints to enforce data integrity
4. **约束**：使用数据库约束执行数据完整性

5. **Schema Evolution**: Plan for schema changes with backward compatibility
5. **模式演化**：计划向后兼容的模式更改

6. **Modern Approaches**: Consider NoSQL for specific use cases and polyglot persistence
6. **现代方法**：特定用例考虑NoSQL和多语言持久化

---

## References and Further Reading
## 参考资料与延伸阅读

**Books:**
**书籍：**
- "Database System Concepts" by Silberschatz, Korth, Sudarshan
- "Fundamentals of Database Systems" by Elmasri and Navathe
- "SQL and Relational Theory" by C.J. Date
- "Designing Data-Intensive Applications" by Martin Kleppmann

**Standards:**
**标准：**
- ANSI/SPARC Three-Schema Architecture
- ANSI/SPARC三级模式架构
- SQL Standard (ISO/IEC 9075)
- SQL标准（ISO/IEC 9075）
- ACID Properties
- ACID属性

**Online Resources:**
**在线资源：**
- PostgreSQL Documentation
- PostgreSQL文档
- MySQL Reference Manual
- MySQL参考手册
- Oracle Database Concepts
- Oracle数据库概念
- MongoDB Schema Design Patterns
- MongoDB模式设计模式