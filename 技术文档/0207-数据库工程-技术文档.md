# Database Engineering
# 数据库工程

## 1. Database Engineering Overview
## 1. 数据库工程概述

### 1.1 Definition and Characteristics
### 1.1 定义和特点

**Definition:** Database Engineering is the systematic application of engineering principles, methods, and tools to the design, implementation, testing, and maintenance of database systems to ensure quality, reliability, and efficiency.

**定义：** 数据库工程是系统地应用工程原理、方法和工具来设计、实现、测试和维护数据库系统，以确保质量、可靠性和效率。

**Key Characteristics:**
**关键特点：**

- **Systematic Approach**: Follows structured methodologies
- **系统化方法**：遵循结构化方法论
- **Lifecycle Management**: Covers entire database lifecycle
- **生命周期管理**：涵盖整个数据库生命周期
- **Quality Focus**: Emphasizes quality assurance
- **质量关注**：强调质量保证
- **Documentation**: Comprehensive documentation
- **文档化**：全面的文档记录
- **Team Collaboration**: Multi-disciplinary teamwork
- **团队协作**：多学科团队合作

### 1.2 Database Lifecycle
### 1.2 数据库生命周期

**Phases:**
**阶段：**

```
┌─────────────────────────────────────────────────────────────┐
│                  Database Lifecycle                         │
│                    数据库生命周期                              │
└─────────────────────────────────────────────────────────────┘

1. Planning          2. Requirements    3. Conceptual      4. Logical
   规划                 需求分析             概念设计           逻辑设计
   │                   │                  │                 │
   ▼                   ▼                  ▼                 ▼
┌────────┐         ┌────────┐        ┌────────┐        ┌────────┐
│Initiate│────────▶│Analyze │───────▶│E-R     │───────▶│Schema  │
│Project │         │Require │        │Model   │        │Design  │
└────────┘         └────────┘        └────────┘        └────────┘

5. Physical          6. Implementation  7. Testing         8. Operation
   物理设计             实施                测试              运维
   │                   │                  │                 │
   ▼                   ▼                  ▼                 ▼
┌────────┐         ┌────────┐        ┌────────┐        ┌────────┐
│Storage │────────▶│Create  │───────▶│Verify  │───────▶│Monitor │
│Design  │         │Database│        │Quality │        │Maintain│
└────────┘         └────────┘        └────────┘        └────────┘
```

**Lifecycle Phases:**
**生命周期阶段：**

| Phase                 | Objectives                         | Deliverables            |
| --------------------- | ---------------------------------- | ----------------------- |
| **Planning**          | Define scope and feasibility       | Project plan, budget    |
| **Requirements**      | Identify data and functional needs | Requirements document   |
| **Conceptual Design** | Create high-level data model       | E-R diagram             |
| **Logical Design**    | Transform to relational schema     | Normalized tables       |
| **Physical Design**   | Optimize for performance           | Storage design, indexes |
| **Implementation**    | Build and populate database        | Working database        |
| **Testing**           | Verify quality and performance     | Test reports            |
| **Operation**         | Maintain and enhance               | Monitoring reports      |

| 阶段         | 目标               | 交付物         |
| ------------ | ------------------ | -------------- |
| **规划**     | 定义范围和可行性   | 项目计划、预算 |
| **需求分析** | 识别数据和功能需求 | 需求文档       |
| **概念设计** | 创建高层数据模型   | E-R图          |
| **逻辑设计** | 转换为关系模式     | 规范化表       |
| **物理设计** | 性能优化           | 存储设计、索引 |
| **实施**     | 构建和填充数据库   | 工作数据库     |
| **测试**     | 验证质量和性能     | 测试报告       |
| **运维**     | 维护和增强         | 监控报告       |

### 1.3 Development Methodologies
### 1.3 开发方法论

#### 1.3.1 Waterfall Model
#### 1.3.1 瀑布模型

**Characteristics:**
**特点：**

- Sequential phases
- 顺序阶段
- Complete each phase before next
- 完成一个阶段再进入下一个
- Extensive documentation
- 大量文档
- Works well for stable requirements
- 适合需求稳定的项目

```
Requirements ────▶ Design ────▶ Implementation ────▶ Testing ────▶ Deployment
需求分析          设计         实施                  测试         部署
```

**Pros:**
**优点：**
- Clear milestones
- 清晰的里程碑
- Easy to manage
- 易于管理
- Well-documented
- 文档完善

**Cons:**
**缺点：**
- Inflexible to changes
- 对变更不灵活
- Late discovery of issues
- 问题发现较晚
- Long delivery time
- 交付时间长

#### 1.3.2 Iterative and Incremental Model
#### 1.3.2 迭代增量模型

**Characteristics:**
**特点：**

- Multiple cycles of development
- 多轮开发循环
- Each iteration adds functionality
- 每次迭代增加功能
- Early and continuous feedback
- 早期和持续反馈
- Risk mitigation through iterations
- 通过迭代降低风险

```
Iteration 1: Core Tables ────▶ Deploy
迭代1：核心表

Iteration 2: Add Features ────▶ Deploy
迭代2：添加功能

Iteration 3: Optimization ────▶ Deploy
迭代3：优化
```

#### 1.3.3 Agile Database Development
#### 1.3.3 敏捷数据库开发

**Principles:**
**原则：**

- **Embrace Change**: Adapt to evolving requirements
- **拥抱变化**：适应不断演变的需求
- **Continuous Integration**: Frequent database changes
- **持续集成**：频繁的数据库变更
- **Automated Testing**: Test database changes
- **自动化测试**：测试数据库变更
- **Evolutionary Design**: Refactor as needed
- **演进式设计**：根据需要重构
- **Collaboration**: Close cooperation with stakeholders
- **协作**：与利益相关者密切合作

**Agile Practices:**
**敏捷实践：**

```
┌─────────────────────────────────────┐
│        Sprint Planning              │
│         冲刺计划                      │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│    Daily Standup                    │
│     每日站会                          │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  Development & Testing              │
│    开发与测试                         │
│  - Schema changes                   │
│    模式变更                           │
│  - Migration scripts                │
│    迁移脚本                           │
│  - Automated tests                  │
│    自动化测试                         │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│    Sprint Review & Retrospective    │
│     冲刺评审与回顾                     │
└─────────────────────────────────────┘
```

### 1.4 Database Engineering vs Software Engineering
### 1.4 数据库工程与软件工程的关系

**Similarities:**
**相似之处：**

- Both follow systematic methodologies
- 都遵循系统化方法
- Quality assurance is critical
- 质量保证至关重要
- Require documentation
- 需要文档记录
- Version control and testing
- 版本控制和测试

**Differences:**
**差异：**

| Aspect        | Database Engineering     | Software Engineering |
| ------------- | ------------------------ | -------------------- |
| **Focus**     | Data and structure       | Logic and behavior   |
| **Longevity** | Long-lived, stable       | Frequent updates     |
| **Changes**   | Schema changes costly    | Code changes easier  |
| **State**     | Stateful (data persists) | Often stateless      |
| **Testing**   | Data integrity focus     | Functional focus     |

| 方面       | 数据库工程         | 软件工程     |
| ---------- | ------------------ | ------------ |
| **关注点** | 数据和结构         | 逻辑和行为   |
| **寿命**   | 长期、稳定         | 频繁更新     |
| **变更**   | 模式变更成本高     | 代码变更容易 |
| **状态**   | 有状态（数据持久） | 通常无状态   |
| **测试**   | 数据完整性关注     | 功能关注     |

## 2. Requirements Analysis
## 2. 需求分析

### 2.1 Requirements Gathering Methods
### 2.1 需求收集方法

**Techniques:**
**技术：**

**1. Interviews (访谈)**
- One-on-one discussions with stakeholders
- 与利益相关者一对一讨论
- Understand business processes
- 理解业务流程
- Identify pain points
- 识别痛点

**2. Questionnaires (问卷调查)**
- Structured questions for large groups
- 针对大群体的结构化问题
- Quantitative data collection
- 定量数据收集
- Statistical analysis
- 统计分析

**3. Document Analysis (文档分析)**
- Review existing documentation
- 审查现有文档
- Forms, reports, policies
- 表单、报告、政策
- Legacy system analysis
- 遗留系统分析

**4. Observation (观察)**
- Watch users perform tasks
- 观察用户执行任务
- Understand actual workflows
- 理解实际工作流程
- Identify implicit requirements
- 识别隐含需求

**5. Prototyping (原型)**
- Build mockups or prototypes
- 构建模型或原型
- Gather feedback early
- 早期收集反馈
- Refine requirements
- 细化需求

### 2.2 Data Requirements Analysis
### 2.2 数据需求分析

**Key Questions:**
**关键问题：**

```
What data needs to be stored?
需要存储什么数据？

Who will use the data?
谁将使用数据？

How will the data be used?
数据将如何使用？

What relationships exist between data?
数据之间存在什么关系？

What are the data quality requirements?
数据质量要求是什么？
```

**Data Analysis Steps:**
**数据分析步骤：**

1. **Identify Entities (识别实体)**
   - Major business objects
   - 主要业务对象
   - Example: Customer, Order, Product
   - 示例：客户、订单、产品

2. **Define Attributes (定义属性)**
   - Properties of entities
   - 实体的属性
   - Example: Customer (name, email, phone)
   - 示例：客户（姓名、电子邮件、电话）

3. **Determine Relationships (确定关系)**
   - How entities connect
   - 实体如何连接
   - Cardinality (1:1, 1:N, M:N)
   - 基数（1:1、1:N、M:N）

4. **Identify Business Rules (识别业务规则)**
   - Constraints and validations
   - 约束和验证
   - Example: "Order total must be positive"
   - 示例："订单总额必须为正"

### 2.3 Functional and Non-Functional Requirements
### 2.3 功能需求与非功能需求

**Functional Requirements:**
**功能需求：**

- **CRUD Operations**: Create, Read, Update, Delete
- **CRUD操作**：创建、读取、更新、删除
- **Business Logic**: Rules and workflows
- **业务逻辑**：规则和工作流程
- **Reports**: Required reports and queries
- **报表**：所需报表和查询
- **Data Processing**: Batch jobs, calculations
- **数据处理**：批处理作业、计算

**Example:**
**示例：**

```
FR-001: System shall allow users to create new customer records
FR-001：系统应允许用户创建新客户记录

FR-002: System shall generate monthly sales reports
FR-002：系统应生成月度销售报告

FR-003: System shall validate email addresses
FR-003：系统应验证电子邮件地址
```

**Non-Functional Requirements:**
**非功能需求：**

| Category            | Requirement                | Example            |
| ------------------- | -------------------------- | ------------------ |
| **Performance**     | Response time, throughput  | Query < 2 seconds  |
| **Scalability**     | Growth capacity            | Support 1M users   |
| **Availability**    | Uptime                     | 99.9% availability |
| **Security**        | Access control, encryption | Role-based access  |
| **Reliability**     | Error rate, MTBF           | < 0.1% error rate  |
| **Maintainability** | Ease of updates            | Schema versioning  |

| 类别         | 需求             | 示例           |
| ------------ | ---------------- | -------------- |
| **性能**     | 响应时间、吞吐量 | 查询 < 2秒     |
| **可扩展性** | 增长能力         | 支持100万用户  |
| **可用性**   | 正常运行时间     | 99.9%可用性    |
| **安全性**   | 访问控制、加密   | 基于角色的访问 |
| **可靠性**   | 错误率、MTBF     | < 0.1%错误率   |
| **可维护性** | 更新便利性       | 模式版本控制   |

### 2.4 Requirements Documentation
### 2.4 需求文档编写

**Requirements Document Template:**
**需求文档模板：**

```markdown
# Database Requirements Specification
# 数据库需求规格说明

## 1. Introduction (简介)
   1.1 Purpose (目的)
   1.2 Scope (范围)
   1.3 Definitions (定义)

## 2. Overall Description (总体描述)
   2.1 System Context (系统上下文)
   2.2 User Characteristics (用户特征)
   2.3 Assumptions and Dependencies (假设和依赖)

## 3. Data Requirements (数据需求)
   3.1 Entity List (实体列表)
   3.2 Attribute Descriptions (属性描述)
   3.3 Relationship Definitions (关系定义)
   3.4 Business Rules (业务规则)

## 4. Functional Requirements (功能需求)
   4.1 User Functions (用户功能)
   4.2 Data Operations (数据操作)
   4.3 Reports and Queries (报表和查询)

## 5. Non-Functional Requirements (非功能需求)
   5.1 Performance (性能)
   5.2 Security (安全)
   5.3 Availability (可用性)
   5.4 Scalability (可扩展性)

## 6. Constraints (约束)
   6.1 Technical Constraints (技术约束)
   6.2 Business Constraints (业务约束)
   6.3 Regulatory Constraints (监管约束)
```

## 3. Conceptual Design
## 3. 概念设计

### 3.1 E-R Modeling Method
### 3.1 E-R建模方法

**Entity-Relationship Model Components:**
**实体-关系模型组件：**

**1. Entity (实体)**

```
┌─────────────────┐
│    Customer     │  ← Rectangle represents entity
│      客户       │     矩形表示实体
└─────────────────┘
```

**2. Attribute (属性)**

```
  ┌──────────────┐
  │ customer_id  │  ← Ellipse represents attribute
  └──────────────┘     椭圆表示属性
```

**3. Relationship (关系)**

```
        Places (下订单)
   ◇  ← Diamond represents relationship
       菱形表示关系
```

**4. Cardinality (基数)**

```
1        M
Customer ────◇──── Order
客户           下订单   订单

One customer can place many orders
一个客户可以下多个订单
```

### 3.2 Identifying Entities, Attributes, and Relationships
### 3.2 实体、属性和关系识别

**Entity Identification Guidelines:**
**实体识别指南：**

✓ **Is an Entity:**
✓ **是实体：**
- Has multiple instances
- 有多个实例
- Has distinct identity
- 有独特标识
- Has attributes
- 有属性
- Example: Customer, Product, Order
- 示例：客户、产品、订单

✗ **Not an Entity:**
✗ **不是实体：**
- Single occurrence
- 单次出现
- No independent existence
- 没有独立存在
- Example: "Phone Number" (attribute of Customer)
- 示例："电话号码"（客户的属性）

**Attribute Types:**
**属性类型：**

| Type              | Description       | Example                |
| ----------------- | ----------------- | ---------------------- |
| **Simple**        | Cannot be divided | Age, Salary            |
| **Composite**     | Can be divided    | Address (street, city) |
| **Single-valued** | One value         | Employee ID            |
| **Multi-valued**  | Multiple values   | Phone numbers          |
| **Derived**       | Calculated        | Age (from birthdate)   |

| 类型     | 描述     | 示例               |
| -------- | -------- | ------------------ |
| **简单** | 不可分割 | 年龄、工资         |
| **复合** | 可分割   | 地址（街道、城市） |
| **单值** | 一个值   | 员工ID             |
| **多值** | 多个值   | 电话号码           |
| **派生** | 计算得出 | 年龄（从生日计算） |

### 3.3 Conceptual Model Design Principles
### 3.3 概念模型设计原则

**Design Principles:**
**设计原则：**

**1. Completeness (完整性)**
- Capture all required data
- 捕获所有必需数据
- Include all entities and relationships
- 包含所有实体和关系

**2. Correctness (正确性)**
- Accurately represent business reality
- 准确表示业务现实
- No logical contradictions
- 无逻辑矛盾

**3. Simplicity (简单性)**
- Easy to understand
- 易于理解
- Avoid unnecessary complexity
- 避免不必要的复杂性

**4. Flexibility (灵活性)**
- Accommodate future changes
- 适应未来变化
- Extensible design
- 可扩展设计

**5. Integration (集成性)**
- Consistent across modules
- 模块间一致
- No redundant entities
- 无冗余实体

**Example E-R Diagram:**
**示例E-R图：**

```
┌──────────┐           ┌──────────┐           ┌──────────┐
│ Customer │           │  Order   │           │ Product  │
│   客户   │           │   订单   │           │   产品   │
└─────┬────┘           └────┬─────┘           └────┬─────┘
      │                     │                      │
      │  1            Places│  M            Contains│
      │                 下订单│                  包含 │
      │                     │                      │
      └───────────◇─────────┘                      │
                              M                    │  M
                               └─────────◇─────────┘
                                     包含
```

### 3.4 UML and Data Modeling
### 3.4 UML与数据建模

**UML Class Diagram for Data Modeling:**
**用于数据建模的UML类图：**

```
┌─────────────────────────┐
│      Customer           │
│        客户             │
├─────────────────────────┤
│ - customerId: int       │
│ - name: string          │
│ - email: string         │
│ - phone: string         │
├─────────────────────────┤
│ + placeOrder()          │
│ + updateProfile()       │
└───────────┬─────────────┘
            │ 1
            │ places (下订单)
            │
            │ *
┌───────────▼─────────────┐
│       Order             │
│        订单             │
├─────────────────────────┤
│ - orderId: int          │
│ - orderDate: date       │
│ - totalAmount: decimal  │
├─────────────────────────┤
│ + calculateTotal()      │
│ + cancel()              │
└─────────────────────────┘
```

**UML vs E-R:**
**UML与E-R对比：**

| Aspect       | E-R Diagram        | UML Class Diagram       |
| ------------ | ------------------ | ----------------------- |
| **Purpose**  | Data structure     | Object-oriented design  |
| **Focus**    | Data relationships | Classes and methods     |
| **Notation** | Entity, Attribute  | Class, Property, Method |
| **Usage**    | Database design    | Software design         |

| 方面       | E-R图      | UML类图        |
| ---------- | ---------- | -------------- |
| **目的**   | 数据结构   | 面向对象设计   |
| **关注点** | 数据关系   | 类和方法       |
| **符号**   | 实体、属性 | 类、属性、方法 |
| **用途**   | 数据库设计 | 软件设计       |

## 4. Logical Design
## 4. 逻辑设计

### 4.1 E-R to Relational Schema Transformation
### 4.1 E-R模型到关系模式的转换

**Transformation Rules:**
**转换规则：**

**Rule 1: Entity to Table**
**规则1：实体转为表**

```
E-R:                    Relational:
┌──────────┐           CREATE TABLE Customer (
│ Customer │              customer_id INT PRIMARY KEY,
└──────────┘              name VARCHAR(100),
                          email VARCHAR(100)
                       );
```

**Rule 2: 1:N Relationship**
**规则2：一对多关系**

```
Customer (1) ────── (N) Order

Solution: Add foreign key in "many" side
解决方案：在"多"方添加外键

CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    order_date DATE
);
```

**Rule 3: M:N Relationship**
**规则3：多对多关系**

```
Student (M) ────── (N) Course

Solution: Create junction table
解决方案：创建连接表

CREATE TABLE enrollments (
    student_id INT REFERENCES students(student_id),
    course_id INT REFERENCES courses(course_id),
    enrollment_date DATE,
    grade CHAR(1),
    PRIMARY KEY (student_id, course_id)
);
```

**Rule 4: 1:1 Relationship**
**规则4：一对一关系**

```
Person (1) ────── (1) Passport

Solution: Merge into one table OR add foreign key
解决方案：合并为一个表或添加外键

-- Option 1: Merge (合并)
CREATE TABLE persons (
    person_id INT PRIMARY KEY,
    name VARCHAR(100),
    passport_number VARCHAR(20) UNIQUE
);

-- Option 2: Separate with FK (分离并使用外键)
CREATE TABLE passports (
    passport_number VARCHAR(20) PRIMARY KEY,
    person_id INT UNIQUE REFERENCES persons(person_id)
);
```

**Rule 5: Multi-valued Attribute**
**规则5：多值属性**

```
Employee with multiple phone numbers (员工有多个电话号码)

Solution: Create separate table
解决方案：创建单独的表

CREATE TABLE employee_phones (
    employee_id INT REFERENCES employees(employee_id),
    phone_number VARCHAR(20),
    phone_type VARCHAR(10),  -- mobile, home, work
    PRIMARY KEY (employee_id, phone_number)
);
```

### 4.2 Normalization Design
### 4.2 规范化设计

**Normalization Process:**
**规范化过程：**

**Step 1: Unnormalized (未规范化)**

```
┌──────────┬────────┬─────────────────────────┐
│ order_id │customer│ items                   │
├──────────┼────────┼─────────────────────────┤
│ 1001     │ John   │ Laptop:999, Mouse:29    │
└──────────┴────────┴─────────────────────────┘

Problem: Repeating groups (重复组)
```

**Step 2: First Normal Form (1NF)**

```
┌──────────┬────────┬─────────┬───────┐
│ order_id │customer│ product │ price │
├──────────┼────────┼─────────┼───────┤
│ 1001     │ John   │ Laptop  │ 999   │
│ 1001     │ John   │ Mouse   │ 29    │
└──────────┴────────┴─────────┴───────┘

Achievement: Atomic values (原子值)
Problem: Partial dependency (部分依赖)
```

**Step 3: Second Normal Form (2NF)**

```
Orders:                    Order_Items:
┌──────────┬────────┐     ┌──────────┬─────────┬───────┐
│ order_id │customer│     │ order_id │ product │ price │
├──────────┼────────┤     ├──────────┼─────────┼───────┤
│ 1001     │ John   │     │ 1001     │ Laptop  │ 999   │
└──────────┴────────┘     │ 1001     │ Mouse   │ 29    │
                          └──────────┴─────────┴───────┘

Achievement: No partial dependencies (无部分依赖)
Problem: Transitive dependency (传递依赖)
```

**Step 4: Third Normal Form (3NF)**

```
Orders:                 Customers:              Order_Items:
┌──────────┬──────┐    ┌──────┬────────┐      ┌──────────┬────────┐
│ order_id │cust_id│    │cust_id│customer│      │ order_id │prod_id │
├──────────┼──────┤    ├──────┼────────┤      ├──────────┼────────┤
│ 1001     │ 101  │    │ 101  │ John   │      │ 1001     │ 201    │
└──────────┴──────┘    └──────┴────────┘      │ 1001     │ 202    │
                                               └──────────┴────────┘

Products:
┌────────┬─────────┬───────┐
│ prod_id│ product │ price │
├────────┼─────────┼───────┤
│ 201    │ Laptop  │ 999   │
│ 202    │ Mouse   │ 29    │
└────────┴─────────┴───────┘

Achievement: No transitive dependencies (无传递依赖)
```

### 4.3 Data Integrity Constraints
### 4.3 数据完整性约束设计

**Constraint Types:**
**约束类型：**

**1. Domain Constraints (域约束)**

```sql
CREATE TABLE employees (
    employee_id INT,
    age INT CHECK (age BETWEEN 18 AND 65),
    email VARCHAR(100) CHECK (email LIKE '%@%.%'),
    salary DECIMAL(10,2) CHECK (salary > 0),
    status VARCHAR(20) CHECK (status IN ('Active', 'Inactive', 'On Leave'))
);
```

**2. Entity Integrity (实体完整性)**

```sql
-- Primary key cannot be NULL
-- 主键不能为NULL
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,  -- NOT NULL automatically
    dept_name VARCHAR(100) NOT NULL
);
```

**3. Referential Integrity (参照完整性)**

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
        ON DELETE RESTRICT      -- Prevent deletion
        ON UPDATE CASCADE       -- Cascade updates
);
```

**4. Business Rules (业务规则)**

```sql
-- Complex constraint using trigger
-- 使用触发器的复杂约束
CREATE TRIGGER check_credit_limit
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
    DECLARE customer_balance DECIMAL(10,2);
    
    SELECT SUM(total_amount) INTO customer_balance
    FROM orders
    WHERE customer_id = NEW.customer_id
      AND status = 'Pending';
    
    IF customer_balance + NEW.total_amount > 10000 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Credit limit exceeded';
    END IF;
END;
```

### 4.4 View Design
### 4.4 视图设计

**View Design Purposes:**
**视图设计目的：**

**1. Security (安全性)**

```sql
-- Hide sensitive salary data
-- 隐藏敏感的工资数据
CREATE VIEW public_employee_info AS
SELECT 
    employee_id,
    first_name,
    last_name,
    department_id,
    hire_date
FROM employees;
-- Salary column excluded (排除工资列)
```

**2. Simplification (简化)**

```sql
-- Simplify complex joins
-- 简化复杂连接
CREATE VIEW employee_details AS
SELECT 
    e.employee_id,
    e.first_name || ' ' || e.last_name AS full_name,
    d.department_name,
    l.city AS location,
    j.job_title,
    e.salary
FROM employees e
JOIN departments d ON e.department_id = d.department_id
JOIN locations l ON d.location_id = l.location_id
JOIN jobs j ON e.job_id = j.job_id;
```

**3. Data Aggregation (数据聚合)**

```sql
-- Pre-calculate aggregations
-- 预先计算聚合
CREATE VIEW department_statistics AS
SELECT 
    department_id,
    COUNT(*) AS employee_count,
    AVG(salary) AS avg_salary,
    MIN(salary) AS min_salary,
    MAX(salary) AS max_salary
FROM employees
GROUP BY department_id;
```

## 5. Physical Design
## 5. 物理设计

### 5.1 Storage Structure Design
### 5.1 存储结构设计

**Storage Considerations:**
**存储考虑因素：**

**1. File Organization (文件组织)**

```sql
-- Table with specific storage parameters
-- 具有特定存储参数的表
CREATE TABLE large_transactions (
    transaction_id BIGINT PRIMARY KEY,
    transaction_date DATE,
    amount DECIMAL(15,2),
    description TEXT
)
PARTITION BY RANGE (transaction_date)
TABLESPACE fast_ssd
WITH (
    fillfactor = 80,          -- Leave 20% free for updates
    autovacuum_enabled = true -- Automatic cleanup
);
```

**2. Row vs Column Storage (行存储vs列存储)**

| Storage Type     | Best For               | Example              |
| ---------------- | ---------------------- | -------------------- |
| **Row Store**    | OLTP, frequent updates | PostgreSQL (default) |
| **Column Store** | OLAP, analytics        | Redshift, Vertica    |

| 存储类型   | 最适合         | 示例               |
| ---------- | -------------- | ------------------ |
| **行存储** | OLTP、频繁更新 | PostgreSQL（默认） |
| **列存储** | OLAP、分析     | Redshift、Vertica  |

### 5.2 Index Design Strategy
### 5.2 索引设计策略

**Index Selection Criteria:**
**索引选择标准：**

```sql
-- 1. Primary Key Index (automatic)
-- 1. 主键索引（自动）
CREATE TABLE products (
    product_id INT PRIMARY KEY  -- B-tree index created automatically
);

-- 2. Index on Foreign Keys (recommended)
-- 2. 外键索引（推荐）
CREATE INDEX idx_order_customer 
ON orders(customer_id);

-- 3. Index on Frequently Queried Columns
-- 3. 频繁查询列的索引
CREATE INDEX idx_order_date 
ON orders(order_date);

-- 4. Composite Index for Multi-Column Queries
-- 4. 多列查询的复合索引
CREATE INDEX idx_emp_dept_salary 
ON employees(department_id, salary DESC);

-- 5. Partial Index for Specific Conditions
-- 5. 特定条件的部分索引
CREATE INDEX idx_active_users 
ON users(email) 
WHERE status = 'active';

-- 6. Full-Text Index for Search
-- 6. 搜索的全文索引
CREATE FULLTEXT INDEX idx_product_search 
ON products(name, description);
```

**Index Trade-offs:**
**索引权衡：**

| Benefit                   | Cost                        |
| ------------------------- | --------------------------- |
| Faster SELECT queries     | Slower INSERT/UPDATE/DELETE |
| Improved JOIN performance | Additional storage space    |
| Efficient sorting         | Index maintenance overhead  |

| 优点             | 代价                       |
| ---------------- | -------------------------- |
| 更快的SELECT查询 | 更慢的INSERT/UPDATE/DELETE |
| 改进的JOIN性能   | 额外的存储空间             |
| 高效排序         | 索引维护开销               |

### 5.3 Partitioning and Sharding Design
### 5.3 分区和分表设计

**Partitioning Strategies:**
**分区策略：**

```sql
-- Range Partitioning by Date
-- 按日期范围分区
CREATE TABLE sales (
    sale_id BIGINT,
    sale_date DATE,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (sale_date);

CREATE TABLE sales_2023 PARTITION OF sales
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

CREATE TABLE sales_2024 PARTITION OF sales
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- List Partitioning by Region
-- 按区域列表分区
CREATE TABLE customers (
    customer_id INT,
    region VARCHAR(20),
    name VARCHAR(100)
) PARTITION BY LIST (region);

CREATE TABLE customers_asia PARTITION OF customers
    FOR VALUES IN ('China', 'Japan', 'Korea');

CREATE TABLE customers_europe PARTITION OF customers
    FOR VALUES IN ('UK', 'Germany', 'France');

-- Hash Partitioning for Even Distribution
-- 哈希分区以均匀分布
CREATE TABLE user_sessions (
    session_id BIGINT,
    user_id INT,
    login_time TIMESTAMP
) PARTITION BY HASH (user_id);

CREATE TABLE sessions_p0 PARTITION OF user_sessions
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);

CREATE TABLE sessions_p1 PARTITION OF user_sessions
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
```

**Sharding (Horizontal Partitioning Across Servers):**
**分片（跨服务器的水平分区）：**

```
Application Layer (应用层)
        │
        ├─────────┬─────────┬─────────┐
        ▼         ▼         ▼         ▼
    Shard 1   Shard 2   Shard 3   Shard 4
    分片1     分片2     分片3     分片4
    Users     Users     Users     Users
    1-250K   250K-500K 500K-750K 750K-1M
```

### 5.4 Performance Optimization Design
### 5.4 性能优化设计

**Optimization Techniques:**
**优化技术：**

**1. Denormalization for Read Performance**
**1. 读性能的反规范化**

```sql
-- Add redundant column to avoid joins
-- 添加冗余列以避免连接
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    customer_name VARCHAR(100),  -- Denormalized
    order_date DATE,
    total_amount DECIMAL(10,2)
);
```

**2. Materialized Views for Aggregations**
**2. 聚合的物化视图**

```sql
CREATE MATERIALIZED VIEW monthly_sales_summary AS
SELECT 
    DATE_TRUNC('month', order_date) AS month,
    department_id,
    SUM(total_amount) AS total_sales,
    COUNT(*) AS order_count
FROM orders
GROUP BY DATE_TRUNC('month', order_date), department_id;

-- Refresh periodically (定期刷新)
REFRESH MATERIALIZED VIEW monthly_sales_summary;
```

**3. Caching Strategy**
**3. 缓存策略**

```
Application (应用)
    ↓ Query (查询)
┌─────────────┐
│   Cache     │ ← Check first (先检查)
│   缓存      │
└─────────────┘
    ↓ Cache miss (缓存未命中)
┌─────────────┐
│  Database   │
│   数据库    │
└─────────────┘
```

**4. Query Optimization**
**4. 查询优化**

```sql
-- Bad: Full table scan
-- 差：全表扫描
SELECT * FROM orders WHERE YEAR(order_date) = 2024;

-- Good: Index-friendly
-- 好：索引友好
SELECT * FROM orders 
WHERE order_date >= '2024-01-01' 
  AND order_date < '2025-01-01';

-- Bad: Function on indexed column
-- 差：索引列上的函数
SELECT * FROM products WHERE UPPER(name) = 'LAPTOP';

-- Good: Use functional index or search value
-- 好：使用函数索引或搜索值
CREATE INDEX idx_product_name_upper ON products(UPPER(name));
```

## 6. Database Implementation
## 6. 数据库实施

### 6.1 Database Creation and Initialization
### 6.1 数据库创建和初始化

**Implementation Steps:**
**实施步骤：**

```sql
-- 1. Create Database
-- 1. 创建数据库
CREATE DATABASE company_db
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_unicode_ci;

USE company_db;

-- 2. Create Schemas/Namespaces
-- 2. 创建模式/命名空间
CREATE SCHEMA hr;
CREATE SCHEMA sales;
CREATE SCHEMA finance;

-- 3. Create Tables in Order (依次创建表)
-- Parent tables first (先创建父表)
CREATE TABLE hr.departments (
    dept_id INT PRIMARY KEY AUTO_INCREMENT,
    dept_name VARCHAR(100) NOT NULL,
    location VARCHAR(100)
);

-- Child tables with foreign keys (带外键的子表)
CREATE TABLE hr.employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    hire_date DATE NOT NULL,
    salary DECIMAL(10,2),
    dept_id INT,
    CONSTRAINT fk_emp_dept 
        FOREIGN KEY (dept_id) 
        REFERENCES hr.departments(dept_id)
);

-- 4. Create Indexes
-- 4. 创建索引
CREATE INDEX idx_emp_dept ON hr.employees(dept_id);
CREATE INDEX idx_emp_hire_date ON hr.employees(hire_date);

-- 5. Create Views
-- 5. 创建视图
CREATE VIEW hr.employee_directory AS
SELECT 
    emp_id,
    CONCAT(first_name, ' ', last_name) AS full_name,
    email,
    dept_name
FROM hr.employees e
JOIN hr.departments d ON e.dept_id = d.dept_id;

-- 6. Create Stored Procedures
-- 6. 创建存储过程
DELIMITER //
CREATE PROCEDURE hr.hire_employee(
    IN p_first_name VARCHAR(50),
    IN p_last_name VARCHAR(50),
    IN p_email VARCHAR(100),
    IN p_dept_id INT,
    OUT p_emp_id INT
)
BEGIN
    INSERT INTO hr.employees (first_name, last_name, email, hire_date, dept_id)
    VALUES (p_first_name, p_last_name, p_email, CURDATE(), p_dept_id);
    
    SET p_emp_id = LAST_INSERT_ID();
END //
DELIMITER ;

-- 7. Set Up Users and Permissions
-- 7. 设置用户和权限
CREATE USER 'hr_admin'@'localhost' IDENTIFIED BY 'secure_password';
GRANT ALL PRIVILEGES ON hr.* TO 'hr_admin'@'localhost';

CREATE USER 'hr_readonly'@'localhost' IDENTIFIED BY 'readonly_password';
GRANT SELECT ON hr.* TO 'hr_readonly'@'localhost';
```

### 6.2 Data Migration and Transformation
### 6.2 数据迁移和转换

**Migration Strategies:**
**迁移策略：**

**1. Big Bang Migration (一次性迁移)**
- Migrate all data at once
- 一次迁移所有数据
- System downtime required
- 需要系统停机
- Faster but riskier
- 更快但风险更高

**2. Phased Migration (分阶段迁移)**
- Migrate in stages
- 分阶段迁移
- Parallel operation possible
- 可以并行运行
- Lower risk, more complex
- 风险更低，更复杂

**3. Trickle Migration (逐步迁移)**
- Gradual data migration
- 逐步迁移数据
- Both systems run simultaneously
- 两个系统同时运行
- Longest duration
- 持续时间最长

**Migration Process:**
**迁移过程：**

```sql
-- Step 1: Extract data from legacy system
-- 步骤1：从遗留系统提取数据
-- Export to CSV or use ETL tool (导出到CSV或使用ETL工具)

-- Step 2: Transform data
-- 步骤2：转换数据
-- Clean, validate, and transform
-- 清理、验证和转换

-- Step 3: Load into new database
-- 步骤3：加载到新数据库
LOAD DATA INFILE '/path/to/employees.csv'
INTO TABLE hr.employees
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS
(emp_id, first_name, last_name, email, @hire_date, salary, dept_id)
SET hire_date = STR_TO_DATE(@hire_date, '%m/%d/%Y');

-- Step 4: Validate data
-- 步骤4：验证数据
SELECT COUNT(*) AS total_records FROM hr.employees;
SELECT COUNT(*) AS records_with_null_dept 
FROM hr.employees WHERE dept_id IS NULL;

-- Step 5: Reconcile with source
-- 步骤5：与源系统核对
-- Compare counts and checksums
-- 比较计数和校验和
```

### 6.3 Application Integration
### 6.3 应用程序集成

**Integration Patterns:**
**集成模式：**

**1. Direct Database Access (直接数据库访问)**

```python
# Python example using connection pool
# Python示例使用连接池
from mysql.connector import pooling

# Create connection pool (创建连接池)
db_pool = pooling.MySQLConnectionPool(
    pool_name="hr_pool",
    pool_size=10,
    host="localhost",
    database="company_db",
    user="hr_app",
    password="secure_password"
)

# Get connection from pool (从池获取连接)
connection = db_pool.get_connection()
cursor = connection.cursor(dictionary=True)

# Execute query (执行查询)
cursor.execute("""
    SELECT emp_id, first_name, last_name, email
    FROM hr.employees
    WHERE dept_id = %s
""", (dept_id,))

employees = cursor.fetchall()
cursor.close()
connection.close()
```

**2. ORM (Object-Relational Mapping)**

```python
# SQLAlchemy example
from sqlalchemy import create_engine, Column, Integer, String, Date
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class Employee(Base):
    __tablename__ = 'employees'
    __table_args__ = {'schema': 'hr'}
    
    emp_id = Column(Integer, primary_key=True)
    first_name = Column(String(50))
    last_name = Column(String(50))
    email = Column(String(100))
    hire_date = Column(Date)

# Create session (创建会话)
engine = create_engine('mysql://user:pass@localhost/company_db')
Session = sessionmaker(bind=engine)
session = Session()

# Query using ORM (使用ORM查询)
employees = session.query(Employee)\\
    .filter(Employee.dept_id == dept_id)\\
    .all()
```

**3. API Layer (API层)**

```python
# RESTful API using Flask
from flask import Flask, jsonify
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://user:pass@localhost/company_db'
db = SQLAlchemy(app)

@app.route('/api/employees/<int:emp_id>', methods=['GET'])
def get_employee(emp_id):
    employee = Employee.query.get_or_404(emp_id)
    return jsonify({
        'emp_id': employee.emp_id,
        'first_name': employee.first_name,
        'last_name': employee.last_name,
        'email': employee.email
    })
```

### 6.4 Data Loading Strategies
### 6.4 数据加载策略

**Bulk Loading Techniques:**
**批量加载技术：**

```sql
-- 1. LOAD DATA INFILE (fastest)
-- 1. LOAD DATA INFILE（最快）
LOAD DATA LOCAL INFILE 'products.csv'
INTO TABLE products
FIELDS TERMINATED BY ','
OPTIONALLY ENCLOSED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS;

-- 2. Batch INSERT (批量INSERT)
INSERT INTO orders (order_id, customer_id, order_date, total)
VALUES 
    (1001, 101, '2024-01-01', 999.99),
    (1002, 102, '2024-01-02', 1499.99),
    (1003, 103, '2024-01-03', 599.99);

-- 3. Disable indexes during load (加载时禁用索引)
ALTER TABLE large_table DISABLE KEYS;
-- Load data... (加载数据...)
ALTER TABLE large_table ENABLE KEYS;

-- 4. Use transactions (使用事务)
START TRANSACTION;
-- Insert thousands of rows (插入数千行)
COMMIT;
```

## 7. Database Testing
## 7. 数据库测试

### 7.1 Testing Strategy and Methods
### 7.1 测试策略和方法

**Testing Levels:**
**测试级别：**

```
┌──────────────────────────────────────┐
│      Unit Testing                    │
│       单元测试                         │
│  - Test individual queries            │
│    测试单个查询                        │
│  - Test stored procedures             │
│    测试存储过程                        │
└───────────────┬──────────────────────┘
                ▼
┌──────────────────────────────────────┐
│    Integration Testing               │
│     集成测试                           │
│  - Test table relationships           │
│    测试表关系                          │
│  - Test constraints                   │
│    测试约束                            │
└───────────────┬──────────────────────┘
                ▼
┌──────────────────────────────────────┐
│    System Testing                    │
│     系统测试                           │
│  - Test complete workflows            │
│    测试完整工作流程                     │
│  - Test with application              │
│    与应用程序一起测试                   │
└───────────────┬──────────────────────┘
                ▼
┌──────────────────────────────────────┐
│   Acceptance Testing                 │
│    验收测试                            │
│  - Validate requirements              │
│    验证需求                            │
│  - User acceptance                    │
│    用户验收                            │
└──────────────────────────────────────┘
```

### 7.2 Functional Testing
### 7.2 功能测试

**Test Cases:**
**测试用例：**

```sql
-- Test 1: Insert Operation
-- 测试1：插入操作
BEGIN;
INSERT INTO employees (first_name, last_name, email, dept_id)
VALUES ('Test', 'User', 'test@example.com', 1);

SELECT * FROM employees WHERE email = 'test@example.com';
-- Expected: 1 row returned (预期：返回1行)

ROLLBACK;

-- Test 2: Foreign Key Constraint
-- 测试2：外键约束
BEGIN;
-- Should fail: Invalid dept_id
-- 应该失败：无效的dept_id
INSERT INTO employees (first_name, last_name, email, dept_id)
VALUES ('Test', 'User', 'test2@example.com', 9999);
-- Expected: Foreign key constraint violation
-- 预期：外键约束违反

ROLLBACK;

-- Test 3: Check Constraint
-- 测试3：检查约束
BEGIN;
-- Should fail: Negative salary
-- 应该失败：负工资
INSERT INTO employees (first_name, last_name, email, salary)
VALUES ('Test', 'User', 'test3@example.com', -1000);
-- Expected: Check constraint violation
-- 预期：检查约束违反

ROLLBACK;
```

### 7.3 Performance Testing
### 7.3 性能测试

**Performance Test Types:**
**性能测试类型：**

**1. Response Time Test (响应时间测试)**

```sql
-- Measure query execution time
-- 测量查询执行时间
SET profiling = 1;

SELECT * FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= '2024-01-01';

SHOW PROFILES;
-- Expected: < 2 seconds (预期：< 2秒)
```

**2. Throughput Test (吞吐量测试)**

```bash
# Use tools like pgbench or sysbench
# 使用pgbench或sysbench等工具

# PostgreSQL pgbench example
pgbench -c 10 -j 2 -t 1000 company_db

# Expected: > 1000 TPS (预期：> 1000 TPS)
```

**3. Scalability Test (可扩展性测试)**

```
Test with increasing data volumes:
使用不断增加的数据量进行测试：

1K records  → Response time: 0.1s
10K records → Response time: 0.3s
100K records → Response time: 1.2s
1M records  → Response time: ?

Monitor degradation pattern
监控性能退化模式
```

### 7.4 Stress Testing and Load Testing
### 7.4 压力测试和负载测试

**Load Testing:**
**负载测试：**

```python
# Example using Python multithreading
# 使用Python多线程的示例
import threading
import mysql.connector
import time

def execute_query(thread_id):
    conn = mysql.connector.connect(
        host="localhost",
        user="test_user",
        password="password",
        database="company_db"
    )
    cursor = conn.cursor()
    
    start_time = time.time()
    cursor.execute("SELECT * FROM large_table WHERE id = %s", (thread_id,))
    result = cursor.fetchall()
    end_time = time.time()
    
    print(f"Thread {thread_id}: {end_time - start_time:.2f}s")
    
    cursor.close()
    conn.close()

# Simulate 100 concurrent users
# 模拟100个并发用户
threads = []
for i in range(100):
    thread = threading.Thread(target=execute_query, args=(i,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
```

**Stress Testing Checklist:**
**压力测试检查清单：**

- [ ] Test with peak load + 50%
- [ ] 测试峰值负载+50%
- [ ] Measure response time degradation
- [ ] 测量响应时间退化
- [ ] Monitor resource utilization (CPU, Memory, I/O)
- [ ] 监控资源利用率（CPU、内存、I/O）
- [ ] Identify breaking point
- [ ] 识别崩溃点
- [ ] Test recovery after overload
- [ ] 测试过载后的恢复

## 8. Database Operations
## 8. 数据库运维

### 8.1 Monitoring and Diagnostics
### 8.1 监控和诊断

**Key Metrics to Monitor:**
**需要监控的关键指标：**

| Metric                | Description           | Alert Threshold |
| --------------------- | --------------------- | --------------- |
| **CPU Usage**         | Database server CPU   | > 80% sustained |
| **Memory Usage**      | RAM utilization       | > 90%           |
| **Disk I/O**          | Read/write operations | > 80% capacity  |
| **Connection Count**  | Active connections    | > 80% of max    |
| **Query Performance** | Slow query count      | > 100/hour      |
| **Replication Lag**   | Master-slave delay    | > 10 seconds    |

| 指标           | 描述            | 告警阈值      |
| -------------- | --------------- | ------------- |
| **CPU使用率**  | 数据库服务器CPU | > 80%持续     |
| **内存使用率** | RAM利用率       | > 90%         |
| **磁盘I/O**    | 读/写操作       | > 80%容量     |
| **连接数**     | 活动连接        | > 80%的最大值 |
| **查询性能**   | 慢查询数        | > 100/小时    |
| **复制延迟**   | 主从延迟        | > 10秒        |

**Monitoring Tools:**
**监控工具：**

```sql
-- MySQL Performance Schema
-- MySQL性能模式
SELECT * FROM performance_schema.events_statements_summary_by_digest
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;

-- PostgreSQL pg_stat_statements
-- PostgreSQL统计语句
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    rows
FROM pg_stat_statements
ORDER BY total_time DESC
LIMIT 10;
```

### 8.2 Backup and Recovery Strategy
### 8.2 备份和恢复策略

**Backup Types:**
**备份类型：**

**1. Full Backup (完全备份)**

```bash
# MySQL full backup
mysqldump --all-databases --single-transaction > full_backup.sql

# PostgreSQL full backup
pg_dump company_db > company_db_backup.sql
```

**2. Incremental Backup (增量备份)**

```bash
# MySQL binary log backup
mysqlbinlog --start-datetime="2024-01-01 00:00:00" \\
            --stop-datetime="2024-01-02 00:00:00" \\
            mysql-bin.000001 > incremental.sql
```

**3. Differential Backup (差异备份)**

```bash
# Backup only changes since last full backup
# 仅备份自上次完全备份以来的更改
```

**Backup Schedule Example:**
**备份计划示例：**

```
Sunday:    Full Backup (完全备份)
Monday:    Incremental Backup (增量备份)
Tuesday:   Incremental Backup (增量备份)
Wednesday: Incremental Backup (增量备份)
Thursday:  Incremental Backup (增量备份)
Friday:    Incremental Backup (增量备份)
Saturday:  Incremental Backup (增量备份)

Retention: 4 weeks (保留：4周)
```

**Recovery Procedures:**
**恢复过程：**

```bash
# 1. Restore from full backup
# 1. 从完全备份恢复
mysql < full_backup.sql

# 2. Apply incremental backups
# 2. 应用增量备份
mysql < incremental_day1.sql
mysql < incremental_day2.sql

# 3. Verify data integrity
# 3. 验证数据完整性
mysql -e "SELECT COUNT(*) FROM critical_table;"
```

### 8.3 Security Management
### 8.3 安全管理

**Security Best Practices:**
**安全最佳实践：**

**1. Access Control (访问控制)**

```sql
-- Principle of least privilege
-- 最小权限原则
CREATE USER 'app_readonly'@'%' IDENTIFIED BY 'strong_password';
GRANT SELECT ON company_db.* TO 'app_readonly'@'%';

CREATE USER 'app_writer'@'%' IDENTIFIED BY 'strong_password';
GRANT SELECT, INSERT, UPDATE ON company_db.* TO 'app_writer'@'%';

-- Revoke unnecessary privileges
-- 撤销不必要的权限
REVOKE ALL ON *.* FROM 'old_user'@'%';
```

**2. Encryption (加密)**

```sql
-- Encrypt sensitive columns
-- 加密敏感列
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    ssn VARBINARY(255),  -- Encrypted
    credit_card VARBINARY(255)  -- Encrypted
);

-- Insert encrypted data
-- 插入加密数据
INSERT INTO users (user_id, username, ssn)
VALUES (1, 'john', AES_ENCRYPT('123-45-6789', 'encryption_key'));

-- Query decrypted data
-- 查询解密数据
SELECT user_id, username, 
       AES_DECRYPT(ssn, 'encryption_key') AS ssn_decrypted
FROM users;
```

**3. Auditing (审计)**

```sql
-- Enable audit logging
-- 启用审计日志
SET GLOBAL general_log = 'ON';
SET GLOBAL general_log_file = '/var/log/mysql/audit.log';

-- Track changes to sensitive tables
-- 跟踪敏感表的更改
CREATE TABLE audit_log (
    audit_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(50),
    action VARCHAR(10),  -- INSERT, UPDATE, DELETE
    user VARCHAR(50),
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    old_values JSON,
    new_values JSON
);

-- Trigger for audit
-- 审计触发器
CREATE TRIGGER audit_employee_changes
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO audit_log (table_name, action, user, old_values, new_values)
    VALUES ('employees', 'UPDATE', USER(),
            JSON_OBJECT('salary', OLD.salary),
            JSON_OBJECT('salary', NEW.salary));
END;
```

**4. SQL Injection Prevention (SQL注入防护)**

```python
# BAD: Vulnerable to SQL injection
# 差：易受SQL注入攻击
query = f"SELECT * FROM users WHERE username = '{user_input}'"

# GOOD: Use parameterized queries
# 好：使用参数化查询
cursor.execute("SELECT * FROM users WHERE username = %s", (user_input,))
```

### 8.4 Capacity Planning
### 8.4 容量规划

**Capacity Planning Process:**
**容量规划过程：**

**1. Current State Assessment (现状评估)**

```sql
-- Assess current database size
-- 评估当前数据库大小
SELECT 
    table_schema,
    SUM(data_length + index_length) / 1024 / 1024 AS size_mb
FROM information_schema.tables
GROUP BY table_schema;

-- Analyze growth rate
-- 分析增长率
SELECT 
    DATE(created_at) AS date,
    COUNT(*) AS daily_records
FROM large_table
WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 90 DAY)
GROUP BY DATE(created_at);
```

**2. Growth Projection (增长预测)**

```
Current Size: 500 GB
当前大小：500 GB

Growth Rate: 10 GB/month
增长率：每月10 GB

Projection for 1 year:
1年预测：
500 GB + (10 GB × 12) = 620 GB

With 50% safety margin:
带50%安全余量：
620 GB × 1.5 = 930 GB

Recommended Capacity: 1 TB
推荐容量：1 TB
```

**3. Resource Planning (资源规划)**

| Resource        | Current | Projected | Recommendation |
| --------------- | ------- | --------- | -------------- |
| **Storage**     | 500 GB  | 620 GB    | 1 TB SSD       |
| **Memory**      | 32 GB   | 48 GB     | 64 GB RAM      |
| **CPU**         | 4 cores | 6 cores   | 8 cores        |
| **Connections** | 100     | 150       | 200 max        |

| 资源       | 当前   | 预测   | 建议      |
| ---------- | ------ | ------ | --------- |
| **存储**   | 500 GB | 620 GB | 1 TB SSD  |
| **内存**   | 32 GB  | 48 GB  | 64 GB RAM |
| **CPU**    | 4核    | 6核    | 8核       |
| **连接数** | 100    | 150    | 200最大   |

## 9. Modern Database Engineering Practices
## 9. 现代数据库工程实践

### 9.1 Database DevOps
### 9.1 数据库DevOps

**DevOps Principles for Databases:**
**数据库DevOps原则：**

```
┌─────────────────────────────────────────────────────┐
│           Database DevOps Cycle                     │
│            数据库DevOps循环                          │
└─────────────────────────────────────────────────────┘

    Plan ────▶ Develop ────▶ Test ────▶ Deploy
    计划        开发          测试       部署
     ▲                                    │
     │                                    ▼
  Monitor ◀──── Operate ◀──── Release ◀───┘
   监控          运维          发布
```

**Key Practices:**
**关键实践：**

**1. Version Control (版本控制)**

```bash
# Git repository structure for database
# 数据库的Git仓库结构
db/
├── migrations/
│   ├── V001__create_tables.sql
│   ├── V002__add_indexes.sql
│   └── V003__add_constraints.sql
├── procedures/
│   ├── sp_get_customer.sql
│   └── sp_process_order.sql
├── views/
│   └── v_customer_orders.sql
└── seeds/
    ├── departments.sql
    └── test_data.sql
```

**2. Automated Testing (自动化测试)**

```python
# pytest example for database tests
# 数据库测试的pytest示例
import pytest
import psycopg2

@pytest.fixture
def db_connection():
    conn = psycopg2.connect(
        dbname="test_db",
        user="test_user",
        password="test_pass"
    )
    yield conn
    conn.close()

def test_insert_customer(db_connection):
    cursor = db_connection.cursor()
    
    # Insert test data
    cursor.execute("""
        INSERT INTO customers (name, email)
        VALUES ('Test User', 'test@example.com')
        RETURNING customer_id
    """)
    
    customer_id = cursor.fetchone()[0]
    assert customer_id is not None
    
    # Verify insertion
    cursor.execute(
        "SELECT name FROM customers WHERE customer_id = %s",
        (customer_id,)
    )
    
    result = cursor.fetchone()
    assert result[0] == 'Test User'
    
    db_connection.rollback()  # Cleanup
```

### 9.2 Continuous Integration/Continuous Delivery
### 9.2 持续集成/持续交付

**CI/CD Pipeline for Database:**
**数据库CI/CD流水线：**

```yaml
# GitLab CI/CD example
# GitLab CI/CD示例
stages:
  - lint
  - test
  - deploy

lint_sql:
  stage: lint
  script:
    - sqlfluff lint migrations/

unit_test:
  stage: test
  services:
    - postgres:13
  script:
    - pip install pytest psycopg2
    - pytest tests/

migration_test:
  stage: test
  services:
    - postgres:13
  script:
    - flyway migrate
    - flyway validate

deploy_dev:
  stage: deploy
  script:
    - flyway migrate -url=jdbc:postgresql://dev-db
  environment:
    name: development
  only:
    - develop

deploy_prod:
  stage: deploy
  script:
    - flyway migrate -url=jdbc:postgresql://prod-db
  environment:
    name: production
  when: manual
  only:
    - main
```

**Deployment Strategies:**
**部署策略：**

**1. Blue-Green Deployment (蓝绿部署)**

```
Blue (Current)          Green (New Version)
蓝（当前）               绿（新版本）
     ↓                        ↓
┌──────────┐            ┌──────────┐
│  DB v1   │            │  DB v2   │
└──────────┘            └──────────┘
     ↑                        ↑
     │                        │
     └────────Switch──────────┘
            切换
```

**2. Canary Deployment (金丝雀部署)**

```
10% traffic → New Database
10%流量 → 新数据库

90% traffic → Old Database
90%流量 → 旧数据库

Gradually increase to 100%
逐步增加到100%
```

### 9.3 Infrastructure as Code (IaC)
### 9.3 基础设施即代码

**Database Infrastructure as Code:**
**数据库基础设施即代码：**

**Terraform Example:**

```hcl
# Terraform configuration for RDS
# RDS的Terraform配置
resource "aws_db_instance" "production" {
  identifier           = "prod-database"
  engine               = "postgres"
  engine_version       = "13.7"
  instance_class       = "db.r5.large"
  allocated_storage    = 1000
  storage_type         = "gp3"
  
  db_name  = "company_db"
  username = "admin"
  password = var.db_password
  
  vpc_security_group_ids = [aws_security_group.database.id]
  db_subnet_group_name   = aws_db_subnet_group.database.name
  
  backup_retention_period = 30
  backup_window          = "03:00-04:00"
  maintenance_window     = "sun:04:00-sun:05:00"
  
  enabled_cloudwatch_logs_exports = ["postgresql"]
  
  multi_az               = true
  deletion_protection    = true
  
  tags = {
    Environment = "production"
    ManagedBy   = "terraform"
  }
}

resource "aws_db_instance" "replica" {
  replicate_source_db = aws_db_instance.production.id
  instance_class      = "db.r5.large"
  
  tags = {
    Environment = "production"
    Role        = "read-replica"
  }
}
```

**Ansible Example:**

```yaml
# Ansible playbook for database setup
# 数据库设置的Ansible playbook
---
- name: Setup PostgreSQL Database
  hosts: db_servers
  become: yes
  
  tasks:
    - name: Install PostgreSQL
      apt:
        name: postgresql-13
        state: present
    
    - name: Configure PostgreSQL
      template:
        src: postgresql.conf.j2
        dest: /etc/postgresql/13/main/postgresql.conf
      notify: restart postgresql
    
    - name: Create database
      postgresql_db:
        name: company_db
        encoding: UTF8
        state: present
    
    - name: Create database user
      postgresql_user:
        name: app_user
        password: "{{ db_password }}"
        db: company_db
        priv: ALL
    
    - name: Apply migrations
      command: flyway migrate
      args:
        chdir: /opt/database/migrations
  
  handlers:
    - name: restart postgresql
      service:
        name: postgresql
        state: restarted
```

### 9.4 Database Version Control
### 9.4 数据库版本控制

**Migration-Based Approach:**
**基于迁移的方法：**

**Flyway Example:**

```sql
-- V1__initial_schema.sql
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- V2__add_user_status.sql
ALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'active';
ALTER TABLE users ADD CONSTRAINT chk_status 
    CHECK (status IN ('active', 'inactive', 'suspended'));

-- V3__create_orders_table.sql
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(user_id),
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10,2)
);

CREATE INDEX idx_orders_user ON orders(user_id);
```

**Liquibase Example:**

```xml
<!-- changelog.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.0.xsd">

    <changeSet id="1" author="dev">
        <createTable tableName="departments">
            <column name="dept_id" type="int" autoIncrement="true">
                <constraints primaryKey="true"/>
            </column>
            <column name="dept_name" type="varchar(100)">
                <constraints nullable="false"/>
            </column>
        </createTable>
    </changeSet>

    <changeSet id="2" author="dev">
        <addColumn tableName="departments">
            <column name="location" type="varchar(100)"/>
        </addColumn>
    </changeSet>

    <changeSet id="3" author="dev">
        <createIndex indexName="idx_dept_name" 
                     tableName="departments">
            <column name="dept_name"/>
        </createIndex>
    </changeSet>

</databaseChangeLog>
```

**Best Practices:**
**最佳实践：**

1. **Never modify existing migrations**
1. **永远不要修改现有迁移**
   - Create new migration instead
   - 创建新迁移代替

2. **Include rollback scripts**
2. **包含回滚脚本**
   ```sql
   -- Up migration
   ALTER TABLE users ADD COLUMN phone VARCHAR(20);
   
   -- Down migration (rollback)
   ALTER TABLE users DROP COLUMN phone;
   ```

3. **Test migrations on staging first**
3. **先在测试环境测试迁移**

4. **Use idempotent migrations**
4. **使用幂等迁移**
   ```sql
   CREATE TABLE IF NOT EXISTS users (...);
   ALTER TABLE users ADD COLUMN IF NOT EXISTS status VARCHAR(20);
   ```

5. **Version everything**
5. **对所有内容进行版本控制**
   - Schema changes
   - 模式变更
   - Stored procedures
   - 存储过程
   - Functions
   - 函数
   - Views
   - 视图

## Conclusion
## 结论

Database Engineering is a comprehensive discipline that combines theoretical knowledge with practical skills to build robust, efficient, and maintainable database systems. By following systematic methodologies, applying engineering best practices, and embracing modern DevOps approaches, organizations can ensure their database systems meet current needs while remaining flexible for future growth.

数据库工程是一门综合性学科，将理论知识与实践技能相结合，构建健壮、高效和可维护的数据库系统。通过遵循系统化方法论、应用工程最佳实践和采用现代DevOps方法，组织可以确保其数据库系统满足当前需求，同时保持未来增长的灵活性。

**Key Takeaways:**
**关键要点：**

1. **Lifecycle Approach**: Follow structured phases from planning to operations
1. **生命周期方法**：遵循从规划到运维的结构化阶段

2. **Requirements First**: Thorough requirements analysis prevents costly redesigns
2. **需求优先**：全面的需求分析可防止代价高昂的重新设计

3. **Conceptual Modeling**: E-R diagrams provide clear communication of data structure
3. **概念建模**：E-R图提供数据结构的清晰交流

4. **Normalization**: Apply normalization principles but denormalize when needed
4. **规范化**：应用规范化原则，但在需要时反规范化

5. **Performance Design**: Index strategy and partitioning are critical for scalability
5. **性能设计**：索引策略和分区对可扩展性至关重要

6. **Testing**: Comprehensive testing ensures quality and reliability
6. **测试**：全面测试确保质量和可靠性

7. **Operations**: Monitoring, backup, and security are ongoing responsibilities
7. **运维**：监控、备份和安全是持续的责任

8. **Modern Practices**: Adopt DevOps, CI/CD, and IaC for database systems
8. **现代实践**：为数据库系统采用DevOps、CI/CD和IaC

**Future Trends:**
**未来趋势：**

- **Cloud-Native Databases**: Serverless and managed database services
- **云原生数据库**：无服务器和托管数据库服务
- **AI-Driven Optimization**: Machine learning for query optimization
- **AI驱动优化**：用于查询优化的机器学习
- **Multi-Model Databases**: Support multiple data models in one system
- **多模型数据库**：在一个系统中支持多种数据模型
- **Database Mesh**: Service mesh concepts applied to databases
- **数据库网格**：将服务网格概念应用于数据库
- **Automated DBA**: AI-powered autonomous database management
- **自动化DBA**：AI驱动的自治数据库管理

---

## References and Further Reading
## 参考资料与延伸阅读

**Books:**
**书籍：**
- "Database System Concepts" by Silberschatz, Korth, Sudarshan
- "Fundamentals of Database Systems" by Elmasri and Navathe
- "Database Design for Mere Mortals" by Michael J. Hernandez
- "Database Reliability Engineering" by Laine Campbell and Charity Majors
- "Refactoring Databases" by Scott W. Ambler and Pramod J. Sadalage

**Standards and Methodologies:**
**标准和方法论：**
- ANSI/SPARC Database Architecture
- ANSI/SPARC数据库架构
- IEEE Standards for Database Design
- IEEE数据库设计标准
- DAMA-DMBOK (Data Management Body of Knowledge)
- DAMA-DMBOK（数据管理知识体系）

**Tools:**
**工具：**
- **Migration**: Flyway, Liquibase, Alembic
- **迁移**：Flyway、Liquibase、Alembic
- **Version Control**: Git, GitLab, GitHub
- **版本控制**：Git、GitLab、GitHub
- **CI/CD**: Jenkins, GitLab CI, GitHub Actions
- **CI/CD**：Jenkins、GitLab CI、GitHub Actions
- **Monitoring**: Prometheus, Grafana, Datadog
- **监控**：Prometheus、Grafana、Datadog
- **Testing**: pytest, DBUnit, pgTAP
- **测试**：pytest、DBUnit、pgTAP

**Online Resources:**
**在线资源：**
- Database Weekly Newsletter
- 数据库周刊
- PostgreSQL Documentation
- PostgreSQL文档
- MySQL Reference Manual
- MySQL参考手册
- Database DevOps Best Practices (Microsoft)
- 数据库DevOps最佳实践（微软）