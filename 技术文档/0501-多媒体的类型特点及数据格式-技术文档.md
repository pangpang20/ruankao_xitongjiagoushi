# Multimedia Types, Characteristics and Data Formats / 多媒体的类型特点及数据格式

## 1. Multimedia Fundamentals / 多媒体基础概念

### 1.1 Definition and Classification / 定义与分类

**Multimedia Definition:**

Multimedia refers to the integration of multiple forms of media content, including text, audio, images, video, and animation, to create interactive and engaging digital experiences. In computer systems, multimedia involves the digitization, storage, processing, transmission, and presentation of these different media types.

**多媒体定义：**

多媒体是指将文本、音频、图像、视频和动画等多种媒体形式集成在一起，创建交互式和引人入胜的数字体验。在计算机系统中，多媒体涉及这些不同媒体类型的数字化、存储、处理、传输和呈现。

**Multimedia Classification / 多媒体分类：**

| Type / 类型              | Characteristics / 特征     | Examples / 示例               |
| ------------------------ | -------------------------- | ----------------------------- |
| **Text / 文本**          | Discrete, structured data  | HTML, PDF, TXT                |
| **Audio / 音频**         | Time-based, continuous     | Music, speech, sound effects  |
| **Image / 图像**         | Spatial, static visual     | Photos, graphics, icons       |
| **Video / 视频**         | Time-based, spatial visual | Movies, streaming, recordings |
| **Animation / 动画**     | Sequential frames          | GIF, SVG animation, 3D models |
| **Interactive / 交互式** | User-driven experience     | Games, VR/AR, simulations     |

### 1.2 Digital Multimedia Characteristics / 数字多媒体的特征

**Key Characteristics:**

1. **Digitization / 数字化**
   - Conversion of analog signals to discrete digital values
   - 模拟信号转换为离散数字值

2. **Compression / 压缩**
   - Reduction of data size while preserving quality
   - 在保持质量的同时减少数据大小

3. **Multimodality / 多模态**
   - Integration of different media types
   - 不同媒体类型的集成

4. **Interactivity / 交互性**
   - User control and participation
   - 用户控制和参与

5. **Real-time Processing / 实时处理**
   - Immediate encoding, transmission, and playback
   - 即时编码、传输和播放

### 1.3 Multimedia Data Representation / 多媒体数据表示

**Analog vs. Digital / 模拟与数字：**

```
Analog Signal / 模拟信号
   ↓ Sampling / 采样
Digital Samples / 数字采样
   ↓ Quantization / 量化
Digital Values / 数字值
   ↓ Encoding / 编码
Digital File / 数字文件
```

**Sampling Process / 采样过程：**

```python
# Audio sampling example / 音频采样示例
import numpy as np
import wave

def sample_audio(analog_signal, sample_rate=44100, bit_depth=16):
    """
    Convert analog audio to digital samples
    将模拟音频转换为数字采样
    
    Args:
        analog_signal: Continuous signal function
        sample_rate: Samples per second (Hz)
        bit_depth: Bits per sample
    """
    # Nyquist theorem: sample_rate >= 2 * max_frequency
    # 奈奎斯特定理：采样率 >= 2 * 最高频率
    
    duration = 1.0  # seconds / 秒
    t = np.linspace(0, duration, int(sample_rate * duration))
    
    # Sample the signal / 采样信号
    digital_samples = analog_signal(t)
    
    # Quantize to bit depth / 量化到位深度
    max_value = 2 ** (bit_depth - 1) - 1
    quantized = np.round(digital_samples * max_value).astype(np.int16)
    
    return quantized

# Example: Sample a 440Hz sine wave (A note)
# 示例：采样440Hz正弦波（A音符）
analog_signal = lambda t: np.sin(2 * np.pi * 440 * t)
digital_audio = sample_audio(analog_signal)
```

### 1.4 Quality Metrics / 质量评价指标

**Common Quality Indicators / 常见质量指标：**

| Metric / 指标                  | Description / 描述              | Typical Values / 典型值 |
| ------------------------------ | ------------------------------- | ----------------------- |
| **Bit Rate / 比特率**          | Data processed per second       | 128kbps - 50Mbps        |
| **Resolution / 分辨率**        | Pixel dimensions (W×H)          | 720p, 1080p, 4K, 8K     |
| **Frame Rate / 帧率**          | Frames per second (fps)         | 24, 30, 60, 120 fps     |
| **Sample Rate / 采样率**       | Audio samples per second        | 44.1kHz, 48kHz, 96kHz   |
| **Bit Depth / 位深度**         | Bits per sample                 | 8-bit, 16-bit, 24-bit   |
| **Color Depth / 色彩深度**     | Bits per pixel                  | 8-bit, 10-bit, 12-bit   |
| **Compression Ratio / 压缩比** | Original size / Compressed size | 10:1, 50:1, 100:1       |

**Quality vs. File Size Trade-off / 质量与文件大小权衡：**

```
High Quality        ← → Low Quality
高质量              ← → 低质量
Large File Size     ← → Small File Size
大文件              ← → 小文件
High Bandwidth      ← → Low Bandwidth
高带宽              ← → 低带宽
```

---

## 2. Audio Multimedia / 音频多媒体

### 2.1 Audio Digitization Principles / 音频数字化原理

**Three-Step Process / 三步过程：**

1. **Sampling / 采样**
   - Capture amplitude at discrete time intervals
   - 在离散时间间隔捕获幅度
   - Governed by Nyquist-Shannon theorem: fs ≥ 2 * fmax
   - 由奈奎斯特-香农定理支配：采样率 ≥ 2 * 最高频率

2. **Quantization / 量化**
   - Map continuous amplitude to discrete levels
   - 将连续幅度映射到离散级别
   - Bit depth determines quantization levels (2^n)
   - 位深度决定量化级别（2^n）

3. **Encoding / 编码**
   - Convert quantized values to binary format
   - 将量化值转换为二进制格式
   - Apply compression if needed
   - 必要时应用压缩

**Audio Data Size Calculation / 音频数据大小计算：**

```
File Size = Sample Rate × Bit Depth × Channels × Duration / 8

Example / 示例:
- Sample Rate / 采样率: 44,100 Hz (CD quality)
- Bit Depth / 位深度: 16 bits
- Channels / 声道: 2 (stereo / 立体声)
- Duration / 时长: 60 seconds

File Size = 44,100 × 16 × 2 × 60 / 8
         = 10,584,000 bytes
         ≈ 10.1 MB
```

### 2.2 Lossless Audio Formats / 无损音频格式

**WAV (Waveform Audio File Format)**

```
Format: PCM (Pulse Code Modulation) / 格式：脉冲编码调制
Container: RIFF / 容器：RIFF
Compression: None (uncompressed) / 压缩：无（未压缩）
Quality: Perfect / 质量：完美
File Size: Large / 文件大小：大
Use Cases: Professional audio, mastering / 使用场景：专业音频、母带制作
```

**Reading WAV file example / 读取WAV文件示例：**

```python
import wave
import struct

def read_wav_file(filename):
    """
    Read WAV file and extract audio data
    读取WAV文件并提取音频数据
    """
    with wave.open(filename, 'rb') as wav_file:
        # Get parameters / 获取参数
        n_channels = wav_file.getnchannels()  # 1=mono, 2=stereo
        sample_width = wav_file.getsampwidth()  # bytes per sample
        framerate = wav_file.getframerate()  # sample rate
        n_frames = wav_file.getnframes()  # total samples
        
        print(f"Channels / 声道: {n_channels}")
        print(f"Sample Width / 采样宽度: {sample_width} bytes")
        print(f"Frame Rate / 帧率: {framerate} Hz")
        print(f"Frames / 帧数: {n_frames}")
        print(f"Duration / 时长: {n_frames/framerate:.2f} seconds")
        
        # Read audio data / 读取音频数据
        audio_data = wav_file.readframes(n_frames)
        
        # Convert to samples / 转换为采样
        if sample_width == 2:  # 16-bit
            samples = struct.unpack(f'{n_frames * n_channels}h', audio_data)
        
        return samples, framerate
```

**FLAC (Free Lossless Audio Codec)**

```
Format: Lossless compression / 格式：无损压缩
Compression Ratio: 50-60% of original / 压缩比：原始大小的50-60%
Quality: Identical to source / 质量：与源相同
Metadata: Rich tagging support / 元数据：丰富的标签支持
Use Cases: Music archiving, Hi-Fi playback / 使用场景：音乐存档、高保真播放
```

**FLAC encoding example / FLAC编码示例：**

```bash
# Encode WAV to FLAC / 将WAV编码为FLAC
flac --best input.wav -o output.flac

# With metadata / 带元数据
flac --best \
  -T "ARTIST=Artist Name" \
  -T "ALBUM=Album Title" \
  -T "TITLE=Song Title" \
  -T "DATE=2024" \
  input.wav -o output.flac

# Decode FLAC to WAV / 将FLAC解码为WAV
flac -d output.flac -o restored.wav
```

**ALAC (Apple Lossless Audio Codec)**

```
Format: Apple's lossless codec / 格式：Apple的无损编解码器
Compression: Similar to FLAC / 压缩：类似于FLAC
Ecosystem: Native iOS/macOS support / 生态系统：原生iOS/macOS支持
Container: M4A (MPEG-4 Audio) / 容器：M4A（MPEG-4音频）
```

**APE (Monkey's Audio)**

```
Format: High compression lossless / 格式：高压缩无损
Compression Ratio: ~55% of original / 压缩比：约原始大小的55%
Decoding Speed: Slower than FLAC / 解码速度：比FLAC慢
Popularity: Common in Asia / 流行度：在亚洲常见
```

### 2.3 Lossy Audio Formats / 有损音频格式

**MP3 (MPEG-1 Audio Layer 3)**

```
Format: Perceptual audio coding / 格式：感知音频编码
Bit Rates: 32-320 kbps (常用：128, 192, 320 kbps)
Compression: Psychoacoustic model / 压缩：心理声学模型
Quality: Good at 192+ kbps / 质量：192+ kbps时良好
Compatibility: Universal / 兼容性：通用
```

**MP3 encoding with LAME / 使用LAME编码MP3：**

```bash
# Variable Bit Rate (VBR) - highest quality
# 可变比特率 - 最高质量
lame -V 0 input.wav output.mp3

# Constant Bit Rate (CBR) - 320 kbps
# 恒定比特率 - 320 kbps
lame -b 320 input.wav output.mp3

# Average Bit Rate (ABR) - 192 kbps
# 平均比特率 - 192 kbps
lame --abr 192 input.wav output.mp3
```

**Python MP3 metadata handling / Python处理MP3元数据：**

```python
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, TPE1, TALB, APIC

def add_mp3_metadata(filename, title, artist, album, cover_image=None):
    """
    Add ID3 tags to MP3 file
    向MP3文件添加ID3标签
    """
    audio = MP3(filename, ID3=ID3)
    
    # Add tags / 添加标签
    audio.tags.add(TIT2(encoding=3, text=title))  # Title / 标题
    audio.tags.add(TPE1(encoding=3, text=artist))  # Artist / 艺术家
    audio.tags.add(TALB(encoding=3, text=album))  # Album / 专辑
    
    # Add cover art / 添加封面
    if cover_image:
        with open(cover_image, 'rb') as img:
            audio.tags.add(
                APIC(
                    encoding=3,
                    mime='image/jpeg',
                    type=3,  # Cover image / 封面图像
                    desc='Cover',
                    data=img.read()
                )
            )
    
    audio.save()
```

**AAC (Advanced Audio Coding)**

```
Format: Successor to MP3 / 格式：MP3的继承者
Standard: MPEG-4 Part 3 / 标准：MPEG-4 Part 3
Quality: Better than MP3 at same bitrate / 质量：同比特率下优于MP3
Bit Rates: 64-320 kbps (常用：128, 256 kbps)
Use Cases: Apple Music, YouTube, streaming / 使用场景：Apple Music、YouTube、流媒体
```

**AAC encoding with FFmpeg / 使用FFmpeg编码AAC：**

```bash
# AAC-LC (Low Complexity) - standard quality
# AAC-LC（低复杂度）- 标准质量
ffmpeg -i input.wav -c:a aac -b:a 192k output.m4a

# AAC-HE (High Efficiency) - for low bitrates
# AAC-HE（高效率）- 用于低比特率
ffmpeg -i input.wav -c:a libfdk_aac -profile:a aac_he -b:a 64k output.m4a

# AAC-HE v2 with SBR and PS - very low bitrates
# AAC-HE v2（带SBR和PS）- 极低比特率
ffmpeg -i input.wav -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k output.m4a
```

**OGG Vorbis**

```
Format: Open-source lossy codec / 格式：开源有损编解码器
Container: OGG / 容器：OGG
Quality: Superior to MP3 / 质量：优于MP3
Patents: Patent-free / 专利：无专利
Use Cases: Gaming, open-source projects / 使用场景：游戏、开源项目
```

**Opus**

```
Format: Modern, versatile codec / 格式：现代、多功能编解码器
Bit Rates: 6-510 kbps / 比特率：6-510 kbps
Latency: Very low (2.5-60 ms) / 延迟：非常低（2.5-60毫秒）
Use Cases: VoIP, WebRTC, streaming / 使用场景：VoIP、WebRTC、流媒体
Standards: IETF RFC 6716 / 标准：IETF RFC 6716
```

**Opus encoding example / Opus编码示例：**

```bash
# Speech optimization / 语音优化
ffmpeg -i input.wav -c:a libopus -b:a 32k -application voip output.opus

# Music optimization / 音乐优化
ffmpeg -i input.wav -c:a libopus -b:a 128k -application audio output.opus

# Low latency / 低延迟
ffmpeg -i input.wav -c:a libopus -b:a 64k -frame_duration 2.5 output.opus
```

### 2.4 Audio Parameters / 音频参数

**Sample Rate Comparison / 采样率比较：**

| Sample Rate | Use Case / 使用场景                    | Quality / 质量                  |
| ----------- | -------------------------------------- | ------------------------------- |
| 8 kHz       | Telephony / 电话                       | Voice only / 仅语音             |
| 16 kHz      | VoIP, voice recording / VoIP、语音录制 | Enhanced voice / 增强语音       |
| 22.05 kHz   | Low-quality music / 低质量音乐         | AM radio quality / AM广播质量   |
| 44.1 kHz    | CD audio / CD音频                      | High-quality music / 高质量音乐 |
| 48 kHz      | Professional video / 专业视频          | Studio quality / 录音室质量     |
| 96 kHz      | Hi-Res audio / 高解析度音频            | Audiophile / 发烧友             |
| 192 kHz     | Mastering / 母带制作                   | Professional / 专业级           |

**Channel Configurations / 声道配置：**

```
Mono (1.0):            [C]
单声道:                [中]

Stereo (2.0):          [L] [R]
立体声:                [左] [右]

2.1 Surround:          [L] [R] [LFE]
2.1环绕声:             [左] [右] [低频]

5.1 Surround:          [FL] [FR] [C] [LFE] [SL] [SR]
5.1环绕声:             [前左] [前右] [中] [低频] [侧左] [侧右]

7.1 Surround:          [FL] [FR] [C] [LFE] [SL] [SR] [BL] [BR]
7.1环绕声:             [前左] [前右] [中] [低频] [侧左] [侧右] [后左] [后右]

Dolby Atmos:           Object-based 3D audio / 基于对象的3D音频
```

### 2.5 Audio Format Comparison / 音频格式比较

| Format | Type / 类型     | Compression Ratio / 压缩比 | Quality / 质量   | Use Case / 使用场景         |
| ------ | --------------- | -------------------------- | ---------------- | --------------------------- |
| WAV    | Lossless / 无损 | 1:1 (None / 无)            | Perfect / 完美   | Professional / 专业         |
| FLAC   | Lossless / 无损 | ~2:1                       | Perfect / 完美   | Archiving / 存档            |
| ALAC   | Lossless / 无损 | ~2:1                       | Perfect / 完美   | Apple ecosystem / Apple生态 |
| MP3    | Lossy / 有损    | 10:1 - 12:1                | Good / 良好      | Universal / 通用            |
| AAC    | Lossy / 有损    | 10:1 - 12:1                | Very Good / 很好 | Streaming / 流媒体          |
| Opus   | Lossy / 有损    | 15:1 - 20:1                | Excellent / 优秀 | Real-time / 实时            |
| OGG    | Lossy / 有损    | 10:1 - 15:1                | Very Good / 很好 | Gaming / 游戏               |

---

## 3. Video Multimedia / 视频多媒体

### 3.1 Video Encoding Principles / 视频编码基本原理

**Video Compression Types / 视频压缩类型：**

1. **Intra-frame Compression (I-frames) / 帧内压缩（I帧）**
   - Self-contained complete frames
   - 独立的完整帧
   - Uses image compression techniques (JPEG-like)
   - 使用图像压缩技术（类似JPEG）

2. **Inter-frame Compression (P/B-frames) / 帧间压缩（P/B帧）**
   - **P-frames (Predicted)**: Reference previous frames
   - **P帧（预测帧）**：引用先前的帧
   - **B-frames (Bidirectional)**: Reference both previous and future frames
   - **B帧（双向帧）**：引用先前和未来的帧

**GOP (Group of Pictures) Structure / GOP（图像组）结构：**

```
I  B  B  P  B  B  P  B  B  I  B  B  P
|--GOP 1 (12 frames)--|--GOP 2----|

I-frame: 关键帧（完整图像）
P-frame: 预测帧（从前一帧预测）
B-frame: 双向帧（从前后帧预测）

Typical GOP sizes / 典型GOP大小:
- Streaming: 2-4 seconds / 流媒体：2-4秒
- Broadcast: 0.5-1 second / 广播：0.5-1秒
```

**Motion Estimation and Compensation / 运动估计和补偿：**

```python
def motion_compensation_example():
    """
    Simplified motion compensation concept
    简化的运动补偿概念
    """
    # Previous frame / 前一帧
    previous_frame = np.array([...])
    
    # Current frame / 当前帧
    current_frame = np.array([...])
    
    # Motion vectors / 运动向量
    # Instead of storing full frame, store:
    # 不存储完整帧，而是存储：
    # 1. Motion vectors (x, y offsets)
    # 1. 运动向量（x, y偏移）
    # 2. Residual (difference after motion compensation)
    # 2. 残差（运动补偿后的差异）
    
    motion_vectors = calculate_motion_vectors(previous_frame, current_frame)
    predicted_frame = apply_motion_vectors(previous_frame, motion_vectors)
    residual = current_frame - predicted_frame
    
    # Compressed P-frame = motion_vectors + residual
    # 压缩的P帧 = 运动向量 + 残差
    return motion_vectors, residual
```

### 3.2 Video Coding Standards / 主流视频编码标准

**H.264/AVC (Advanced Video Coding)**

```
Standard: ITU-T H.264 / ISO/IEC 14496-10 / 标准：ITU-T H.264 / ISO/IEC 14496-10
Release: 2003 / 发布：2003年
Profiles: Baseline, Main, High / 配置文件：基线、主要、高级
Compression: 50% better than MPEG-2 / 压缩：比MPEG-2好50%
Use Cases: Blu-ray, streaming, broadcasting / 使用场景：蓝光、流媒体、广播
Market Share: Still dominant (60%+) / 市场份额：仍占主导地位（60%+）
```

**H.264 encoding with FFmpeg / 使用FFmpeg编码H.264：**

```bash
# Fast encoding (lower quality) / 快速编码（较低质量）
ffmpeg -i input.mp4 -c:v libx264 -preset ultrafast -crf 23 output.mp4

# Balanced encoding / 平衡编码
ffmpeg -i input.mp4 -c:v libx264 -preset medium -crf 23 output.mp4

# High quality (slow) / 高质量（慢速）
ffmpeg -i input.mp4 -c:v libx264 -preset veryslow -crf 18 output.mp4

# Constant bitrate for streaming / 恒定比特率用于流媒体
ffmpeg -i input.mp4 -c:v libx264 -preset medium -b:v 5M -maxrate 5M -bufsize 10M output.mp4

# Two-pass encoding for best quality / 两遍编码以获得最佳质量
# Pass 1 / 第一遍
ffmpeg -i input.mp4 -c:v libx264 -preset slow -b:v 5M -pass 1 -f null /dev/null
# Pass 2 / 第二遍
ffmpeg -i input.mp4 -c:v libx264 -preset slow -b:v 5M -pass 2 output.mp4
```

**H.264 Profiles / H.264配置文件：**

| Profile / 配置文件 | Features / 特性                   | Use Case / 使用场景                      |
| ------------------ | --------------------------------- | ---------------------------------------- |
| Baseline           | B-frames不支持, CABAC不支持       | Mobile devices / 移动设备                |
| Main               | B-frames支持, CABAC支持           | Broadcasting / 广播                      |
| High               | 8x8 transform, 自适应帧/场        | Blu-ray, HD streaming / 蓝光、高清流媒体 |
| High 10            | 10-bit color depth / 10位色彩深度 | Professional video / 专业视频            |

**H.265/HEVC (High Efficiency Video Coding)**

```
Standard: ITU-T H.265 / ISO/IEC 23008-2 / 标准：ITU-T H.265 / ISO/IEC 23008-2
Release: 2013 / 发布：2013年
Compression: 50% better than H.264 / 压缩：比H.264好50%
Coding Tree Units: 64x64 (vs 16x16 in H.264) / 编码树单元：64x64（H.264中为16x16）
Use Cases: 4K/8K video, HDR content / 使用场景：4K/8K视频、HDR内容
Patent Issues: Complex licensing / 专利问题：复杂的许可
```

**H.265 encoding / H.265编码：**

```bash
# Standard HEVC encoding / 标准HEVC编码
ffmpeg -i input.mp4 -c:v libx265 -preset medium -crf 28 output.mp4

# 4K HDR encoding / 4K HDR编码
ffmpeg -i input_4k.mp4 \
  -c:v libx265 \
  -preset slow \
  -crf 22 \
  -pix_fmt yuv420p10le \
  -x265-params "colorprim=bt2020:transfer=smpte2084:colormatrix=bt2020nc" \
  output_4k_hdr.mp4

# Lower bitrate for same quality / 相同质量下更低的比特率
ffmpeg -i input.mp4 -c:v libx265 -preset slow -crf 28 -b:v 2M output.mp4
```

**VP9 (Google)**

```
Developer: Google / 开发者：Google
Release: 2013 / 发布：2013年
License: Open-source, royalty-free / 许可：开源、免版税
Compression: Similar to H.265 / 压缩：类似于H.265
Use Cases: YouTube, WebM / 使用场景：YouTube、WebM
Hardware Support: Limited compared to H.264/H.265 / 硬件支持：相比H.264/H.265有限
```

**VP9 encoding / VP9编码：**

```bash
# VP9 two-pass encoding / VP9两遍编码
# Pass 1
ffmpeg -i input.mp4 -c:v libvpx-vp9 -b:v 2M -pass 1 -f null /dev/null
# Pass 2
ffmpeg -i input.mp4 -c:v libvpx-vp9 -b:v 2M -pass 2 output.webm

# Constrained quality mode / 受限质量模式
ffmpeg -i input.mp4 -c:v libvpx-vp9 -crf 30 -b:v 0 output.webm

# Real-time encoding for live streaming / 实时编码用于直播
ffmpeg -i input.mp4 -c:v libvpx-vp9 -quality realtime -speed 6 output.webm
```

**AV1 (AOMedia Video 1)**

```
Developer: Alliance for Open Media (AOMedia) / 开发者：开放媒体联盟
Release: 2018 / 发布：2018年
License: Royalty-free / 许可：免版税
Compression: 30% better than H.265 / 压缩：比H.265好30%
Encoding Speed: Very slow (improving) / 编码速度：非常慢（正在改进）
Use Cases: Netflix, YouTube (4K+) / 使用场景：Netflix、YouTube（4K+）
Future: Next-generation codec / 未来：下一代编解码器
```

**AV1 encoding / AV1编码：**

```bash
# AV1 encoding with libaom / 使用libaom编码AV1
ffmpeg -i input.mp4 -c:v libaom-av1 -crf 30 -b:v 0 output.mkv

# Faster AV1 encoding with SVT-AV1 / 使用SVT-AV1更快编码
ffmpeg -i input.mp4 -c:v libsvtav1 -crf 35 -preset 6 output.mkv

# AV1 for streaming / AV1用于流媒体
ffmpeg -i input.mp4 \
  -c:v libsvtav1 \
  -crf 30 \
  -preset 8 \
  -svtav1-params "tune=0:enable-qm=1" \
  output.mp4
```

### 3.3 Video Parameters / 视频参数

**Resolution Standards / 分辨率标准：**

| Name            | Resolution | Pixels | Aspect Ratio / 宽高比 | Use Case / 使用场景               |
| --------------- | ---------- | ------ | --------------------- | --------------------------------- |
| SD (480p)       | 640×480    | 307K   | 4:3                   | Legacy / 传统                     |
| HD (720p)       | 1280×720   | 922K   | 16:9                  | HD broadcasting / 高清广播        |
| Full HD (1080p) | 1920×1080  | 2.1M   | 16:9                  | Blu-ray, streaming / 蓝光、流媒体 |
| 2K              | 2048×1080  | 2.2M   | 19:10                 | Cinema / 电影                     |
| QHD (1440p)     | 2560×1440  | 3.7M   | 16:9                  | Gaming / 游戏                     |
| 4K UHD          | 3840×2160  | 8.3M   | 16:9                  | 4K streaming / 4K流媒体           |
| 4K DCI          | 4096×2160  | 8.8M   | 19:10                 | Cinema / 电影                     |
| 8K UHD          | 7680×4320  | 33.2M  | 16:9                  | Future / 未来                     |

**Frame Rate Standards / 帧率标准：**

```
24 fps: Cinema standard / 电影标准
25 fps: PAL video standard / PAL视频标准
29.97/30 fps: NTSC video standard / NTSC视频标准
48 fps: High frame rate cinema (HFR) / 高帧率电影
50 fps: PAL high frame rate / PAL高帧率
59.94/60 fps: Smooth motion, gaming / 流畅运动、游戏
120 fps: High-speed cameras, slow motion / 高速摄像机、慢动作
```

**Color Space / 色彩空间：**

```
BT.601 (SD):     Standard Definition / 标清
BT.709 (HD):     High Definition (Rec.709) / 高清
BT.2020 (UHD):   Ultra High Definition / 超高清
DCI-P3:          Digital Cinema / 数字电影

YUV Subsampling / YUV子采样:
4:4:4 - Full chroma resolution / 全色度分辨率
4:2:2 - Half horizontal chroma / 水平色度减半
4:2:0 - Quarter chroma resolution / 色度分辨率四分之一
```

**HDR (High Dynamic Range) / 高动态范围：**

| Standard / 标准        | Characteristics / 特征                      | Adoption / 采用情况            |
| ---------------------- | ------------------------------------------- | ------------------------------ |
| HDR10                  | 10-bit, static metadata / 10位、静态元数据  | Universal / 通用               |
| HDR10+                 | Dynamic metadata / 动态元数据               | Samsung, Amazon / 三星、亚马逊 |
| Dolby Vision           | 12-bit, dynamic metadata / 12位、动态元数据 | Premium content / 高端内容     |
| HLG (Hybrid Log-Gamma) | Backward compatible / 向后兼容              | Broadcasting / 广播            |

### 3.4 Video Quality and Compression / 视频质量与压缩比

**CRF (Constant Rate Factor) Guide / CRF（恒定速率因子）指南：**

```
CRF Scale (lower = higher quality) / CRF刻度（越低质量越高）:

0-17:  Visually lossless / 视觉无损
18-23: High quality (recommended range) / 高质量（推荐范围）
24-28: Medium quality / 中等质量
29-35: Low quality / 低质量
36-51: Very low quality / 非常低质量

Default values / 默认值:
- H.264: CRF 23
- H.265: CRF 28
- VP9:   CRF 31
- AV1:   CRF 32
```

**Bitrate Recommendations / 比特率建议：**

| Resolution | H.264 Bitrate | H.265 Bitrate | Use Case / 使用场景          |
| ---------- | ------------- | ------------- | ---------------------------- |
| 480p       | 1-2 Mbps      | 0.5-1 Mbps    | Mobile / 移动                |
| 720p       | 3-5 Mbps      | 1.5-3 Mbps    | HD streaming / 高清流媒体    |
| 1080p      | 5-10 Mbps     | 3-6 Mbps      | Full HD / 全高清             |
| 1440p      | 10-20 Mbps    | 6-13 Mbps     | QHD / 2K                     |
| 4K         | 25-50 Mbps    | 15-25 Mbps    | UHD streaming / 超高清流媒体 |
| 8K         | 80-160 Mbps   | 50-100 Mbps   | Future / 未来                |

### 3.5 Video Encoder Comparison / 编码器比较

| Codec | Compression Efficiency / 压缩效率 | Encoding Speed / 编码速度 | Decoding Speed / 解码速度 | Patent Status / 专利状态 |
| ----- | --------------------------------- | ------------------------- | ------------------------- | ------------------------ |
| H.264 | Baseline / 基准                   | Fast / 快                 | Very Fast / 非常快        | Patented / 专利          |
| H.265 | +50% vs H.264                     | Slow / 慢                 | Fast / 快                 | Patented / 专利          |
| VP9   | +50% vs H.264                     | Very Slow / 非常慢        | Medium / 中等             | Royalty-free / 免版税    |
| AV1   | +30% vs H.265                     | Extremely Slow / 极慢     | Slow / 慢                 | Royalty-free / 免版税    |

---

## 4. Image Multimedia / 图像多媒体

### 4.1 Bitmap Image Formats / 位图图像格式

**BMP (Bitmap)**

```
Format: Uncompressed raster / 格式：未压缩光栅
Color Depth: 1, 4, 8, 16, 24, 32-bit / 色彩深度：1、4、8、16、24、32位
Compression: None (or RLE) / 压缩：无（或RLE）
File Size: Very large / 文件大小：非常大
Use Cases: Windows applications, legacy systems / 使用场景：Windows应用、传统系统
```

**PNG (Portable Network Graphics)**

```
Format: Lossless compression / 格式：无损压缩
Compression: DEFLATE (zlib) / 压缩：DEFLATE（zlib）
Color Depth: Up to 48-bit / 色彩深度：最高48位
Transparency: Full alpha channel / 透明度：完整Alpha通道
Interlacing: Adam7 / 交错：Adam7
Use Cases: Web graphics, screenshots, logos / 使用场景：Web图形、截图、标志
```

**PNG optimization / PNG优化：**

```bash
# Lossless optimization with OptiPNG / 使用OptiPNG进行无损优化
optipng -o7 image.png

# Lossy compression with pngquant / 使用pngquant进行有损压缩
pngquant --quality=65-80 image.png -o output.png

# Using FFmpeg / 使用FFmpeg
ffmpeg -i input.png -compression_level 100 output.png
```

**Python PNG manipulation / Python处理PNG：**

```python
from PIL import Image

def optimize_png(input_path, output_path, quality=85):
    """
    Optimize PNG image / 优化PNG图像
    """
    img = Image.open(input_path)
    
    # Convert RGBA to RGB if no transparency / 如果没有透明度，转换RGBA为RGB
    if img.mode == 'RGBA':
        # Check if image has transparency / 检查图像是否有透明度
        if not has_transparency(img):
            rgb_img = Image.new('RGB', img.size, (255, 255, 255))
            rgb_img.paste(img, mask=img.split()[3])
            img = rgb_img
    
    # Save with optimization / 优化保存
    img.save(output_path, 'PNG', optimize=True, compress_level=9)

def has_transparency(img):
    """Check if PNG has transparency / 检查PNG是否有透明度"""
    if img.mode == 'RGBA':
        alpha = img.split()[3]
        return min(alpha.getdata()) < 255
    return False
```

**JPEG (Joint Photographic Experts Group)**

```
Format: Lossy compression / 格式：有损压缩
Compression: DCT (Discrete Cosine Transform) / 压缩：离散余弦变换
Quality Range: 0-100 (higher = better) / 质量范围：0-100（越高越好）
Color Space: YCbCr / 色彩空间：YCbCr
Use Cases: Photography, web images / 使用场景：摄影、Web图像
Limitations: No transparency / 限制：无透明度
```

**JPEG quality settings / JPEG质量设置：**

```bash
# High quality (minimal loss) / 高质量（最小损失）
ffmpeg -i input.png -q:v 2 output.jpg  # Quality 2 (95-100%)

# Medium quality (balanced) / 中等质量（平衡）
ffmpeg -i input.png -q:v 5 output.jpg  # Quality 5 (80-85%)

# Low quality (small file) / 低质量（小文件）
ffmpeg -i input.png -q:v 10 output.jpg  # Quality 10 (60-70%)

# Progressive JPEG / 渐进式JPEG
ffmpeg -i input.png -q:v 3 -pix_fmt yuvj420p -huffman optimal output.jpg
```

**Python JPEG manipulation / Python处理JPEG：**

```python
from PIL import Image
import piexif

def save_jpeg_optimized(input_path, output_path, quality=85):
    """
    Save JPEG with optimized settings
    保存优化的JPEG
    """
    img = Image.open(input_path)
    
    # Convert to RGB if necessary / 必要时转换为RGB
    if img.mode != 'RGB':
        img = img.convert('RGB')
    
    # Save with optimization / 优化保存
    img.save(
        output_path,
        'JPEG',
        quality=quality,
        optimize=True,
        progressive=True,  # Progressive JPEG / 渐进式JPEG
        subsampling='4:2:0'  # Chroma subsampling / 色度子采样
    )

def extract_exif(image_path):
    """
    Extract EXIF metadata from JPEG
    从JPEG提取EXIF元数据
    """
    img = Image.open(image_path)
    exif_dict = piexif.load(img.info.get('exif', b''))
    
    # Extract common fields / 提取常见字段
    metadata = {}
    if piexif.ImageIFD.Make in exif_dict['0th']:
        metadata['Camera Make'] = exif_dict['0th'][piexif.ImageIFD.Make].decode()
    if piexif.ImageIFD.Model in exif_dict['0th']:
        metadata['Camera Model'] = exif_dict['0th'][piexif.ImageIFD.Model].decode()
    if piexif.ExifIFD.DateTimeOriginal in exif_dict['Exif']:
        metadata['Date'] = exif_dict['Exif'][piexif.ExifIFD.DateTimeOriginal].decode()
    
    return metadata
```

**WebP (Google)**

```
Format: Both lossy and lossless / 格式：有损和无损
Compression: VP8/VP8L / 压缩：VP8/VP8L
File Size: 25-35% smaller than JPEG/PNG / 文件大小：比JPEG/PNG小25-35%
Transparency: Alpha channel support / 透明度：支持Alpha通道
Animation: Supported / 动画：支持
Use Cases: Modern web applications / 使用场景：现代Web应用
```

**WebP conversion / WebP转换：**

```bash
# Lossy WebP / 有损WebP
cwebp -q 80 input.jpg -o output.webp

# Lossless WebP / 无损WebP
cwebp -lossless input.png -o output.webp

# With transparency / 带透明度
cwebp -q 80 -alpha_q 100 input.png -o output.webp

# Using FFmpeg / 使用FFmpeg
ffmpeg -i input.jpg -c:v libwebp -quality 80 output.webp
```

**AVIF (AV1 Image File Format)**

```
Format: Next-gen image format / 格式：下一代图像格式
Based on: AV1 video codec / 基于：AV1视频编解码器
Compression: Superior to WebP / 压缩：优于WebP
HDR Support: Yes / HDR支持：是
Browser Support: Growing / 浏览器支持：增长中
Use Cases: Modern web, high-quality images / 使用场景：现代Web、高质量图像
```

**AVIF encoding / AVIF编码：**

```bash
# Convert to AVIF / 转换为AVIF
avifenc -s 4 -j 8 input.jpg output.avif

# Using FFmpeg / 使用FFmpeg
ffmpeg -i input.jpg -c:v libaom-av1 -still-picture 1 output.avif

# Lossless AVIF / 无损AVIF
avifenc --lossless input.png output.avif
```

### 4.2 Vector Image Formats / 矢量图像格式

**SVG (Scalable Vector Graphics)**

```
Format: XML-based vector graphics / 格式：基于XML的矢量图形
Scalability: Infinite / 可缩放性：无限
File Size: Usually small / 文件大小：通常很小
Animation: CSS/JavaScript / 动画：CSS/JavaScript
Interactivity: Fully interactive / 交互性：完全交互
Use Cases: Icons, logos, diagrams / 使用场景：图标、标志、图表
```

**SVG example / SVG示例：**

```xml
<!-- Simple SVG circle / 简单的SVG圆形 -->
<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
  <!-- Circle / 圆形 -->
  <circle cx="100" cy="100" r="80" 
          fill="blue" 
          stroke="black" 
          stroke-width="2"/>
  
  <!-- Text / 文本 -->
  <text x="100" y="110" 
        text-anchor="middle" 
        font-size="20" 
        fill="white">
    SVG Circle
  </text>
</svg>
```

**SVG optimization / SVG优化：**

```bash
# Optimize SVG with SVGO / 使用SVGO优化SVG
svgo input.svg -o output.svg

# Remove unnecessary data / 删除不必要的数据
svgo --multipass --precision=2 input.svg -o output.svg
```

**PDF (Portable Document Format)**

```
Format: Page description language / 格式：页面描述语言
Content: Vector and raster / 内容：矢量和光栅
Compression: Multiple methods / 压缩：多种方法
Metadata: Rich document properties / 元数据：丰富的文档属性
Use Cases: Documents, printables / 使用场景：文档、打印品
```

### 4.3 Image Compression Techniques / 图像压缩技术

**Lossless vs. Lossy / 无损与有损：**

| Technique / 技术 | Method / 方法     | Quality / 质量                 | Use Case / 使用场景             |
| ---------------- | ----------------- | ------------------------------ | ------------------------------- |
| Lossless / 无损  | RLE, LZW, DEFLATE | Perfect / 完美                 | Archiving, editing / 存档、编辑 |
| Lossy / 有损     | DCT, Wavelet      | Good to Excellent / 良好到优秀 | Web, display / Web、显示        |

**Compression algorithms / 压缩算法：**

```python
def run_length_encoding(data):
    """
    Simple RLE compression / 简单的RLE压缩
    Example: AAAABBBCCCCC -> 4A3B5C
    """
    if not data:
        return []
    
    compressed = []
    count = 1
    current = data[0]
    
    for i in range(1, len(data)):
        if data[i] == current and count < 255:
            count += 1
        else:
            compressed.extend([count, current])
            current = data[i]
            count = 1
    
    compressed.extend([count, current])
    return compressed

# Example / 示例
pixels = [255, 255, 255, 255, 128, 128, 128, 0, 0]
compressed = run_length_encoding(pixels)
print(compressed)  # [4, 255, 3, 128, 2, 0]
```

### 4.4 Image Metadata / 图像元数据

**EXIF (Exchangeable Image File Format)**

```
Camera Information / 相机信息:
- Make and Model / 制造商和型号
- Lens information / 镜头信息
- Focal length / 焦距

Shooting Parameters / 拍摄参数:
- ISO speed / ISO感光度
- Aperture (f-stop) / 光圈
- Shutter speed / 快门速度
- White balance / 白平衡

Location Data / 位置数据:
- GPS coordinates / GPS坐标
- Altitude / 海拔

Timestamp / 时间戳:
- Date and time original / 原始日期和时间
- Date and time digitized / 数字化日期和时间
```

**XMP (Extensible Metadata Platform)**

```
Creator Information / 创建者信息
Copyright / 版权
Keywords and descriptions / 关键词和描述
Rating and labels / 评级和标签
Edit history / 编辑历史
```

### 4.5 Image Format Selection Guide / 图像格式选择指南

| Use Case / 使用场景   | Recommended Format / 推荐格式 | Reason / 原因                             |
| --------------------- | ----------------------------- | ----------------------------------------- |
| Photography / 摄影    | JPEG, HEIF                    | High quality, small size / 高质量、小体积 |
| Screenshots / 截图    | PNG                           | Lossless, text clarity / 无损、文本清晰   |
| Logos / 标志          | SVG, PNG                      | Scalability / 可缩放性                    |
| Icons / 图标          | SVG, WebP                     | Small size, scalability / 小体积、可缩放  |
| Web images / Web图像  | WebP, AVIF                    | Best compression / 最佳压缩               |
| Transparency / 透明度 | PNG, WebP                     | Alpha channel / Alpha通道                 |
| Animation / 动画      | GIF, WebP, APNG               | Frame-based / 基于帧                      |
| Print / 打印          | TIFF, PDF                     | High resolution / 高分辨率                |

---

## 5. Container Formats / 容器格式

### 5.1 Container Format Basics / 容器格式基础

**Container vs. Codec / 容器与编解码器：**

```
Container (Wrapper) / 容器（封装器）:
- Holds multiple streams / 包含多个流
- Metadata and structure / 元数据和结构
- Examples: MP4, MKV, AVI

Codec (Encoder/Decoder) / 编解码器：
- Compression algorithm / 压缩算法
- Video: H.264, H.265, VP9
- Audio: AAC, MP3, Opus
```

**Multiplexing Example / 多路复用示例：**

```
Container File / 容器文件
├── Video Stream (H.264) / 视频流（H.264）
├── Audio Stream 1 (AAC - English) / 音频流1（AAC - 英语）
├── Audio Stream 2 (AAC - Spanish) / 音频流2（AAC - 西班牙语）
├── Subtitle Stream 1 (SRT - English) / 字幕流1（SRT - 英语）
├── Subtitle Stream 2 (SRT - Chinese) / 字幕流2（SRT - 中文）
└── Metadata (title, duration, etc.) / 元数据（标题、时长等）
```

### 5.2 Major Container Formats / 主流容器格式

**MP4 (MPEG-4 Part 14)**

```
Standard: ISO/IEC 14496-14 / 标准：ISO/IEC 14496-14
Base: MPEG-4 container / 基础：MPEG-4容器
Video Codecs: H.264, H.265, AV1 / 视频编解码器：H.264、H.265、AV1
Audio Codecs: AAC, MP3, AC-3 / 音频编解码器：AAC、MP3、AC-3
Features: Streaming, chapters, metadata / 特性：流媒体、章节、元数据
Compatibility: Universal / 兼容性：通用
Use Cases: Streaming, mobile, web / 使用场景：流媒体、移动、Web
```

**MP4 creation with FFmpeg / 使用FFmpeg创建MP4：**

```bash
# Basic MP4 conversion / 基本MP4转换
ffmpeg -i input.avi -c:v libx264 -c:a aac output.mp4

# MP4 with multiple audio tracks / 带多个音轨的MP4
ffmpeg -i input.mkv \
  -map 0:v:0 -map 0:a:0 -map 0:a:1 \
  -c:v copy -c:a copy \
  -metadata:s:a:0 language=eng \
  -metadata:s:a:1 language=spa \
  output.mp4

# MP4 with subtitles / 带字幕的MP4
ffmpeg -i input.mkv -i subtitles.srt \
  -c:v copy -c:a copy -c:s mov_text \
  -metadata:s:s:0 language=eng \
  output.mp4

# Fragmented MP4 for streaming / 用于流媒体的分片MP4
ffmpeg -i input.mp4 \
  -c copy \
  -movflags frag_keyframe+empty_moov+default_base_moof \
  output_fragmented.mp4
```

**MKV (Matroska)**

```
Format: Open-source container / 格式：开源容器
Flexibility: Extremely versatile / 灵活性：极其通用
Video Codecs: Any / 视频编解码器：任何
Audio Codecs: Any / 音频编解码器：任何
Features: Unlimited streams, chapters, menus / 特性：无限流、章节、菜单
Subtitles: Advanced support (ASS, SRT, VobSub) / 字幕：高级支持
Use Cases: High-quality archiving, Blu-ray rips / 使用场景：高质量存档、蓝光翻录
```

**MKV features example / MKV特性示例：**

```bash
# Create MKV with multiple streams / 创建带多个流的MKV
ffmpeg -i video.mp4 -i audio_en.aac -i audio_zh.aac -i subs_en.srt \
  -map 0:v -map 1:a -map 2:a -map 3:s \
  -c:v copy -c:a copy -c:s srt \
  -metadata:s:a:0 language=eng -metadata:s:a:0 title="English" \
  -metadata:s:a:1 language=chi -metadata:s:a:1 title="中文" \
  -metadata:s:s:0 language=eng \
  output.mkv

# Add chapters to MKV / 向MKV添加章节
ffmpeg -i input.mkv -i chapters.txt -map 0 -map_chapters 1 -c copy output.mkv

# Extract streams from MKV / 从MKV提取流
ffmpeg -i input.mkv -map 0:v -c copy video_only.mkv
ffmpeg -i input.mkv -map 0:a:1 -c copy audio_track2.aac
```

**WebM**

```
Developer: Google / 开发者：Google
Purpose: Web-optimized / 目的：Web优化
Video Codecs: VP8, VP9, AV1 / 视频编解码器：VP8、VP9、AV1
Audio Codecs: Vorbis, Opus / 音频编解码器：Vorbis、Opus
License: Royalty-free / 许可：免版税
HTML5: Native support / HTML5：原生支持
Use Cases: Web video, YouTube / 使用场景：Web视频、YouTube
```

**WebM creation / 创建WebM：**

```bash
# VP9 + Opus WebM / VP9 + Opus WebM
ffmpeg -i input.mp4 \
  -c:v libvpx-vp9 -b:v 2M \
  -c:a libopus -b:a 128k \
  output.webm

# Dash-compatible WebM / 兼容Dash的WebM
ffmpeg -i input.mp4 \
  -c:v libvpx-vp9 -b:v 2M \
  -c:a libopus -b:a 128k \
  -f webm -dash 1 \
  output.webm
```

**AVI (Audio Video Interleave)**

```
Developer: Microsoft / 开发者：微软
Release: 1992 / 发布：1992年
Structure: RIFF container / 结构：RIFF容器
Limitations: 2GB file size limit (classic AVI) / 限制：2GB文件大小限制（经典AVI）
Compatibility: Legacy systems / 兼容性：传统系统
Status: Outdated, avoid for new projects / 状态：过时，避免用于新项目
```

**MOV (QuickTime File Format)**

```
Developer: Apple / 开发者：Apple
Container: QuickTime / 容器：QuickTime
Codecs: H.264, ProRes, AAC / 编解码器：H.264、ProRes、AAC
Features: High quality, editing-friendly / 特性：高质量、编辑友好
Use Cases: macOS/iOS ecosystem, professional editing / 使用场景：macOS/iOS生态系统、专业编辑
```

### 5.3 Subtitle and Metadata / 字幕和元数据封装

**Subtitle Formats / 字幕格式：**

| Format  | Type / 类型  | Features / 特性                | Container Support / 容器支持 |
| ------- | ------------ | ------------------------------ | ---------------------------- |
| SRT     | Text / 文本  | Simple, universal / 简单、通用 | MP4, MKV, WebM               |
| ASS/SSA | Text / 文本  | Styling, effects / 样式、效果  | MKV                          |
| VobSub  | Image / 图像 | DVD subtitles / DVD字幕        | MKV, MP4                     |
| PGS     | Image / 图像 | Blu-ray subtitles / 蓝光字幕   | MKV, M2TS                    |
| WebVTT  | Text / 文本  | Web standard / Web标准         | WebM, MP4                    |

**Subtitle embedding / 嵌入字幕：**

```bash
# Embed SRT subtitle / 嵌入SRT字幕
ffmpeg -i video.mp4 -i subtitle.srt \
  -c:v copy -c:a copy -c:s mov_text \
  -metadata:s:s:0 language=eng \
  output.mp4

# Hardcode subtitle (burn-in) / 硬编码字幕（烧录）
ffmpeg -i video.mp4 -vf subtitles=subtitle.srt output_with_subs.mp4

# Multiple subtitle tracks / 多个字幕轨道
ffmpeg -i video.mp4 -i en.srt -i zh.srt \
  -map 0:v -map 0:a -map 1 -map 2 \
  -c:v copy -c:a copy -c:s srt \
  -metadata:s:s:0 language=eng \
  -metadata:s:s:1 language=chi \
  output.mkv
```

**Metadata embedding / 嵌入元数据：**

```bash
# Add metadata to MP4 / 向MP4添加元数据
ffmpeg -i input.mp4 -c copy \
  -metadata title="Movie Title" \
  -metadata artist="Director Name" \
  -metadata album="Collection Name" \
  -metadata date="2024" \
  -metadata comment="Description" \
  output.mp4

# Python metadata manipulation / Python操作元数据
from mutagen.mp4 import MP4

video = MP4("movie.mp4")
video["\xa9nam"] = "Movie Title"  # Title / 标题
video["\xa9ART"] = "Director"     # Artist / 艺术家
video["\xa9alb"] = "Collection"   # Album / 专辑
video["\xa9day"] = "2024"         # Year / 年份
video.save()
```

### 5.4 Container Format Comparison / 容器格式对比

| Container | Flexibility / 灵活性 | Streaming / 流媒体 | Compatibility / 兼容性      | Best Use / 最佳用途                 |
| --------- | -------------------- | ------------------ | --------------------------- | ----------------------------------- |
| MP4       | Medium / 中等        | Excellent / 优秀   | Universal / 通用            | General purpose / 通用              |
| MKV       | Very High / 非常高   | Good / 良好        | High / 高                   | High-quality archiving / 高质量存档 |
| WebM      | Low / 低             | Excellent / 优秀   | Web browsers / Web浏览器    | Web video / Web视频                 |
| AVI       | Low / 低             | Poor / 差          | Legacy / 传统               | Avoid / 避免                        |
| MOV       | High / 高            | Good / 良好        | Apple ecosystem / Apple生态 | Professional editing / 专业编辑     |

---

## 6. Streaming Media Formats and Protocols / 流媒体格式与协议

### 6.1 Streaming Principles / 流媒体传输原理

**Streaming vs. Download / 流媒体与下载：**

```
Progressive Download / 渐进式下载:
- Download file sequentially / 顺序下载文件
- Play while downloading / 下载时播放
- Limited seeking / 有限的定位
- File stored locally / 文件本地存储

Adaptive Streaming / 自适应流媒体:
- Multiple quality levels / 多个质量级别
- Dynamic bitrate switching / 动态比特率切换
- Segment-based delivery / 基于分段的传输
- No full file download / 无完整文件下载
```

**Buffering and Playback / 缓冲和播放：**

```python
class StreamingBuffer:
    """
    Simple streaming buffer implementation
    简单的流媒体缓冲实现
    """
    def __init__(self, buffer_size=10):
        self.buffer = []
        self.buffer_size = buffer_size  # seconds / 秒
        self.playing = False
    
    def add_segment(self, segment):
        """Add segment to buffer / 向缓冲区添加分段"""
        self.buffer.append(segment)
        
        # Start playback when buffer is sufficient / 缓冲足够时开始播放
        if len(self.buffer) >= self.buffer_size * 0.5:
            self.playing = True
    
    def get_next_segment(self):
        """Get next segment to play / 获取下一个要播放的分段"""
        if self.buffer:
            return self.buffer.pop(0)
        else:
            # Buffering / 缓冲中
            self.playing = False
            return None
    
    def buffer_health(self):
        """Check buffer health / 检查缓冲区健康状况"""
        return len(self.buffer) / self.buffer_size
```

### 6.2 Adaptive Bitrate Streaming / 自适应比特率流

**HLS (HTTP Live Streaming)**

```
Developer: Apple / 开发者：Apple
Release: 2009 / 发布：2009年
Transport: HTTP/HTTPS / 传输：HTTP/HTTPS
Segment Format: MPEG-TS or fMP4 / 分段格式：MPEG-TS或fMP4
Manifest: M3U8 playlist / 清单：M3U8播放列表
Compatibility: Universal (iOS, Android, Web) / 兼容性：通用
Latency: 6-30 seconds / 延迟：6-30秒
```

**HLS playlist example / HLS播放列表示例：**

```m3u8
# Master playlist / 主播放列表
#EXTM3U
#EXT-X-VERSION:3

# 1080p variant / 1080p变体
#EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080,CODECS="avc1.640028,mp4a.40.2"
https://example.com/1080p/playlist.m3u8

# 720p variant / 720p变体
#EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720,CODECS="avc1.64001f,mp4a.40.2"
https://example.com/720p/playlist.m3u8

# 480p variant / 480p变体
#EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480,CODECS="avc1.64001e,mp4a.40.2"
https://example.com/480p/playlist.m3u8
```

```m3u8
# Media playlist / 媒体播放列表
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:0

#EXTINF:10.0,
segment0.ts
#EXTINF:10.0,
segment1.ts
#EXTINF:10.0,
segment2.ts
#EXT-X-ENDLIST
```

**HLS generation with FFmpeg / 使用FFmpeg生成HLS：**

```bash
# Basic HLS generation / 基本HLS生成
ffmpeg -i input.mp4 \
  -c:v libx264 -c:a aac \
  -hls_time 10 \
  -hls_playlist_type vod \
  -hls_segment_filename 'segment%03d.ts' \
  output.m3u8

# Multi-bitrate HLS / 多比特率HLS
ffmpeg -i input.mp4 \
  -filter_complex \
  "[0:v]split=3[v1][v2][v3]; \
   [v1]scale=w=1920:h=1080[v1out]; \
   [v2]scale=w=1280:h=720[v2out]; \
   [v3]scale=w=854:h=480[v3out]" \
  -map "[v1out]" -c:v:0 libx264 -b:v:0 5M \
  -map "[v2out]" -c:v:1 libx264 -b:v:1 2.5M \
  -map "[v3out]" -c:v:2 libx264 -b:v:2 1M \
  -map a:0 -c:a aac -b:a 128k \
  -var_stream_map "v:0,a:0 v:1,a:0 v:2,a:0" \
  -master_pl_name master.m3u8 \
  -f hls -hls_time 10 -hls_list_size 0 \
  -hls_segment_filename 'v%v/segment%03d.ts' \
  v%v/playlist.m3u8
```

**DASH (Dynamic Adaptive Streaming over HTTP)**

```
Standard: MPEG-DASH (ISO/IEC 23009-1) / 标准：MPEG-DASH
Release: 2012 / 发布：2012年
Manifest: MPD (XML) / 清单：MPD（XML）
Segment Format: Any (MP4, WebM) / 分段格式：任意（MP4、WebM）
Codec Agnostic: Yes / 编解码器无关：是
DRM Support: Excellent / DRM支持：优秀
```

**DASH MPD example / DASH MPD示例：**

```xml
<?xml version="1.0"?>
<MPD xmlns="urn:mpeg:dash:schema:mpd:2011" 
     type="static" 
     mediaPresentationDuration="PT634.566S">
  
  <!-- AdaptationSet for video / 视频自适应集 -->
  <Period>
    <AdaptationSet mimeType="video/mp4" codecs="avc1.64001f">
      
      <!-- 1080p representation / 1080p表示 -->
      <Representation id="1" bandwidth="5000000" width="1920" height="1080">
        <BaseURL>1080p/</BaseURL>
        <SegmentTemplate timescale="1000" 
                         initialization="init.mp4" 
                         media="segment$Number$.m4s" 
                         startNumber="1" 
                         duration="10000"/>
      </Representation>
      
      <!-- 720p representation / 720p表示 -->
      <Representation id="2" bandwidth="2500000" width="1280" height="720">
        <BaseURL>720p/</BaseURL>
        <SegmentTemplate timescale="1000" 
                         initialization="init.mp4" 
                         media="segment$Number$.m4s" 
                         startNumber="1" 
                         duration="10000"/>
      </Representation>
    </AdaptationSet>
    
    <!-- AdaptationSet for audio / 音频自适应集 -->
    <AdaptationSet mimeType="audio/mp4" codecs="mp4a.40.2">
      <Representation id="audio" bandwidth="128000">
        <BaseURL>audio/</BaseURL>
        <SegmentTemplate timescale="1000" 
                         initialization="init.mp4" 
                         media="segment$Number$.m4s" 
                         startNumber="1" 
                         duration="10000"/>
      </Representation>
    </AdaptationSet>
  </Period>
</MPD>
```

**DASH generation / DASH生成：**

```bash
# Generate DASH content / 生成DASH内容
ffmpeg -i input.mp4 \
  -map 0:v:0 -c:v:0 libx264 -b:v:0 5M -s:v:0 1920x1080 \
  -map 0:v:0 -c:v:1 libx264 -b:v:1 2.5M -s:v:1 1280x720 \
  -map 0:v:0 -c:v:2 libx264 -b:v:2 1M -s:v:2 854x480 \
  -map 0:a:0 -c:a aac -b:a 128k \
  -f dash \
  -seg_duration 10 \
  -adaptation_sets "id=0,streams=v id=1,streams=a" \
  manifest.mpd
```

### 6.3 Real-time Streaming Protocols / 实时流媒体协议

**RTMP (Real-Time Messaging Protocol)**

```
Developer: Adobe (now open) / 开发者：Adobe（现已开放）
Port: TCP 1935 / 端口：TCP 1935
Latency: 3-5 seconds / 延迟：3-5秒
Use Case: Live broadcasting (legacy) / 使用场景：直播（传统）
Status: Being replaced by HLS/WebRTC / 状态：正被HLS/WebRTC取代
```

**RTMP streaming with FFmpeg / 使用FFmpeg进行RTMP流媒体：**

```bash
# Stream to RTMP server / 推流到RTMP服务器
ffmpeg -re -i input.mp4 \
  -c:v libx264 -preset veryfast -maxrate 3000k -bufsize 6000k \
  -pix_fmt yuv420p -g 50 \
  -c:a aac -b:a 128k -ar 44100 \
  -f flv rtmp://live-server.com/live/stream_key

# Stream from webcam / 从网络摄像头流媒体
ffmpeg -f dshow -i video="USB Camera":audio="Microphone" \
  -c:v libx264 -preset ultrafast -tune zerolatency \
  -c:a aac -b:a 128k \
  -f flv rtmp://localhost/live/mystream
```

**RTSP (Real Time Streaming Protocol)**

```
Port: TCP/UDP 554 / 端口：TCP/UDP 554
Transport: RTP/RTCP / 传输：RTP/RTCP
Use Case: IP cameras, surveillance / 使用场景：IP摄像机、监控
Control: Play, pause, seek commands / 控制：播放、暂停、定位命令
```

**WebRTC (Web Real-Time Communication)**

```
Standard: W3C and IETF / 标准：W3C和IETF
Latency: Sub-second (<1s) / 延迟：亚秒级（<1秒）
Transport: UDP (SRTP) / 传输：UDP（SRTP）
Codecs: VP8, VP9, H.264, Opus / 编解码器：VP8、VP9、H.264、Opus
Use Cases: Video conferencing, live interaction / 使用场景：视频会议、实时互动
P2P: Peer-to-peer capable / P2P：支持点对点
```

**WebRTC signaling example / WebRTC信令示例：**

```javascript
// WebRTC peer connection setup / WebRTC对等连接设置
const peerConnection = new RTCPeerConnection({
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' }
  ]
});

// Add local stream / 添加本地流
navigator.mediaDevices.getUserMedia({ video: true, audio: true })
  .then(stream => {
    stream.getTracks().forEach(track => {
      peerConnection.addTrack(track, stream);
    });
  });

// Create offer / 创建提议
peerConnection.createOffer()
  .then(offer => {
    return peerConnection.setLocalDescription(offer);
  })
  .then(() => {
    // Send offer to remote peer via signaling server
    // 通过信令服务器发送提议到远程对等端
    signalingServer.send({
      type: 'offer',
      sdp: peerConnection.localDescription
    });
  });

// Handle incoming stream / 处理传入流
peerConnection.ontrack = (event) => {
  const remoteVideo = document.getElementById('remote-video');
  remoteVideo.srcObject = event.streams[0];
};
```

### 6.4 CDN and Caching / CDN分发和缓存策略

**CDN Architecture / CDN架构：**

```
Origin Server / 源服务器
       |
       v
CDN Edge Servers (Global) / CDN边缘服务器（全球）
   |    |    |
   v    v    v
Users / 用户

Benefits / 优势:
- Reduced latency / 降低延迟
- Load distribution / 负载分配
- DDoS protection / DDoS保护
- Bandwidth savings / 节省带宽
```

**Cache Control Headers / 缓存控制头：**

```http
# Long cache for segments / 分段长缓存
Cache-Control: public, max-age=31536000, immutable

# Short cache for playlists / 播放列表短缓存
Cache-Control: public, max-age=10

# No cache for live manifests / 直播清单无缓存
Cache-Control: no-cache, no-store, must-revalidate
```

### 6.5 Low-Latency Streaming / 低延迟直播技术

**Low-Latency HLS (LL-HLS)**

```
Segment Duration: 1-2 seconds (vs 6-10s traditional) / 分段时长：1-2秒
Partial Segments: Sub-second chunks / 部分分段：亚秒级块
Latency Target: 2-3 seconds / 延迟目标：2-3秒
Blocking Playlist Reload: Reduces overhead / 阻塞播放列表重载：减少开销
```

**LL-HLS playlist example / LL-HLS播放列表示例：**

```m3u8
#EXTM3U
#EXT-X-VERSION:9
#EXT-X-TARGETDURATION:2
#EXT-X-SERVER-CONTROL:CAN-BLOCK-RELOAD=YES,PART-HOLD-BACK=0.6
#EXT-X-PART-INF:PART-TARGET=0.2

#EXT-X-PART:DURATION=0.2,URI="segment0_part0.m4s"
#EXT-X-PART:DURATION=0.2,URI="segment0_part1.m4s"
#EXTINF:2.0,
segment0.m4s
```

**Low-Latency DASH**

```
Chunked Transfer Encoding: Yes / 分块传输编码：是
Chunk Duration: <1 second / 块时长：<1秒
Latency: 2-4 seconds / 延迟：2-4秒
```

**SRT (Secure Reliable Transport)**

```
Protocol: UDP-based / 协议：基于UDP
Latency: Configurable (120ms - 8s) / 延迟：可配置（120毫秒 - 8秒）
Error Correction: Yes / 错误纠正：是
Encryption: AES / 加密：AES
Use Case: Professional broadcasting / 使用场景：专业广播
```

**Streaming Protocol Comparison / 流媒体协议比较：**

| Protocol / 协议 | Latency / 延迟 | Compatibility / 兼容性       | Use Case / 使用场景              |
| --------------- | -------------- | ---------------------------- | -------------------------------- |
| HLS             | 6-30s          | Universal / 通用             | VOD, Live / 点播、直播           |
| DASH            | 6-30s          | Wide / 广泛                  | VOD, Live / 点播、直播           |
| LL-HLS          | 2-3s           | Modern / 现代                | Low-latency live / 低延迟直播    |
| LL-DASH         | 2-4s           | Growing / 增长中             | Low-latency live / 低延迟直播    |
| RTMP            | 3-5s           | Declining / 衰减中           | Live ingest / 直播推流           |
| WebRTC          | <1s            | Modern browsers / 现代浏览器 | Real-time interaction / 实时互动 |
| SRT             | 0.12-8s        | Professional / 专业          | Broadcast / 广播                 |

---

## 7. Multimedia Encoding and Decoding / 多媒体编解码技术

### 7.1 Codec Architecture / 编解码器架构

**Encoder Pipeline / 编码器管道：**

```
Input Frame / 输入帧
    ↓
Preprocessing / 预处理
    ↓
Partitioning / 分区
    ↓
Prediction / 预测
(Intra/Inter) / (帧内/帧间)
    ↓
Transform / 变换
(DCT/DST) / (DCT/DST)
    ↓
Quantization / 量化
    ↓
Entropy Coding / 熵编码
(CABAC/CAVLC) / (CABAC/CAVLC)
    ↓
Bitstream / 比特流
```

**Decoder Pipeline / 解码器管道：**

```
Bitstream / 比特流
    ↓
Entropy Decoding / 熵解码
    ↓
Dequantization / 反量化
    ↓
Inverse Transform / 反变换
    ↓
Prediction / 预测
    ↓
Reconstruction / 重建
    ↓
Post-processing / 后处理
    ↓
Output Frame / 输出帧
```

### 7.2 Hardware Acceleration / 硬件加速技术

**Hardware Acceleration APIs / 硬件加速API：**

| Platform / 平台 | API              | Supported Codecs / 支持的编解码器 |
| --------------- | ---------------- | --------------------------------- |
| NVIDIA          | NVENC/NVDEC      | H.264, H.265, VP9, AV1            |
| Intel           | Quick Sync Video | H.264, H.265, VP9, AV1            |
| AMD             | VCE/VCN          | H.264, H.265                      |
| Apple           | VideoToolbox     | H.264, H.265, ProRes              |
| Android         | MediaCodec       | H.264, H.265, VP8, VP9            |
| Windows         | DXVA2, D3D11VA   | H.264, H.265, VP9                 |

**NVIDIA NVENC encoding / NVIDIA NVENC编码：**

```bash
# H.264 with NVENC / 使用NVENC编码H.264
ffmpeg -hwaccel cuda -i input.mp4 \
  -c:v h264_nvenc \
  -preset p7 \
  -tune hq \
  -rc vbr \
  -cq 23 \
  -b:v 5M \
  output.mp4

# H.265 with NVENC / 使用NVENC编码H.265
ffmpeg -hwaccel cuda -i input.mp4 \
  -c:v hevc_nvenc \
  -preset p7 \
  -tier high \
  -rc vbr \
  -cq 28 \
  output.mp4
```

**Intel Quick Sync / Intel Quick Sync：**

```bash
# H.264 with QSV / 使用QSV编码H.264
ffmpeg -hwaccel qsv -c:v h264_qsv -i input.mp4 \
  -c:v h264_qsv \
  -preset veryslow \
  -global_quality 23 \
  output.mp4

# H.265 with QSV / 使用QSV编码H.265
ffmpeg -hwaccel qsv -c:v hevc_qsv -i input.mp4 \
  -c:v hevc_qsv \
  -preset veryslow \
  -global_quality 28 \
  output.mp4
```

**Apple VideoToolbox / Apple VideoToolbox：**

```bash
# H.264 with VideoToolbox / 使用VideoToolbox编码H.264
ffmpeg -i input.mp4 \
  -c:v h264_videotoolbox \
  -b:v 5M \
  output.mp4

# H.265 with VideoToolbox / 使用VideoToolbox编码H.265
ffmpeg -i input.mp4 \
  -c:v hevc_videotoolbox \
  -b:v 5M \
  -tag:v hvc1 \
  output.mp4
```

### 7.3 FFmpeg Framework / FFmpeg处理框架

**FFmpeg Architecture / FFmpeg架构：**

```
FFmpeg Components / FFmpeg组件:

├── libavformat    - Muxing/Demuxing / 复用/解复用
├── libavcodec     - Encoding/Decoding / 编码/解码
├── libavfilter    - Filtering / 过滤
├── libavutil      - Utilities / 实用工具
├── libswscale     - Scaling/Color conversion / 缩放/颜色转换
├── libswresample  - Audio resampling / 音频重采样
└── libpostproc    - Post-processing / 后处理
```

**FFmpeg common operations / FFmpeg常用操作：**

```bash
# Get file information / 获取文件信息
ffmpeg -i input.mp4

# Convert format / 转换格式
ffmpeg -i input.avi -c:v libx264 -c:a aac output.mp4

# Extract audio / 提取音频
ffmpeg -i input.mp4 -vn -c:a copy audio.aac

# Extract video / 提取视频
ffmpeg -i input.mp4 -an -c:v copy video.mp4

# Change resolution / 更改分辨率
ffmpeg -i input.mp4 -vf scale=1280:720 output.mp4

# Change frame rate / 更改帧率
ffmpeg -i input.mp4 -r 30 output.mp4

# Trim video / 剪辑视频
ffmpeg -i input.mp4 -ss 00:01:00 -t 00:02:00 -c copy output.mp4

# Concatenate videos / 连接视频
ffmpeg -f concat -i filelist.txt -c copy output.mp4

# Add watermark / 添加水印
ffmpeg -i input.mp4 -i logo.png \
  -filter_complex "overlay=10:10" \
  output.mp4

# Generate thumbnail / 生成缩略图
ffmpeg -i input.mp4 -ss 00:00:10 -vframes 1 thumbnail.jpg
```

**Python FFmpeg wrapper / Python FFmpeg封装：**

```python
import ffmpeg

def transcode_video(input_file, output_file, resolution='1280x720', bitrate='2M'):
    """
    Transcode video using ffmpeg-python
    使用ffmpeg-python转码视频
    """
    try:
        (
            ffmpeg
            .input(input_file)
            .output(
                output_file,
                vcodec='libx264',
                acodec='aac',
                video_bitrate=bitrate,
                s=resolution
            )
            .overwrite_output()
            .run(capture_stdout=True, capture_stderr=True)
        )
        print(f"Transcoding completed: {output_file}")
    except ffmpeg.Error as e:
        print(f"Error: {e.stderr.decode()}")

def get_video_info(input_file):
    """
    Get video metadata / 获取视频元数据
    """
    probe = ffmpeg.probe(input_file)
    video_info = next(s for s in probe['streams'] if s['codec_type'] == 'video')
    audio_info = next((s for s in probe['streams'] if s['codec_type'] == 'audio'), None)
    
    info = {
        'duration': float(probe['format']['duration']),
        'size': int(probe['format']['size']),
        'bitrate': int(probe['format']['bit_rate']),
        'video': {
            'codec': video_info['codec_name'],
            'width': video_info['width'],
            'height': video_info['height'],
            'fps': eval(video_info['r_frame_rate'])
        }
    }
    
    if audio_info:
        info['audio'] = {
            'codec': audio_info['codec_name'],
            'sample_rate': int(audio_info['sample_rate']),
            'channels': audio_info['channels']
        }
    
    return info
```

### 7.4 GStreamer Framework / GStreamer框架

**GStreamer Pipeline / GStreamer管道：**

```bash
# Simple playback / 简单播放
gst-launch-1.0 filesrc location=video.mp4 ! decodebin ! autovideosink

# Transcode to H.264 / 转码为H.264
gst-launch-1.0 filesrc location=input.avi ! decodebin ! x264enc ! mp4mux ! filesink location=output.mp4

# RTSP streaming / RTSP流媒体
gst-launch-1.0 rtspsrc location=rtsp://camera-ip/stream ! decodebin ! autovideosink

# Webcam capture / 网络摄像头捕获
gst-launch-1.0 v4l2src ! videoconvert ! autovideosink
```

**Python GStreamer / Python GStreamer：**

```python
import gi
gi.require_version('Gst', '1.0')
from gi.repository import Gst, GLib

class VideoPlayer:
    """
    Simple video player using GStreamer
    使用GStreamer的简单视频播放器
    """
    def __init__(self):
        Gst.init(None)
        self.pipeline = Gst.Pipeline.new("player")
        
        # Create elements / 创建元素
        self.source = Gst.ElementFactory.make("filesrc", "source")
        self.decoder = Gst.ElementFactory.make("decodebin", "decoder")
        self.convert = Gst.ElementFactory.make("videoconvert", "convert")
        self.sink = Gst.ElementFactory.make("autovideosink", "sink")
        
        # Add elements to pipeline / 添加元素到管道
        self.pipeline.add(self.source)
        self.pipeline.add(self.decoder)
        self.pipeline.add(self.convert)
        self.pipeline.add(self.sink)
        
        # Link elements / 连接元素
        self.source.link(self.decoder)
        self.decoder.connect("pad-added", self.on_pad_added)
    
    def on_pad_added(self, decoder, pad):
        """Dynamically link decoder output / 动态连接解码器输出"""
        pad.link(self.convert.get_static_pad("sink"))
        self.convert.link(self.sink)
    
    def play(self, filename):
        """Play video file / 播放视频文件"""
        self.source.set_property("location", filename)
        self.pipeline.set_state(Gst.State.PLAYING)
        
        # Wait until error or EOS / 等待错误或流结束
        bus = self.pipeline.get_bus()
        bus.timed_pop_filtered(
            Gst.CLOCK_TIME_NONE,
            Gst.MessageType.ERROR | Gst.MessageType.EOS
        )
        
        self.pipeline.set_state(Gst.State.NULL)
```

### 7.5 Encoding Optimization / 编码优化和性能调优

**x264 Preset and Tune / x264预设和调优：**

```bash
# Presets (speed vs compression) / 预设（速度与压缩）
# ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, placebo

# Fast encoding / 快速编码
ffmpeg -i input.mp4 -c:v libx264 -preset ultrafast output.mp4

# Balanced / 平衡
ffmpeg -i input.mp4 -c:v libx264 -preset medium output.mp4

# Best quality / 最佳质量
ffmpeg -i input.mp4 -c:v libx264 -preset veryslow output.mp4

# Tune options / 调优选项
# film, animation, grain, stillimage, psnr, ssim, fastdecode, zerolatency

ffmpeg -i input.mp4 -c:v libx264 -preset medium -tune film output.mp4
ffmpeg -i input.mp4 -c:v libx264 -preset medium -tune animation output.mp4
ffmpeg -i input.mp4 -c:v libx264 -preset ultrafast -tune zerolatency output.mp4
```

**Rate Control Modes / 码率控制模式：**

```bash
# CRF (Constant Rate Factor) - Variable bitrate / CRF（恒定速率因子）- 可变比特率
ffmpeg -i input.mp4 -c:v libx264 -crf 23 output.mp4

# CBR (Constant Bitrate) / CBR（恒定比特率）
ffmpeg -i input.mp4 -c:v libx264 -b:v 5M -minrate 5M -maxrate 5M -bufsize 10M output.mp4

# ABR (Average Bitrate) / ABR（平均比特率）
ffmpeg -i input.mp4 -c:v libx264 -b:v 5M output.mp4

# Two-pass VBR / 两遍VBR
ffmpeg -i input.mp4 -c:v libx264 -b:v 5M -pass 1 -f null /dev/null
ffmpeg -i input.mp4 -c:v libx264 -b:v 5M -pass 2 output.mp4
```

**Parallel Processing / 并行处理：**

```bash
# Use multiple threads / 使用多线程
ffmpeg -i input.mp4 -c:v libx264 -threads 8 output.mp4

# Tile encoding for large videos / 大视频的分块编码
ffmpeg -i input.mp4 -c:v libx265 -x265-params "pools=8:slices=8" output.mp4
```

---

## 8. Emerging Multimedia Technologies / 新兴多媒体技术

### 8.1 Ultra High Definition / 超高清视频

**4K/8K Standards / 4K/8K标准：**

| Resolution / 分辨率 | Pixels / 像素      | Aspect Ratio / 宽高比 | Bitrate / 比特率 |
| ------------------- | ------------------ | --------------------- | ---------------- |
| 4K UHD              | 3840×2160 (8.3MP)  | 16:9                  | 25-50 Mbps       |
| 4K DCI              | 4096×2160 (8.8MP)  | 19:10                 | 30-60 Mbps       |
| 8K UHD              | 7680×4320 (33.2MP) | 16:9                  | 80-160 Mbps      |
| 8K DCI              | 8192×4320 (35.4MP) | 19:10                 | 100-200 Mbps     |

**4K encoding example / 4K编码示例：**

```bash
# 4K H.265 encoding / 4K H.265编码
ffmpeg -i input_4k.mp4 \
  -c:v libx265 \
  -preset slow \
  -crf 22 \
  -pix_fmt yuv420p10le \
  -c:a aac -b:a 256k \
  output_4k.mp4

# 8K AV1 encoding / 8K AV1编码
ffmpeg -i input_8k.mp4 \
  -c:v libsvtav1 \
  -crf 30 \
  -preset 6 \
  -svtav1-params "tune=0" \
  -c:a libopus -b:a 256k \
  output_8k.mkv
```

### 8.2 High Dynamic Range / 高动态范围

**HDR Formats / HDR格式：**

```
HDR10:
- 10-bit color depth / 10位色彩深度
- Static metadata (MaxCLL, MaxFALL) / 静态元数据
- BT.2020 color space / BT.2020色彩空间
- PQ (ST.2084) transfer function / PQ传递函数

HDR10+:
- Dynamic metadata per scene / 每场景动态元数据
- Better highlights and shadows / 更好的高光和阴影
- Samsung/Amazon support / 三星/亚马逊支持

Dolby Vision:
- 12-bit color depth / 12位色彩深度
- Dynamic metadata per frame / 每帧动态元数据
- Dual-layer (base + enhancement) / 双层（基础+增强）
- Premium content / 高端内容

HLG (Hybrid Log-Gamma):
- Backward compatible with SDR / 与SDR向后兼容
- Broadcasting friendly / 广播友好
- BBC and NHK standard / BBC和NHK标准
```

**HDR10 encoding / HDR10编码：**

```bash
# HDR10 H.265 encoding / HDR10 H.265编码
ffmpeg -i input_hdr.mp4 \
  -c:v libx265 \
  -preset slow \
  -crf 18 \
  -pix_fmt yuv420p10le \
  -colorspace bt2020nc \
  -color_primaries bt2020 \
  -color_trc smpte2084 \
  -x265-params "hdr-opt=1:repeat-headers=1:colorprim=bt2020:transfer=smpte2084:colormatrix=bt2020nc:master-display=G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)L(10000000,1):max-cll=1000,400" \
  output_hdr10.mp4
```

### 8.3 Immersive Audio / 沉浸式音频

**Dolby Atmos**

```
Channels: Up to 128 audio tracks / 声道：最多128音轨
Objects: 118 simultaneous objects / 对象：118个同时对象
Height Channels: Yes (overhead speakers) / 高度声道：是（顶置扬声器）
Format: Dolby TrueHD or Dolby Digital Plus / 格式：Dolby TrueHD或Dolby Digital Plus
Use Cases: Cinema, home theater, streaming / 使用场景：电影院、家庭影院、流媒体
```

**DTS:X**

```
Approach: Object-based audio / 方法：基于对象的音频
Channels: Flexible (no fixed channel layout) / 声道：灵活（无固定声道布局）
Backward Compatible: Yes / 向后兼容：是
Competitor: Dolby Atmos / 竞争对手：Dolby Atmos
```

**Spatial Audio / 空间音频：**

```bash
# Create binaural audio / 创建双耳音频
ffmpeg -i input.wav \
  -af "aformat=channel_layouts=stereo,\
       earwax" \
  output_binaural.wav

# 5.1 to stereo downmix / 5.1降混到立体声
ffmpeg -i input_5.1.ac3 \
  -ac 2 \
  -af "pan=stereo|FL=FC+0.30*FL+0.30*BL|FR=FC+0.30*FR+0.30*BR" \
  output_stereo.mp3
```

### 8.4 VR/AR Multimedia / 虚拟现实/增强现实多媒体

**360° Video Formats / 360°视频格式：**

```
Equirectangular Projection / 等距柱状投影:
- Most common format / 最常见格式
- 2:1 aspect ratio / 2:1宽高比
- Spherical mapping / 球面映射

Cubemap Projection / 立方体贴图投影:
- 6 faces (front, back, left, right, top, bottom) / 6个面
- Better for rendering / 更适合渲染
- Less distortion at poles / 极点处失真更少
```

**360° video encoding / 360°视频编码：**

```bash
# Equirectangular 360 video / 等距柱状360视频
ffmpeg -i input_360.mp4 \
  -c:v libx264 \
  -preset slow \
  -crf 20 \
  -vf "v360=e:e:cubic:out_w=3840:out_h=1920" \
  -movflags +faststart \
  -metadata:s:v:0 "stereo_mode=mono" \
  output_360.mp4

# Inject spatial metadata / 注入空间元数据
ffmpeg -i input.mp4 -i input.mp4 \
  -map 0:v -map 1:a -c copy \
  -metadata:s:v:0 "spherical=1" \
  -metadata:s:v:0 "spherical-type=equirectangular" \
  output_spatial.mp4
```

**Spatial Audio for VR / VR空间音频：**

```
Ambisonics:
- Spherical harmonics representation / 球谐函数表示
- First Order (FOA): 4 channels / 一阶：4声道
- Higher Order (HOA): 9, 16, 25+ channels / 高阶：9、16、25+声道

Binaural Audio:
- HRTF (Head-Related Transfer Function) / 头部相关传递函数
- 3D positional audio / 3D定位音频
- Headphone playback / 耳机播放
```

### 8.5 AI-Driven Multimedia / AI驱动的多媒体处理

**Super Resolution / 超分辨率：**

```python
import cv2
from cv2 import dnn_superres

def upscale_image_ai(input_image, output_image, scale=4):
    """
    AI-based image super resolution
    基于AI的图像超分辨率
    """
    # Create SR object / 创建SR对象
    sr = dnn_superres.DnnSuperResImpl_create()
    
    # Load model / 加载模型
    # Options: EDSR, ESPCN, FSRCNN, LapSRN
    model_path = f"EDSR_x{scale}.pb"
    sr.readModel(model_path)
    sr.setModel("edsr", scale)
    
    # Read image / 读取图像
    image = cv2.imread(input_image)
    
    # Upscale / 放大
    result = sr.upsample(image)
    
    # Save / 保存
    cv2.imwrite(output_image, result)
```

**Video Interpolation / 视频插帧：**

```bash
# Frame interpolation for smooth slow-motion
# 帧插值实现平滑慢动作
ffmpeg -i input.mp4 \
  -filter:v "minterpolate='fps=60:mi_mode=mci'" \
  output_60fps.mp4
```

**AI Denoising / AI降噪：**

```bash
# Video denoising / 视频降噪
ffmpeg -i noisy_video.mp4 \
  -vf "hqdn3d=4:3:6:4.5" \
  denoised_video.mp4

# Audio denoising with RNNoise / 使用RNNoise音频降噪
ffmpeg -i noisy_audio.wav \
  -af "arnndn=m=model.rnnn" \
  clean_audio.wav
```

**Content-Aware Encoding / 内容感知编码：**

```python
def calculate_vmaf_score(reference, distorted):
    """
    Calculate VMAF quality score
    计算VMAF质量分数
    """
    import subprocess
    
    cmd = [
        'ffmpeg',
        '-i', distorted,
        '-i', reference,
        '-lavfi', 'libvmaf=log_path=vmaf_output.json',
        '-f', 'null', '-'
    ]
    
    subprocess.run(cmd, capture_output=True)
    
    # Parse VMAF score / 解析VMAF分数
    import json
    with open('vmaf_output.json') as f:
        data = json.load(f)
        vmaf_score = data['pooled_metrics']['vmaf']['mean']
    
    return vmaf_score
```

---

## 9. Multimedia Application Practices / 多媒体应用实践

### 9.1 Web Multimedia Development / Web多媒体开发

**HTML5 Video API**

```html
<!DOCTYPE html>
<html>
<head>
    <title>HTML5 Video Player / HTML5视频播放器</title>
</head>
<body>
    <!-- Basic video player / 基本视频播放器 -->
    <video id="myVideo" width="640" height="360" controls>
        <source src="video.mp4" type="video/mp4">
        <source src="video.webm" type="video/webm">
        <track kind="subtitles" src="subtitles_en.vtt" srclang="en" label="English">
        <track kind="subtitles" src="subtitles_zh.vtt" srclang="zh" label="中文">
        Your browser does not support the video tag.
        您的浏览器不支持视频标签。
    </video>

    <script>
        const video = document.getElementById('myVideo');

        // Play/Pause control / 播放/暂停控制
        function togglePlay() {
            if (video.paused) {
                video.play();
            } else {
                video.pause();
            }
        }

        // Seek to position / 跳转到位置
        function seekTo(seconds) {
            video.currentTime = seconds;
        }

        // Change playback speed / 改变播放速度
        function changeSpeed(rate) {
            video.playbackRate = rate;
        }

        // Event listeners / 事件监听器
        video.addEventListener('loadedmetadata', () => {
            console.log(`Duration / 时长: ${video.duration}`);
            console.log(`Resolution / 分辨率: ${video.videoWidth}x${video.videoHeight}`);
        });

        video.addEventListener('timeupdate', () => {
            const progress = (video.currentTime / video.duration) * 100;
            console.log(`Progress / 进度: ${progress.toFixed(2)}%`);
        });

        video.addEventListener('ended', () => {
            console.log('Video ended / 视频结束');
        });
    </script>
</body>
</html>
```

**HTML5 Audio API**

```html
<audio id="myAudio" controls>
    <source src="audio.mp3" type="audio/mpeg">
    <source src="audio.ogg" type="audio/ogg">
</audio>

<script>
    const audio = document.getElementById('myAudio');

    // Volume control / 音量控制
    function setVolume(value) {
        audio.volume = value; // 0.0 to 1.0
    }

    // Mute/Unmute / 静音/取消静音
    function toggleMute() {
        audio.muted = !audio.muted;
    }
</script>
```

**Web Audio API / Web音频API：**

```javascript
// Web Audio API for advanced audio processing
// Web Audio API用于高级音频处理
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

// Load audio file / 加载音频文件
fetch('audio.mp3')
    .then(response => response.arrayBuffer())
    .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
    .then(audioBuffer => {
        // Create source / 创建源
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;

        // Create gain node (volume control) / 创建增益节点（音量控制）
        const gainNode = audioContext.createGain();
        gainNode.gain.value = 0.5; // 50% volume

        // Create filter / 创建滤波器
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;

        // Connect nodes / 连接节点
        source.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioContext.destination);

        // Play / 播放
        source.start(0);
    });
```

**Media Source Extensions (MSE) / 媒体源扩展：**

```javascript
class AdaptivePlayer {
    constructor(videoElement) {
        this.video = videoElement;
        this.mediaSource = new MediaSource();
        this.video.src = URL.createObjectURL(this.mediaSource);
        
        this.mediaSource.addEventListener('sourceopen', () => {
            this.sourceBuffer = this.mediaSource.addSourceBuffer('video/mp4; codecs="avc1.64001e"');
            this.loadSegment(0);
        });
    }
    
    async loadSegment(segmentIndex) {
        const response = await fetch(`segment${segmentIndex}.m4s`);
        const data = await response.arrayBuffer();
        
        this.sourceBuffer.appendBuffer(data);
        
        this.sourceBuffer.addEventListener('updateend', () => {
            if (segmentIndex < this.totalSegments - 1) {
                this.loadSegment(segmentIndex + 1);
            } else {
                this.mediaSource.endOfStream();
            }
        });
    }
}

// Usage / 使用
const player = new AdaptivePlayer(document.getElementById('video'));
```

### 9.2 Mobile Multimedia / 移动端多媒体处理

**Android MediaCodec / Android MediaCodec：**

```java
import android.media.MediaCodec;
import android.media.MediaFormat;

public class VideoEncoder {
    private MediaCodec encoder;
    private MediaFormat format;
    
    public void setupEncoder(int width, int height, int bitrate) {
        // Create format / 创建格式
        format = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_AVC, width, height);
        format.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
        format.setInteger(MediaFormat.KEY_FRAME_RATE, 30);
        format.setInteger(MediaFormat.KEY_COLOR_FORMAT, 
                         MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);
        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 2);
        
        try {
            // Create encoder / 创建编码器
            encoder = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);
            encoder.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
            encoder.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    public void encodeFrame(byte[] frameData, long presentationTimeUs) {
        int inputBufferIndex = encoder.dequeueInputBuffer(10000);
        if (inputBufferIndex >= 0) {
            ByteBuffer inputBuffer = encoder.getInputBuffer(inputBufferIndex);
            inputBuffer.clear();
            inputBuffer.put(frameData);
            encoder.queueInputBuffer(inputBufferIndex, 0, frameData.length, 
                                   presentationTimeUs, 0);
        }
        
        MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();
        int outputBufferIndex = encoder.dequeueOutputBuffer(bufferInfo, 10000);
        if (outputBufferIndex >= 0) {
            ByteBuffer outputBuffer = encoder.getOutputBuffer(outputBufferIndex);
            // Write encoded data / 写入编码数据
            encoder.releaseOutputBuffer(outputBufferIndex, false);
        }
    }
}
```

**iOS AVFoundation / iOS AVFoundation：**

```swift
import AVFoundation

class VideoProcessor {
    var assetWriter: AVAssetWriter?
    var videoInput: AVAssetWriterInput?
    
    func setupWriter(outputURL: URL, width: Int, height: Int) {
        do {
            // Create asset writer / 创建资产写入器
            assetWriter = try AVAssetWriter(url: outputURL, fileType: .mp4)
            
            // Configure video settings / 配置视频设置
            let videoSettings: [String: Any] = [
                AVVideoCodecKey: AVVideoCodecType.h264,
                AVVideoWidthKey: width,
                AVVideoHeightKey: height,
                AVVideoCompressionPropertiesKey: [
                    AVVideoAverageBitRateKey: 5000000,
                    AVVideoProfileLevelKey: AVVideoProfileLevelH264HighAutoLevel
                ]
            ]
            
            // Create input / 创建输入
            videoInput = AVAssetWriterInput(mediaType: .video, outputSettings: videoSettings)
            videoInput?.expectsMediaDataInRealTime = true
            
            if let writer = assetWriter, let input = videoInput, writer.canAdd(input) {
                writer.add(input)
                writer.startWriting()
                writer.startSession(atSourceTime: .zero)
            }
        } catch {
            print("Error setting up writer: \(error)")
        }
    }
    
    func appendSampleBuffer(_ sampleBuffer: CMSampleBuffer) {
        if let input = videoInput, input.isReadyForMoreMediaData {
            input.append(sampleBuffer)
        }
    }
}
```

### 9.3 Digital Rights Management / 数字版权保护

**DRM Systems / DRM系统：**

| DRM System / DRM系统 | Platform / 平台 | Use Case / 使用场景            |
| -------------------- | --------------- | ------------------------------ |
| Widevine             | Android, Chrome | Google ecosystem / Google生态  |
| FairPlay             | iOS, Safari     | Apple ecosystem / Apple生态    |
| PlayReady            | Windows, Xbox   | Microsoft ecosystem / 微软生态 |
| ClearKey             | Any             | Testing / 测试                 |

**Widevine DRM (Encrypted DASH) / Widevine DRM（加密DASH）：**

```bash
# Encrypt video with Widevine / 使用Widevine加密视频
packager \
  in=input.mp4,stream=video,output=video_encrypted.mp4 \
  in=input.mp4,stream=audio,output=audio_encrypted.mp4 \
  --enable_widevine_encryption \
  --key_server_url "https://license.usercontent.goog/v1/keys" \
  --content_id "content123" \
  --signer "widevine_test" \
  --aes_signing_key "1ae8ccd0e7985cc0b6203a55855a1034afc252980e970ca90e5202689f947ab9" \
  --aes_signing_iv "d58ce954203b7c9a9a9d467f59839249" \
  --mpd_output manifest.mpd
```

**EME (Encrypted Media Extensions) / 加密媒体扩展：**

```javascript
const video = document.querySelector('video');
const config = [{
    initDataTypes: ['cenc'],
    videoCapabilities: [{
        contentType: 'video/mp4; codecs="avc1.64001e"'
    }],
    audioCapabilities: [{
        contentType: 'audio/mp4; codecs="mp4a.40.2"'
    }]
}];

// Check DRM support / 检查DRM支持
navigator.requestMediaKeySystemAccess('com.widevine.alpha', config)
    .then(keySystemAccess => {
        return keySystemAccess.createMediaKeys();
    })
    .then(mediaKeys => {
        return video.setMediaKeys(mediaKeys);
    })
    .then(() => {
        // Load encrypted content / 加载加密内容
        video.src = 'encrypted_video.mp4';
    })
    .catch(error => {
        console.error('DRM setup failed:', error);
    });

// Handle encrypted event / 处理加密事件
video.addEventListener('encrypted', (event) => {
    const session = video.mediaKeys.createSession();
    
    session.addEventListener('message', (event) => {
        // Request license / 请求许可证
        fetch('https://license-server.com/license', {
            method: 'POST',
            headers: {'Content-Type': 'application/octet-stream'},
            body: event.message
        })
        .then(response => response.arrayBuffer())
        .then(license => {
            return session.update(license);
        });
    });
    
    session.generateRequest(event.initDataType, event.initData);
});
```

### 9.4 Performance Optimization / 性能优化和最佳实践

**Video Optimization Checklist / 视频优化清单：**

```
✓ Choose appropriate codec / 选择合适的编解码器
  - H.264 for compatibility / H.264用于兼容性
  - H.265 for 4K content / H.265用于4K内容
  - AV1 for future-proofing / AV1用于面向未来

✓ Optimize encoding settings / 优化编码设置
  - Use CRF for best quality/size ratio / 使用CRF获得最佳质量/大小比
  - Two-pass encoding for critical content / 关键内容使用两遍编码
  - Adjust GOP size for seekability / 调整GOP大小以提高可定位性

✓ Use adaptive streaming / 使用自适应流媒体
  - Multiple bitrate variants / 多比特率变体
  - Segment-based delivery / 基于分段的传输
  - CDN distribution / CDN分发

✓ Enable hardware acceleration / 启用硬件加速
  - GPU encoding/decoding / GPU编码/解码
  - Platform-specific APIs / 平台特定API

✓ Optimize for mobile / 优化移动端
  - Lower bitrates for cellular / 蜂窝网络使用较低比特率
  - Efficient codecs (H.265, VP9) / 高效编解码器
  - Preload strategies / 预加载策略
```

**Image Optimization Best Practices / 图像优化最佳实践：**

```html
<!-- Responsive images / 响应式图像 -->
<picture>
    <!-- Modern formats / 现代格式 -->
    <source srcset="image.avif" type="image/avif">
    <source srcset="image.webp" type="image/webp">
    <!-- Fallback / 后备 -->
    <img src="image.jpg" alt="Description" loading="lazy">
</picture>

<!-- Srcset for different resolutions / Srcset用于不同分辨率 -->
<img 
    srcset="image-320w.jpg 320w,
            image-640w.jpg 640w,
            image-1024w.jpg 1024w"
    sizes="(max-width: 600px) 100vw, 50vw"
    src="image-640w.jpg"
    alt="Description"
    loading="lazy"
>
```

**Lazy Loading / 延迟加载：**

```javascript
// Intersection Observer for lazy loading
// Intersection Observer用于延迟加载
const imageObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.classList.remove('lazy');
            observer.unobserve(img);
        }
    });
});

// Observe all lazy images / 观察所有延迟加载图像
document.querySelectorAll('img.lazy').forEach(img => {
    imageObserver.observe(img);
});
```

---

## Conclusion / 结论

Multimedia types, characteristics, and data formats form the foundation of modern digital media systems, spanning from audio and video encoding to streaming protocols and emerging technologies like 8K video, HDR, and AI-driven processing.

多媒体的类型、特点及数据格式构成了现代数字媒体系统的基础，涵盖了从音频和视频编码到流媒体协议以及8K视频、HDR和AI驱动处理等新兴技术。

**Key Takeaways / 关键要点:**

1. **Format Selection / 格式选择** - Choose formats based on use case, balancing quality, file size, and compatibility. For audio, AAC and Opus excel for streaming; FLAC for archiving. For video, H.264 remains universal, while H.265/AV1 offer better compression for 4K+.
   
   根据使用场景选择格式，平衡质量、文件大小和兼容性。对于音频，AAC和Opus在流媒体方面表现出色；FLAC用于存档。对于视频，H.264仍然通用，而H.265/AV1为4K+提供更好的压缩。

2. **Streaming Optimization / 流媒体优化** - Adaptive bitrate streaming (HLS, DASH) is essential for modern video delivery. Multi-bitrate encoding, CDN distribution, and low-latency protocols enable seamless user experiences across varying network conditions.
   
   自适应比特率流媒体（HLS、DASH）对于现代视频传输至关重要。多比特率编码、CDN分发和低延迟协议能够在不同网络条件下实现无缝的用户体验。

3. **Hardware Acceleration / 硬件加速** - Leverage GPU encoding/decoding (NVENC, Quick Sync, VideoToolbox) for real-time processing and reduced power consumption, especially critical for 4K/8K content and mobile devices.
   
   利用GPU编码/解码（NVENC、Quick Sync、VideoToolbox）实现实时处理和降低功耗，这对于4K/8K内容和移动设备尤为关键。

4. **Emerging Technologies / 新兴技术** - Stay ahead with next-generation codecs (AV1), HDR formats (Dolby Vision), immersive audio (Dolby Atmos), and AI-driven enhancements (super resolution, content-aware encoding).
   
   通过下一代编解码器（AV1）、HDR格式（Dolby Vision）、沉浸式音频（Dolby Atmos）和AI驱动的增强（超分辨率、内容感知编码）保持领先。

5. **Web Integration / Web集成** - HTML5 multimedia APIs, Media Source Extensions, and Web Audio API provide powerful browser-native capabilities for building sophisticated media applications without plugins.
   
   HTML5多媒体API、媒体源扩展和Web Audio API为构建复杂的媒体应用提供了强大的浏览器原生功能，无需插件。

6. **Performance Best Practices / 性能最佳实践** - Implement lazy loading, responsive images, format negotiation (AVIF/WebP/JPEG fallback), and CDN caching to optimize bandwidth and user experience.
   
   实施延迟加载、响应式图像、格式协商（AVIF/WebP/JPEG后备）和CDN缓存，以优化带宽和用户体验。

**Future Trends / 未来趋势:**

- **AV1 Adoption / AV1采用**: As encoding speeds improve and hardware support expands, AV1 will gradually replace H.265 for streaming.
  
  随着编码速度提高和硬件支持扩展，AV1将逐步取代H.265用于流媒体。

- **8K and Beyond / 8K及更高**: Ultra-high-resolution content will become more accessible with improved codecs and 5G networks.
  
  通过改进的编解码器和5G网络，超高分辨率内容将变得更加普及。

- **Interactive Media / 交互式媒体**: WebRTC, low-latency streaming, and cloud gaming will drive demand for sub-second latency.
  
  WebRTC、低延迟流媒体和云游戏将推动对亚秒级延迟的需求。

- **AI Integration / AI集成**: Machine learning will revolutionize encoding (content-aware compression), upscaling (super resolution), and content creation.
  
  机器学习将彻底改变编码（内容感知压缩）、升级（超分辨率）和内容创作。

---

## References / 参考资料

**Standards and Specifications / 标准和规范:**
- ITU-T H.264 (AVC) - Advanced Video Coding
- ITU-T H.265 (HEVC) - High Efficiency Video Coding
- ISO/IEC 23008-2 - HEVC Standard
- ISO/IEC 14496-10 - AVC Standard
- IETF RFC 6716 - Opus Audio Codec
- MPEG-DASH (ISO/IEC 23009-1)
- HLS (RFC 8216)

**Tools and Libraries / 工具和库:**
- FFmpeg: https://ffmpeg.org/
- GStreamer: https://gstreamer.freedesktop.org/
- x264: https://www.videolan.org/developers/x264.html
- x265: https://x265.readthedocs.io/
- libvpx (VP9): https://chromium.googlesource.com/webm/libvpx
- libaom (AV1): https://aomedia.googlesource.com/aom/

**Learning Resources / 学习资源:**
- Multimedia Systems by Ralf Steinmetz and Klara Nahrstedt
- Digital Video and HD by Charles Poynton
- MDN Web Docs - Web media technologies
- FFmpeg Documentation and Wiki

---

**Document Information / 文档信息**

Title / 标题: Multimedia Types, Characteristics and Data Formats / 多媒体的类型特点及数据格式  
Version / 版本: 1.0  
Last Updated / 最后更新: 2024  
Language / 语言: English & 中文 (Bilingual / 双语)
