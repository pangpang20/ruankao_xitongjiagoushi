# Embedded System Networks / 嵌入式系统网络

## 1. Fundamentals of Embedded Networks / 嵌入式网络基础

### 1.1 Definition and Characteristics / 定义与特点

**Embedded Network Definition:**

An embedded network is a communication system that connects embedded devices and systems, enabling data exchange, remote control, and collaborative operations. It is a key enabler of the Internet of Things (IoT) and cyber-physical systems.

**嵌入式网络定义：**

嵌入式网络是连接嵌入式设备和系统的通信系统，使数据交换、远程控制和协同操作成为可能。它是物联网（IoT）和信息物理系统的关键推动技术。

**Key Characteristics:**

| Characteristic         | Description                     | Impact                         |
| ---------------------- | ------------------------------- | ------------------------------ |
| Resource Constraints   | Limited CPU, memory, power      | Requires lightweight protocols |
| Real-time Requirements | Deterministic timing            | Needs priority scheduling      |
| Reliability            | High availability demands       | Fault tolerance mechanisms     |
| Diversity              | Various protocols and standards | Interoperability challenges    |
| Security               | Vulnerable to attacks           | Special security measures      |
| Scalability            | Large number of devices         | Network management complexity  |

**关键特性：**

| 特性       | 描述                | 影响           |
| ---------- | ------------------- | -------------- |
| 资源受限   | CPU、内存、功耗有限 | 需要轻量级协议 |
| 实时性要求 | 确定性时序          | 需要优先级调度 |
| 可靠性     | 高可用性需求        | 容错机制       |
| 多样性     | 各种协议和标准      | 互操作性挑战   |
| 安全性     | 易受攻击            | 特殊安全措施   |
| 可扩展性   | 设备数量庞大        | 网络管理复杂性 |

### 1.2 Network Architecture / 网络架构

**OSI Model Adaptation for Embedded Systems:**

```
┌─────────────────────────────────────────────────┐
│        Application Layer (应用层)                │
│   MQTT, CoAP, HTTP, Modbus, Custom Protocols    │
├─────────────────────────────────────────────────┤
│      Transport Layer (传输层)                    │
│            TCP, UDP, DTLS                       │
├─────────────────────────────────────────────────┤
│       Network Layer (网络层)                     │
│        IPv4, IPv6, 6LoWPAN, RPL                 │
├─────────────────────────────────────────────────┤
│      Data Link Layer (数据链路层)                │
│   Ethernet, WiFi MAC, BLE, Zigbee, LoRaWAN      │
├─────────────────────────────────────────────────┤
│       Physical Layer (物理层)                    │
│  IEEE 802.3, 802.11, 802.15.4, LoRa, NB-IoT     │
└─────────────────────────────────────────────────┘
```

**Network Topologies:**

```
Star Topology (星型拓扑)          Mesh Topology (网状拓扑)
      Gateway                         Node ─── Node
     /   |   \                         /  \   /  \
  Node Node Node                    Node  Node  Node
                                      \   /  \   /
Tree Topology (树型拓扑)               Node ── Node
      Gateway
      /      \
   Node      Node
   /  \      /  \
 Node Node Node Node
```

### 1.3 Differences from Traditional Networks / 与传统网络的区别

**Comparison Table:**

| Aspect         | Traditional Networks | Embedded Networks         |
| -------------- | -------------------- | ------------------------- |
| Bandwidth      | High (Mbps-Gbps)     | Low-Medium (kbps-Mbps)    |
| Power          | AC powered           | Battery/energy harvesting |
| Processing     | Powerful CPUs        | MCU/low-power processors  |
| Memory         | Abundant (GB)        | Limited (KB-MB)           |
| Protocol Stack | Full TCP/IP          | Lightweight stacks        |
| Latency        | Milliseconds         | Microseconds-seconds      |
| Device Count   | Hundreds-thousands   | Millions-billions         |

**对比表：**

| 方面     | 传统网络       | 嵌入式网络        |
| -------- | -------------- | ----------------- |
| 带宽     | 高 (Mbps-Gbps) | 低-中 (kbps-Mbps) |
| 电源     | 交流供电       | 电池/能量采集     |
| 处理能力 | 强大的CPU      | MCU/低功耗处理器  |
| 内存     | 充足 (GB)      | 有限 (KB-MB)      |
| 协议栈   | 完整TCP/IP     | 轻量级协议栈      |
| 延迟     | 毫秒级         | 微秒-秒级         |
| 设备数量 | 数百-数千      | 数百万-数十亿     |

### 1.4 Typical Application Scenarios / 典型应用场景

**Industrial Automation (工业自动化)**
- SCADA systems
- Factory automation (Industry 4.0)
- Process control
- Predictive maintenance

**Smart Home (智能家居)**
- Home automation
- Security systems
- Energy management
- Appliance control

**Healthcare (医疗健康)**
- Patient monitoring
- Medical device networking
- Telemedicine
- Wearable health trackers

**Automotive (汽车电子)**
- In-vehicle networks (CAN, LIN, FlexRay)
- V2X communication
- ADAS (Advanced Driver Assistance Systems)
- Infotainment systems

**Agriculture (智慧农业)**
- Precision farming
- Environmental monitoring
- Livestock tracking
- Irrigation control

---

## 2. Network Communication Technologies / 网络通信技术

### 2.1 Wired Communication / 有线通信

#### 2.1.1 Ethernet

**Technical Specifications:**

| Standard   | Speed    | Cable       | Distance |
| ---------- | -------- | ----------- | -------- |
| 10BASE-T   | 10 Mbps  | Cat3 UTP    | 100m     |
| 100BASE-TX | 100 Mbps | Cat5 UTP    | 100m     |
| 1000BASE-T | 1 Gbps   | Cat5e/6 UTP | 100m     |

**Ethernet Frame Structure:**

```
┌──────────┬──────────┬───────┬──────┬────────┬─────┐
│ Preamble │   SFD    │  DA   │  SA  │ Type/  │ FCS │
│  7 bytes │  1 byte  │6 bytes│6bytes│ Length │4bytes│
└──────────┴──────────┴───────┴──────┴────────┴─────┘
            ← 46-1500 bytes Data Payload →
```

**Example: lwIP Ethernet Driver Integration**

```c
// Ethernet initialization for STM32
#include "lwip/netif.h"
#include "ethernetif.h"

struct netif gnetif;
ip4_addr_t ipaddr, netmask, gw;

void MX_LWIP_Init(void) {
    // IP addresses initialization
    IP4_ADDR(&ipaddr, 192, 168, 1, 10);
    IP4_ADDR(&netmask, 255, 255, 255, 0);
    IP4_ADDR(&gw, 192, 168, 1, 1);
    
    // Initialize lwIP
    lwip_init();
    
    // Add network interface
    netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, 
              &ethernetif_init, &ethernet_input);
    
    // Set as default interface
    netif_set_default(&gnetif);
    netif_set_up(&gnetif);
    netif_set_link_up(&gnetif);
}

// Ethernet packet receive handler
void ethernetif_input(struct netif *netif) {
    struct pbuf *p;
    
    // Receive packet from driver
    p = low_level_input(netif);
    
    if (p != NULL) {
        // Pass to lwIP stack
        if (netif->input(p, netif) != ERR_OK) {
            pbuf_free(p);
        }
    }
}
```

#### 2.1.2 CAN (Controller Area Network)

**CAN Bus Characteristics:**

- Multi-master broadcast network
- Speed: 125 kbps - 1 Mbps
- Maximum nodes: 110 (theoretically)
- Distance: Up to 40m @ 1Mbps, 1km @ 50kbps
- Error detection: CRC, ACK, bit monitoring

**CAN Frame Format:**

```
Standard CAN Frame (CAN 2.0A):
┌────┬─────────┬───┬────┬────┬──────────┬─────┬───┬────┬───┐
│SOF │ 11-bit  │RTR│IDE │R0  │   DLC    │Data │CRC│ACK │EOF│
│1bit│   ID    │1b │1b  │1b  │  4 bits  │0-8B │15b│2b  │7b │
└────┴─────────┴───┴────┴────┴──────────┴─────┴───┴────┴───┘
```

**Example: CAN Communication Code**

```c
// CAN initialization for STM32
#include "stm32f4xx_hal.h"

CAN_HandleTypeDef hcan1;

void CAN_Init(void) {
    hcan1.Instance = CAN1;
    hcan1.Init.Prescaler = 6;
    hcan1.Init.Mode = CAN_MODE_NORMAL;
    hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
    hcan1.Init.TimeSeg1 = CAN_BS1_13TQ;
    hcan1.Init.TimeSeg2 = CAN_BS2_2TQ;
    hcan1.Init.TimeTriggeredMode = DISABLE;
    hcan1.Init.AutoBusOff = ENABLE;
    hcan1.Init.AutoWakeUp = ENABLE;
    hcan1.Init.AutoRetransmission = ENABLE;
    
    HAL_CAN_Init(&hcan1);
    
    // Configure filter
    CAN_FilterTypeDef filter;
    filter.FilterIdHigh = 0x0000;
    filter.FilterIdLow = 0x0000;
    filter.FilterMaskIdHigh = 0x0000;
    filter.FilterMaskIdLow = 0x0000;
    filter.FilterFIFOAssignment = CAN_RX_FIFO0;
    filter.FilterBank = 0;
    filter.FilterMode = CAN_FILTERMODE_IDMASK;
    filter.FilterScale = CAN_FILTERSCALE_32BIT;
    filter.FilterActivation = ENABLE;
    
    HAL_CAN_ConfigFilter(&hcan1, &filter);
    HAL_CAN_Start(&hcan1);
    HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);
}

// Send CAN message
void CAN_SendMessage(uint32_t id, uint8_t *data, uint8_t len) {
    CAN_TxHeaderTypeDef txHeader;
    uint32_t txMailbox;
    
    txHeader.StdId = id;
    txHeader.IDE = CAN_ID_STD;
    txHeader.RTR = CAN_RTR_DATA;
    txHeader.DLC = len;
    txHeader.TransmitGlobalTime = DISABLE;
    
    HAL_CAN_AddTxMessage(&hcan1, &txHeader, data, &txMailbox);
}

// Receive interrupt callback
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {
    CAN_RxHeaderTypeDef rxHeader;
    uint8_t rxData[8];
    
    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &rxHeader, rxData);
    
    // Process received data
    process_can_message(rxHeader.StdId, rxData, rxHeader.DLC);
}
```

#### 2.1.3 RS-485 and Modbus

**RS-485 Characteristics:**

- Differential signaling (balanced transmission)
- Multi-drop network (up to 32 nodes without repeaters)
- Distance: Up to 1200m
- Speed: Up to 10 Mbps (short distance)
- Half-duplex communication

**Modbus Protocol Stack:**

```
┌─────────────────────────────────┐
│   Modbus Application Layer      │  ← Function Codes
├─────────────────────────────────┤
│   Modbus Data Link Layer        │  ← RTU / ASCII / TCP
├─────────────────────────────────┤
│   Physical Layer                │  ← RS-485 / Ethernet
└─────────────────────────────────┘
```

**Modbus RTU Frame:**

```
┌────────┬──────────┬─────────┬──────┬─────┐
│ Slave  │ Function │  Data   │ CRC  │ End │
│Address │   Code   │ N bytes │16-bit│     │
│ 1 byte │  1 byte  │         │      │     │
└────────┴──────────┴─────────┴──────┴─────┘
```

**Example: Modbus RTU Implementation**

```c
// Modbus RTU master implementation
#include <stdint.h>
#include <string.h>

// Modbus function codes
#define MODBUS_FC_READ_COILS           0x01
#define MODBUS_FC_READ_HOLDING_REGS    0x03
#define MODBUS_FC_WRITE_SINGLE_COIL    0x05
#define MODBUS_FC_WRITE_SINGLE_REG     0x06

// CRC calculation
uint16_t modbus_crc16(uint8_t *buffer, uint16_t length) {
    uint16_t crc = 0xFFFF;
    
    for (uint16_t i = 0; i < length; i++) {
        crc ^= buffer[i];
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 0x0001) {
                crc = (crc >> 1) ^ 0xA001;
            } else {
                crc = crc >> 1;
            }
        }
    }
    return crc;
}

// Read holding registers
int modbus_read_holding_registers(uint8_t slave_addr, 
                                   uint16_t start_addr,
                                   uint16_t num_regs,
                                   uint16_t *data) {
    uint8_t tx_buffer[8];
    uint8_t rx_buffer[256];
    uint16_t crc;
    
    // Build request frame
    tx_buffer[0] = slave_addr;
    tx_buffer[1] = MODBUS_FC_READ_HOLDING_REGS;
    tx_buffer[2] = (start_addr >> 8) & 0xFF;
    tx_buffer[3] = start_addr & 0xFF;
    tx_buffer[4] = (num_regs >> 8) & 0xFF;
    tx_buffer[5] = num_regs & 0xFF;
    
    crc = modbus_crc16(tx_buffer, 6);
    tx_buffer[6] = crc & 0xFF;
    tx_buffer[7] = (crc >> 8) & 0xFF;
    
    // Send request via UART
    uart_transmit(tx_buffer, 8);
    
    // Receive response
    int rx_len = uart_receive(rx_buffer, 256, 1000);
    
    // Verify response
    if (rx_len < 5) return -1;
    if (rx_buffer[0] != slave_addr) return -2;
    if (rx_buffer[1] != MODBUS_FC_READ_HOLDING_REGS) return -3;
    
    // Verify CRC
    crc = modbus_crc16(rx_buffer, rx_len - 2);
    uint16_t rx_crc = rx_buffer[rx_len-2] | (rx_buffer[rx_len-1] << 8);
    if (crc != rx_crc) return -4;
    
    // Extract data
    uint8_t byte_count = rx_buffer[2];
    for (int i = 0; i < num_regs; i++) {
        data[i] = (rx_buffer[3 + i*2] << 8) | rx_buffer[4 + i*2];
    }
    
    return 0;
}
```

### 2.2 Wireless Communication / 无线通信

#### 2.2.1 WiFi (IEEE 802.11)

**WiFi Standards Comparison:**

| Standard          | Frequency | Max Speed | Range | Year |
| ----------------- | --------- | --------- | ----- | ---- |
| 802.11b           | 2.4 GHz   | 11 Mbps   | ~100m | 1999 |
| 802.11g           | 2.4 GHz   | 54 Mbps   | ~100m | 2003 |
| 802.11n           | 2.4/5 GHz | 600 Mbps  | ~150m | 2009 |
| 802.11ac          | 5 GHz     | 1.3 Gbps  | ~100m | 2014 |
| 802.11ax (WiFi 6) | 2.4/5 GHz | 9.6 Gbps  | ~150m | 2019 |

**WiFi Connection Process:**

```
Device                           Access Point
  │                                    │
  ├───── Probe Request ────────────────>│
  │<──── Probe Response ────────────────┤
  │                                    │
  ├───── Authentication Request ───────>│
  │<──── Authentication Response ───────┤
  │                                    │
  ├───── Association Request ──────────>│
  │<──── Association Response ──────────┤
  │                                    │
  ├───── EAPOL (4-way handshake) ──────>│
  │<──── EAPOL ─────────────────────────┤
  │                                    │
  └───── Connected ────────────────────>│
```

**Example: ESP32 WiFi Station Mode**

```c
// ESP32 WiFi connection example
#include "esp_wifi.h"
#include "esp_event.h"
#include "nvs_flash.h"

#define WIFI_SSID      "YourSSID"
#define WIFI_PASSWORD  "YourPassword"

static void wifi_event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data) {
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && 
               event_id == WIFI_EVENT_STA_DISCONNECTED) {
        esp_wifi_connect();
        printf("Retry connecting to AP...\n");
    } else if (event_base == IP_EVENT && 
               event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        printf("Got IP: " IPSTR "\n", IP2STR(&event->ip_info.ip));
    }
}

void wifi_init_sta(void) {
    // Initialize NVS
    nvs_flash_init();
    
    // Initialize TCP/IP stack
    esp_netif_init();
    esp_event_loop_create_default();
    esp_netif_create_default_wifi_sta();
    
    // WiFi initialization
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_wifi_init(&cfg);
    
    // Register event handlers
    esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, 
                                &wifi_event_handler, NULL);
    esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, 
                                &wifi_event_handler, NULL);
    
    // WiFi configuration
    wifi_config_t wifi_config = {
        .sta = {
            .ssid = WIFI_SSID,
            .password = WIFI_PASSWORD,
            .threshold.authmode = WIFI_AUTH_WPA2_PSK,
        },
    };
    
    esp_wifi_set_mode(WIFI_MODE_STA);
    esp_wifi_set_config(WIFI_IF_STA, &wifi_config);
    esp_wifi_start();
}
```

#### 2.2.2 Bluetooth and BLE

**Bluetooth Technology Evolution:**

| Version      | Year | Key Features         | Power     | Data Rate |
| ------------ | ---- | -------------------- | --------- | --------- |
| BT 1.0       | 1999 | Basic connectivity   | High      | 1 Mbps    |
| BT 2.0 + EDR | 2004 | Enhanced Data Rate   | High      | 3 Mbps    |
| BT 3.0 + HS  | 2009 | High Speed (WiFi)    | High      | 24 Mbps   |
| BT 4.0 (BLE) | 2010 | Low Energy           | Ultra-low | 1 Mbps    |
| BT 5.0       | 2016 | Long range, 2x speed | Low       | 2 Mbps    |
| BT 5.2       | 2020 | LE Audio, EATT       | Low       | 2 Mbps    |

**BLE GATT Structure:**

```
Profile (配置文件)
  └── Service (服务)
       ├── Characteristic (特征)
       │    ├── Value (值)
       │    └── Descriptor (描述符)
       └── Characteristic
            ├── Value
            └── Descriptor
```

**Example: BLE GATT Server (Nordic nRF52)**

```c
// BLE GATT custom service example
#include "ble.h"
#include "ble_srv_common.h"

// UUIDs (128-bit)
#define CUSTOM_SERVICE_UUID      0x1234
#define CUSTOM_CHAR_UUID         0x5678

typedef struct {
    uint16_t                     service_handle;
    ble_gatts_char_handles_t     char_handles;
    uint16_t                     conn_handle;
} ble_custom_service_t;

// Initialize custom service
uint32_t ble_custom_service_init(ble_custom_service_t * p_service) {
    uint32_t err_code;
    ble_uuid_t ble_uuid;
    
    // Add service
    ble_uuid.type = BLE_UUID_TYPE_BLE;
    ble_uuid.uuid = CUSTOM_SERVICE_UUID;
    
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY,
                                         &ble_uuid,
                                         &p_service->service_handle);
    if (err_code != NRF_SUCCESS) return err_code;
    
    // Add characteristic
    ble_gatts_char_md_t char_md;
    ble_gatts_attr_t    attr_char_value;
    ble_uuid_t          char_uuid;
    ble_gatts_attr_md_t attr_md;
    
    memset(&char_md, 0, sizeof(char_md));
    char_md.char_props.read  = 1;
    char_md.char_props.write = 1;
    char_md.char_props.notify = 1;
    
    char_uuid.type = BLE_UUID_TYPE_BLE;
    char_uuid.uuid = CUSTOM_CHAR_UUID;
    
    memset(&attr_md, 0, sizeof(attr_md));
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
    attr_md.vloc = BLE_GATTS_VLOC_STACK;
    
    memset(&attr_char_value, 0, sizeof(attr_char_value));
    attr_char_value.p_uuid    = &char_uuid;
    attr_char_value.p_attr_md = &attr_md;
    attr_char_value.init_len  = sizeof(uint8_t);
    attr_char_value.max_len   = 20;
    
    err_code = sd_ble_gatts_characteristic_add(p_service->service_handle,
                                                 &char_md,
                                                 &attr_char_value,
                                                 &p_service->char_handles);
    
    return err_code;
}

// Send notification
uint32_t ble_custom_value_update(ble_custom_service_t * p_service,
                                  uint8_t * data, uint16_t length) {
    if (p_service->conn_handle == BLE_CONN_HANDLE_INVALID) {
        return NRF_ERROR_INVALID_STATE;
    }
    
    ble_gatts_hvx_params_t params;
    memset(&params, 0, sizeof(params));
    params.type   = BLE_GATT_HVX_NOTIFICATION;
    params.handle = p_service->char_handles.value_handle;
    params.p_data = data;
    params.p_len  = &length;
    
    return sd_ble_gatts_hvx(p_service->conn_handle, &params);
}
```

#### 2.2.3 Zigbee (IEEE 802.15.4)

**Zigbee Network Characteristics:**

- Frequency: 2.4 GHz (global), 868 MHz (Europe), 915 MHz (Americas)
- Data Rate: 250 kbps @ 2.4GHz
- Range: 10-100 meters
- Network Size: Up to 65,000 nodes
- Power: Ultra-low (battery life years)

**Zigbee Device Types:**

```
┌──────────────────────────────────────┐
│     Coordinator (协调器)              │  ← One per network
│     - Network formation              │
│     - Security management            │
└──────────────────────────────────────┘
         │
         ├────── Router (路由器) ────────── End Device (终端设备)
         │       - Routing                 - Sensor/actuator
         │       - Can have children       - Low power
         │                                 - Sleep mode
         └────── Router ──────────────────── End Device
```

**Zigbee Protocol Stack:**

```
┌─────────────────────────────────────┐
│  Application Layer (应用层)          │  ← ZCL, Profiles
├─────────────────────────────────────┤
│  APS (Application Support) Layer    │  ← Binding, Group
├─────────────────────────────────────┤
│  Network Layer (网络层)              │  ← Routing, AODV
├─────────────────────────────────────┤
│  MAC Layer (IEEE 802.15.4)          │  ← CSMA/CA
├─────────────────────────────────────┤
│  PHY Layer (IEEE 802.15.4)          │  ← 2.4GHz radio
└─────────────────────────────────────┘
```

#### 2.2.4 LoRa and LoRaWAN

**LoRa Technical Parameters:**

| Parameter         | Value                       | Notes          |
| ----------------- | --------------------------- | -------------- |
| Frequency         | 433/868/915 MHz             | Regional bands |
| Modulation        | CSS (Chirp Spread Spectrum) | Proprietary    |
| Sensitivity       | -148 dBm                    | Excellent      |
| Range             | 2-15 km                     | Line of sight  |
| Data Rate         | 0.3-50 kbps                 | Adjustable     |
| Power Consumption | 10-100 mW TX                | Very low       |

**LoRaWAN Network Architecture:**

```
End Devices ───┐
End Devices ───┼──> Gateway ──> Network Server ──> Application Server
End Devices ───┘         │
                         ├──> Gateway ──> (Same Network Server)
                         │
                         └──> Gateway ──> (Same Network Server)
```

**LoRaWAN Classes:**

- **Class A**: Lowest power, bi-directional, end-device scheduled
- **Class B**: Scheduled receive slots, beacon synchronized
- **Class C**: Continuous receive, lowest latency, higher power

**Example: LoRaWAN Device Code (using LMIC library)**

```c
// LoRaWAN OTAA example for Arduino
#include <lmic.h>
#include <hal/hal.h>

// Device EUI (little-endian)
static const u1_t PROGMEM DEVEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
// Application EUI (little-endian)
static const u1_t PROGMEM APPEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
// Application Key (big-endian)
static const u1_t PROGMEM APPKEY[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

void os_getDevEui (u1_t* buf) { memcpy_P(buf, DEVEUI, 8);}
void os_getArtEui (u1_t* buf) { memcpy_P(buf, APPEUI, 8);}
void os_getDevKey (u1_t* buf) { memcpy_P(buf, APPKEY, 16);}

// Pin mapping
const lmic_pinmap lmic_pins = {
    .nss = 10,
    .rxtx = LMIC_UNUSED_PIN,
    .rst = 9,
    .dio = {2, 6, 7},
};

static osjob_t sendjob;
const unsigned TX_INTERVAL = 60; // seconds

void onEvent (ev_t ev) {
    switch(ev) {
        case EV_JOINED:
            Serial.println(F("EV_JOINED"));
            // Disable link check validation
            LMIC_setLinkCheckMode(0);
            break;
        case EV_TXCOMPLETE:
            Serial.println(F("EV_TXCOMPLETE"));
            if (LMIC.txrxFlags & TXRX_ACK)
                Serial.println(F("Received ack"));
            if (LMIC.dataLen) {
                Serial.print(F("Received "));
                Serial.print(LMIC.dataLen);
                Serial.println(F(" bytes"));
            }
            // Schedule next transmission
            os_setTimedCallback(&sendjob, os_getTime()+sec2osticks(TX_INTERVAL), do_send);
            break;
        case EV_JOIN_FAILED:
            Serial.println(F("EV_JOIN_FAILED"));
            break;
        default:
            Serial.println(F("Unknown event"));
            break;
    }
}

void do_send(osjob_t* j){
    // Check if there is not a current TX/RX job running
    if (LMIC.opmode & OP_TXRXPEND) {
        Serial.println(F("OP_TXRXPEND, not sending"));
    } else {
        // Prepare upstream data transmission
        uint8_t payload[] = {0x48, 0x65, 0x6C, 0x6C, 0x6F}; // "Hello"
        LMIC_setTxData2(1, payload, sizeof(payload), 0);
        Serial.println(F("Packet queued"));
    }
}

void setup() {
    Serial.begin(9600);
    
    // LMIC init
    os_init();
    LMIC_reset();
    
    // Start joining
    LMIC_startJoining();
    
    // Start job
    do_send(&sendjob);
}

void loop() {
    os_runloop_once();
}
```

### 2.3 Cellular Networks / 蜂窝网络

#### 2.3.1 NB-IoT (Narrowband IoT)

**NB-IoT Characteristics:**

| Feature          | Specification               |
| ---------------- | --------------------------- |
| Frequency        | Licensed LTE bands          |
| Bandwidth        | 180 kHz                     |
| Data Rate        | 200 kbps (DL), 20 kbps (UL) |
| Latency          | 1.6 - 10 seconds            |
| Coverage         | +20 dB over GPRS            |
| Battery Life     | 10+ years                   |
| Devices per Cell | 50,000+                     |

**NB-IoT Deployment Modes:**

```
1. Standalone:  GSM spectrum replacement
2. Guard Band:  LTE guard band utilization
3. In-Band:     Within LTE carrier
```

**Example: NB-IoT Module (Quectel BC95) AT Commands**

```c
// NB-IoT connection and data transmission
#include <stdio.h>
#include <string.h>

// Send AT command
void send_at_command(const char* cmd) {
    uart_printf("%s\r\n", cmd);
    delay_ms(100);
}

// Initialize NB-IoT module
int nbiot_init(void) {
    // Check module
    send_at_command("AT");
    
    // Check SIM card
    send_at_command("AT+CIMI");
    
    // Set APN
    send_at_command("AT+CGDCONT=1,\"IP\",\"your_apn\"");
    
    // Attach to network
    send_at_command("AT+CGATT=1");
    delay_ms(5000);
    
    // Check attach status
    send_at_command("AT+CGATT?");
    
    // Connect to server
    send_at_command("AT+QIOPEN=1,0,\"UDP\",\"server.com\",5683");
    
    return 0;
}

// Send data via CoAP/UDP
void nbiot_send_data(const char* data, int len) {
    char cmd[128];
    
    // Send data length
    sprintf(cmd, "AT+QISEND=0,%d", len);
    send_at_command(cmd);
    delay_ms(50);
    
    // Send actual data
    uart_transmit((uint8_t*)data, len);
    delay_ms(100);
}

// Receive data
int nbiot_receive_data(char* buffer, int max_len) {
    // Check if data available
    send_at_command("AT+QIRD=0,1500");
    
    // Parse response and copy to buffer
    // Implementation depends on specific module response format
    
    return 0; // Return received length
}
```

#### 2.3.2 LTE-M (LTE Cat-M1)

**LTE-M vs NB-IoT Comparison:**

| Feature           | LTE-M                 | NB-IoT                |
| ----------------- | --------------------- | --------------------- |
| Bandwidth         | 1.4 MHz               | 180 kHz               |
| Peak Data Rate    | 1 Mbps                | 250 kbps              |
| Latency           | 10-15 ms              | 1.6-10 s              |
| Mobility          | Full (up to 160 km/h) | Limited               |
| Voice Support     | VoLTE                 | No                    |
| Power Consumption | Low                   | Ultra-low             |
| Use Cases         | Wearables, tracking   | Smart meters, sensors |

---

## 3. Network Protocol Stack / 网络协议栈

### 3.1 Lightweight TCP/IP Stacks / 轻量级TCP/IP协议栈

#### 3.1.1 lwIP (Lightweight IP)

**lwIP Architecture:**

```
┌──────────────────────────────────────────┐
│     Application (Socket API / RAW API)   │
├──────────────────────────────────────────┤
│  TCP          UDP         ICMP    IGMP   │
├──────────────────────────────────────────┤
│              IP (IPv4/IPv6)              │
├──────────────────────────────────────────┤
│         ARP          DHCP    DNS         │
├──────────────────────────────────────────┤
│          Network Interface (netif)       │
└──────────────────────────────────────────┘
```

**lwIP Configuration Options (lwipopts.h):**

```c
// Memory options
#define MEM_ALIGNMENT           4
#define MEM_SIZE                (16*1024)  // Heap memory size
#define MEMP_NUM_PBUF           16         // Number of pbufs
#define MEMP_NUM_TCP_PCB        8          // TCP connections
#define MEMP_NUM_TCP_SEG        16         // TCP segments
#define PBUF_POOL_SIZE          24         // Packet buffers

// Protocol options
#define LWIP_IPV4               1
#define LWIP_IPV6               0
#define LWIP_TCP                1
#define LWIP_UDP                1
#define LWIP_DHCP               1
#define LWIP_DNS                1

// TCP options
#define TCP_MSS                 1460       // Maximum segment size
#define TCP_WND                 (4*TCP_MSS) // TCP window size
#define TCP_SND_BUF             (4*TCP_MSS) // TCP send buffer

// Performance tuning
#define LWIP_NETIF_TX_SINGLE_PBUF  1
#define LWIP_CHECKSUM_ON_COPY   1
```

**Example: lwIP TCP Server**

```c
// Simple TCP echo server using lwIP RAW API
#include "lwip/tcp.h"

struct tcp_pcb *echo_pcb;

// Data received callback
static err_t echo_recv(void *arg, struct tcp_pcb *tpcb, 
                       struct pbuf *p, err_t err) {
    if (p == NULL) {
        // Connection closed
        tcp_close(tpcb);
        return ERR_OK;
    }
    
    // Echo back the data
    tcp_write(tpcb, p->payload, p->len, TCP_WRITE_FLAG_COPY);
    tcp_output(tpcb);
    
    // Free the pbuf
    pbuf_free(p);
    
    return ERR_OK;
}

// Connection accepted callback
static err_t echo_accept(void *arg, struct tcp_pcb *newpcb, err_t err) {
    // Set callback
    tcp_recv(newpcb, echo_recv);
    
    return ERR_OK;
}

// Initialize echo server
void echo_server_init(void) {
    // Create new TCP PCB
    echo_pcb = tcp_new();
    
    // Bind to port 7
    tcp_bind(echo_pcb, IP_ADDR_ANY, 7);
    
    // Listen for incoming connections
    echo_pcb = tcp_listen(echo_pcb);
    
    // Set accept callback
    tcp_accept(echo_pcb, echo_accept);
}
```

#### 3.1.2 uIP (Micro IP)

**uIP Characteristics:**

- Extremely small code size (~5-10 KB)
- Minimal RAM usage (~几百bytes)
- Single-packet buffer approach
- Designed for 8/16-bit microcontrollers

**uIP vs lwIP:**

| Feature     | uIP          | lwIP       |
| ----------- | ------------ | ---------- |
| Code Size   | ~5 KB        | ~50 KB     |
| RAM         | <1 KB        | >10 KB     |
| Performance | Low          | High       |
| Features    | Minimal      | Complete   |
| Target      | 8/16-bit MCU | 32-bit MCU |

### 3.2 IoT Application Protocols / 物联网应用层协议

#### 3.2.1 MQTT (Message Queuing Telemetry Transport)

**MQTT Architecture:**

```
Publisher ──┐
Publisher ──┼──> MQTT Broker ──> Subscriber
Publisher ──┘         │
                      └──> Subscriber
```

**MQTT QoS Levels:**

| QoS | Name          | Description                | Use Case          |
| --- | ------------- | -------------------------- | ----------------- |
| 0   | At most once  | Fire and forget            | Sensor readings   |
| 1   | At least once | Acknowledged delivery      | Important data    |
| 2   | Exactly once  | Guaranteed single delivery | Critical commands |

**MQTT Packet Structure:**

```
┌──────────────┬─────────────────┬─────────────┐
│ Fixed Header │ Variable Header │   Payload   │
│   2-5 bytes  │   (Optional)    │ (Optional)  │
└──────────────┴─────────────────┴─────────────┘

Fixed Header:
Bit    7 6 5 4    3 2 1 0
      ┌────────┬──────────┐
      │Message │  Flags   │
      │  Type  │          │
      └────────┴──────────┘
```

**Example: MQTT Client (using Paho Embedded C)**

```c
// MQTT client example
#include "MQTTClient.h"

#define BROKER_ADDRESS "tcp://broker.hivemq.com:1883"
#define CLIENT_ID      "embedded_device_001"
#define TOPIC          "sensors/temperature"
#define QOS            1
#define TIMEOUT        10000L

void messageArrived(MessageData* data) {
    printf("Message arrived on topic %.*s: %.*s\n",
           data->topicName->lenstring.len,
           data->topicName->lenstring.data,
           data->message->payloadlen,
           (char*)data->message->payload);
}

int main() {
    Network network;
    MQTTClient client;
    unsigned char sendbuf[80], readbuf[80];
    int rc;
    
    // Initialize network
    NetworkInit(&network);
    NetworkConnect(&network, "broker.hivemq.com", 1883);
    
    // Initialize MQTT client
    MQTTClientInit(&client, &network, 1000,
                   sendbuf, sizeof(sendbuf),
                   readbuf, sizeof(readbuf));
    
    // Connect options
    MQTTPacket_connectData connectData = MQTTPacket_connectData_initializer;
    connectData.MQTTVersion = 3;
    connectData.clientID.cstring = CLIENT_ID;
    connectData.keepAliveInterval = 20;
    connectData.cleansession = 1;
    
    // Connect to broker
    rc = MQTTConnect(&client, &connectData);
    if (rc != SUCCESS) {
        printf("Failed to connect, return code %d\n", rc);
        return -1;
    }
    
    // Subscribe to topic
    rc = MQTTSubscribe(&client, TOPIC, QOS, messageArrived);
    if (rc != SUCCESS) {
        printf("Failed to subscribe, return code %d\n", rc);
    }
    
    // Publish message
    MQTTMessage message;
    char payload[] = "{\"temperature\": 25.5}";
    message.qos = QOS;
    message.retained = 0;
    message.payload = (void*)payload;
    message.payloadlen = strlen(payload);
    
    rc = MQTTPublish(&client, TOPIC, &message);
    if (rc != SUCCESS) {
        printf("Failed to publish, return code %d\n", rc);
    }
    
    // Main loop
    while (1) {
        MQTTYield(&client, 1000);
    }
    
    return 0;
}
```

#### 3.2.2 CoAP (Constrained Application Protocol)

**CoAP Characteristics:**

- RESTful protocol for constrained devices
- Runs over UDP (default port 5683)
- Similar to HTTP but optimized for IoT
- Supports observe pattern (publish-subscribe)
- DTLS for security

**CoAP Message Format:**

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver| T |  TKL  |      Code     |          Message ID           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Token (if any, TKL bytes) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Options (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 1 1 1 1 1 1 1|    Payload (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**CoAP Methods and Response Codes:**

```
Methods:
  GET    = 0.01
  POST   = 0.02
  PUT    = 0.03
  DELETE = 0.04

Response Codes:
  2.01 Created
  2.02 Deleted
  2.03 Valid
  2.04 Changed
  2.05 Content
  4.04 Not Found
  5.00 Internal Server Error
```

**Example: CoAP Server (libcoap)**

```c
// CoAP server example using libcoap
#include "coap3/coap.h"

// GET handler for /temperature resource
static void temperature_get_handler(coap_resource_t *resource,
                                     coap_session_t *session,
                                     const coap_pdu_t *request,
                                     const coap_string_t *query,
                                     coap_pdu_t *response) {
    unsigned char buf[3];
    const char* data = "{\"temperature\": 25.5}";
    
    // Set response code
    coap_pdu_set_code(response, COAP_RESPONSE_CODE_CONTENT);
    
    // Add Content-Format option (application/json = 50)
    coap_add_option(response, COAP_OPTION_CONTENT_FORMAT,
                    coap_encode_var_safe(buf, sizeof(buf), 
                    COAP_MEDIATYPE_APPLICATION_JSON), buf);
    
    // Add payload
    coap_add_data(response, strlen(data), (const uint8_t *)data);
}

int main(void) {
    coap_context_t *ctx = NULL;
    coap_address_t serv_addr;
    coap_resource_t *resource = NULL;
    coap_endpoint_t *endpoint = NULL;
    
    // Initialize CoAP context
    coap_startup();
    
    // Prepare server address
    coap_address_init(&serv_addr);
    serv_addr.addr.sin.sin_family = AF_INET;
    serv_addr.addr.sin.sin_addr.s_addr = INADDR_ANY;
    serv_addr.addr.sin.sin_port = htons(5683);
    
    // Create CoAP context
    ctx = coap_new_context(NULL);
    if (!ctx) {
        return -1;
    }
    
    // Create endpoint
    endpoint = coap_new_endpoint(ctx, &serv_addr, COAP_PROTO_UDP);
    if (!endpoint) {
        coap_free_context(ctx);
        return -1;
    }
    
    // Create resource
    resource = coap_resource_init(coap_make_str_const("temperature"), 0);
    coap_register_handler(resource, COAP_REQUEST_GET, temperature_get_handler);
    coap_add_resource(ctx, resource);
    
    // Main loop
    while (1) {
        coap_io_process(ctx, COAP_IO_WAIT);
    }
    
    coap_free_context(ctx);
    coap_cleanup();
    
    return 0;
}
```

### 3.3 6LoWPAN and IPv6 / 6LoWPAN与IPv6支持

**6LoWPAN (IPv6 over Low-Power Wireless Personal Area Networks):**

6LoWPAN enables IPv6 packets to be sent and received over IEEE 802.15.4 based networks.

**6LoWPAN Adaptation Layer:**

```
┌─────────────────────────────────────┐
│          IPv6 Layer                 │
├─────────────────────────────────────┤
│      6LoWPAN Adaptation Layer       │  ← Header compression
│  - Header Compression (HC1, IPHC)   │  ← Fragmentation
│  - Fragmentation & Reassembly       │  ← Mesh routing
├─────────────────────────────────────┤
│     IEEE 802.15.4 MAC/PHY           │
└─────────────────────────────────────┘
```

**Header Compression Example:**

```
Normal IPv6 Header: 40 bytes
After 6LoWPAN Compression: 2-3 bytes (typical)

IPv6 MTU: 1280 bytes
802.15.4 Frame: 127 bytes payload
→ Fragmentation required
```

**RPL (IPv6 Routing Protocol for Low-Power and Lossy Networks):**

```
DODAG (Destination Oriented DAG):
        Root
       /    \
     Node   Node
     /  \     \
   Node Node  Node
```

---

## 4. Network Design and Implementation / 网络设计与实现

### 4.1 Network Hardware Interface Design / 网络硬件接口设计

#### 4.1.1 Ethernet PHY Interface

**Common Ethernet PHY Chips:**

| Chip    | Manufacturer      | Interface | Speed            |
| ------- | ----------------- | --------- | ---------------- |
| LAN8720 | Microchip         | RMII      | 10/100 Mbps      |
| DP83848 | Texas Instruments | MII/RMII  | 10/100 Mbps      |
| KSZ8081 | Microchip         | MII/RMII  | 10/100 Mbps      |
| RTL8211 | Realtek           | RGMII     | 10/100/1000 Mbps |

**RMII Interface Signals:**

```
MCU                         PHY (LAN8720)
┌──────────┐               ┌──────────┐
│          │──RMII_TXD0──>│          │
│          │──RMII_TXD1──>│          │──> Ethernet
│   MAC    │──RMII_TX_EN─>│   PHY    │    Cable
│          │<─RMII_RXD0───│          │
│          │<─RMII_RXD1───│          │
│          │<─RMII_CRS_DV─│          │
│          │──RMII_REF_CLK│          │
│          │──RMII_MDC───>│          │
│          │<>RMII_MDIO<>│          │
└──────────┘               └──────────┘
```

**Example: STM32 Ethernet PHY Configuration**

```c
// STM32 HAL Ethernet PHY setup
#include "stm32f4xx_hal.h"

ETH_HandleTypeDef heth;

void HAL_ETH_MspInit(ETH_HandleTypeDef* ethHandle) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    if(ethHandle->Instance==ETH) {
        // Enable clocks
        __HAL_RCC_ETH_CLK_ENABLE();
        __HAL_RCC_GPIOA_CLK_ENABLE();
        __HAL_RCC_GPIOC_CLK_ENABLE();
        __HAL_RCC_GPIOG_CLK_ENABLE();
        
        // Configure RMII pins
        // PA1: RMII_REF_CLK, PA2: RMII_MDIO, PA7: RMII_CRS_DV
        GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_7;
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
        GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        
        // PC1: RMII_MDC, PC4: RMII_RXD0, PC5: RMII_RXD1
        GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5;
        HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        
        // PG11: RMII_TX_EN, PG13: RMII_TXD0, PG14: RMII_TXD1
        GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_13|GPIO_PIN_14;
        HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
        
        // Enable Ethernet interrupt
        HAL_NVIC_SetPriority(ETH_IRQn, 0, 0);
        HAL_NVIC_EnableIRQ(ETH_IRQn);
    }
}

// Initialize Ethernet
void MX_ETH_Init(void) {
    uint8_t MACAddr[6];
    
    heth.Instance = ETH;
    MACAddr[0] = 0x00;
    MACAddr[1] = 0x80;
    MACAddr[2] = 0xE1;
    MACAddr[3] = 0x00;
    MACAddr[4] = 0x00;
    MACAddr[5] = 0x00;
    
    heth.Init.MACAddr = &MACAddr[0];
    heth.Init.MediaInterface = HAL_ETH_RMII_MODE;
    heth.Init.TxDesc = DMATxDscrTab;
    heth.Init.RxDesc = DMARxDscrTab;
    heth.Init.RxBuffLen = 1524;
    
    if (HAL_ETH_Init(&heth) != HAL_OK) {
        Error_Handler();
    }
    
    // Configure PHY via MDIO
    uint32_t phyreg;
    HAL_ETH_ReadPHYRegister(&heth, PHY_BCR, &phyreg);
    phyreg |= PHY_RESET;
    HAL_ETH_WritePHYRegister(&heth, PHY_BCR, phyreg);
    HAL_Delay(PHY_RESET_DELAY);
}
```

#### 4.1.2 Wireless Module Interface

**Common Wireless Module Interfaces:**

- **UART**: Simple, low-speed (AT commands)
- **SPI**: High-speed, more CPU overhead
- **SDIO**: Very high-speed (WiFi modules)
- **USB**: Flexible, higher complexity

**Example: ESP8266 UART Interface**

```c
// ESP8266 WiFi module control via UART
#include <string.h>
#include <stdio.h>

#define ESP8266_UART    USART2
#define TIMEOUT_MS      5000

// Send AT command and wait for response
int esp8266_send_command(const char* cmd, const char* expected_resp) {
    char rx_buffer[256];
    int rx_len = 0;
    uint32_t start_time;
    
    // Clear RX buffer
    memset(rx_buffer, 0, sizeof(rx_buffer));
    
    // Send command
    uart_printf(ESP8266_UART, "%s\r\n", cmd);
    
    // Wait for response
    start_time = HAL_GetTick();
    while ((HAL_GetTick() - start_time) < TIMEOUT_MS) {
        if (uart_available(ESP8266_UART)) {
            rx_buffer[rx_len++] = uart_getc(ESP8266_UART);
            
            // Check for expected response
            if (strstr(rx_buffer, expected_resp) != NULL) {
                return 0; // Success
            }
            
            // Check for error
            if (strstr(rx_buffer, "ERROR") != NULL) {
                return -1; // Error
            }
        }
    }
    
    return -2; // Timeout
}

// Connect to WiFi AP
int esp8266_connect_ap(const char* ssid, const char* password) {
    char cmd[128];
    
    // Set station mode
    if (esp8266_send_command("AT+CWMODE=1", "OK") != 0) {
        return -1;
    }
    
    // Connect to AP
    sprintf(cmd, "AT+CWJAP=\"%s\",\"%s\"", ssid, password);
    if (esp8266_send_command(cmd, "OK") != 0) {
        return -2;
    }
    
    return 0;
}

// Create TCP connection
int esp8266_tcp_connect(const char* server, uint16_t port) {
    char cmd[128];
    
    sprintf(cmd, "AT+CIPSTART=\"TCP\",\"%s\",%d", server, port);
    if (esp8266_send_command(cmd, "CONNECT") != 0) {
        return -1;
    }
    
    return 0;
}

// Send data
int esp8266_tcp_send(const uint8_t* data, uint16_t len) {
    char cmd[32];
    
    // Prepare to send
    sprintf(cmd, "AT+CIPSEND=%d", len);
    if (esp8266_send_command(cmd, ">") != 0) {
        return -1;
    }
    
    // Send actual data
    uart_transmit(ESP8266_UART, data, len);
    
    // Wait for send confirmation
    delay_ms(100);
    
    return 0;
}
```

### 4.2 Driver Development / 驱动程序开发

**Network Driver Architecture:**

```
┌─────────────────────────────────┐
│     Application Layer           │
├─────────────────────────────────┤
│     Protocol Stack (lwIP)       │
├─────────────────────────────────┤
│     Network Interface Layer     │  ← Driver abstraction
├─────────────────────────────────┤
│     Hardware Driver             │  ← Register access
│  - Initialization               │
│  - TX/RX functions              │
│  - Interrupt handlers           │
├─────────────────────────────────┤
│     Hardware (PHY/MAC)          │
└─────────────────────────────────┘
```

**Example: Network Driver Template**

```c
// Generic network driver template
#include "netif/etharp.h"
#include "lwip/timeouts.h"

#define NETIF_MTU       1500
#define NETIF_HWADDR_LEN 6

struct netif_driver {
    uint8_t mac_addr[NETIF_HWADDR_LEN];
    // Hardware-specific fields
    void* hw_base;
    uint32_t irq_num;
};

// Low-level initialization
static void low_level_init(struct netif *netif) {
    struct netif_driver *driver = (struct netif_driver*)netif->state;
    
    // Set MAC hardware address
    netif->hwaddr_len = NETIF_HWADDR_LEN;
    memcpy(netif->hwaddr, driver->mac_addr, NETIF_HWADDR_LEN);
    
    // Set MTU
    netif->mtu = NETIF_MTU;
    
    // Set capabilities
    netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
    
    // Initialize hardware
    hw_init(driver->hw_base);
    hw_set_mac_address(driver->hw_base, driver->mac_addr);
    hw_enable_interrupts(driver->hw_base);
}

// Low-level output function
static err_t low_level_output(struct netif *netif, struct pbuf *p) {
    struct netif_driver *driver = (struct netif_driver*)netif->state;
    struct pbuf *q;
    uint8_t *buffer;
    uint16_t total_len = 0;
    
    // Allocate TX buffer
    buffer = hw_get_tx_buffer(driver->hw_base);
    if (buffer == NULL) {
        return ERR_BUF;
    }
    
    // Copy pbuf chain to TX buffer
    for (q = p; q != NULL; q = q->next) {
        memcpy(&buffer[total_len], q->payload, q->len);
        total_len += q->len;
    }
    
    // Transmit packet
    hw_transmit_packet(driver->hw_base, buffer, total_len);
    
    return ERR_OK;
}

// Low-level input function
static struct pbuf* low_level_input(struct netif *netif) {
    struct netif_driver *driver = (struct netif_driver*)netif->state;
    struct pbuf *p, *q;
    uint16_t len;
    uint8_t *buffer;
    
    // Get received packet
    len = hw_get_rx_length(driver->hw_base);
    if (len == 0) {
        return NULL;
    }
    
    buffer = hw_get_rx_buffer(driver->hw_base);
    
    // Allocate pbuf
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
    if (p != NULL) {
        // Copy data to pbuf
        uint16_t offset = 0;
        for (q = p; q != NULL; q = q->next) {
            memcpy(q->payload, &buffer[offset], q->len);
            offset += q->len;
        }
    }
    
    // Release RX buffer
    hw_release_rx_buffer(driver->hw_base);
    
    return p;
}
```

---

## Conclusion / 结论

Embedded system networks form the backbone of modern IoT and cyber-physical systems. This comprehensive guide has covered the fundamental concepts, technologies, protocols, and best practices for designing, implementing, and optimizing embedded networks.

嵌入式系统网络构成了现代物联网和信息物理系统的基础。本综合指南涵盖了设计、实施和优化嵌入式网络的基本概念、技术、协议和最佳实践。

**Key Takeaways / 关键要点:**

1. **Network Technologies** - Understanding the tradeoffs between wired (Ethernet, CAN, RS-485) and wireless (WiFi, BLE, Zigbee, LoRa, NB-IoT) technologies is crucial for selecting the right solution.

2. **Protocol Stacks** - Lightweight TCP/IP implementations (lwIP, uIP) and IoT protocols (MQTT, CoAP) enable efficient networking on resource-constrained devices.

3. **Performance Optimization** - Power management, bandwidth optimization, and latency reduction are essential for battery-powered and real-time applications.

4. **Security** - Implementing encryption, authentication, and secure boot/OTA mechanisms is non-negotiable in production systems.

5. **IoT Architecture** - Cloud-edge-device architectures with edge computing capabilities provide scalability and low-latency processing.

6. **Future Trends** - 5G, TSN, SDN, and AI-driven optimization will shape the next generation of embedded networks.

**网络技术** - 理解有线（以太网、CAN、RS-485）和无线（WiFi、蓝牙、Zigbee、LoRa、NB-IoT）技术之间的权衡对于选择正确的解决方案至关重要。

**协议栈** - 轻量级TCP/IP实现（lwIP、uIP）和物联网协议（MQTT、CoAP）使资源受限设备上的高效网络成为可能。

**性能优化** - 电源管理、带宽优化和延迟降低对于电池供电和实时应用至关重要。

**安全性** - 在生产系统中实施加密、认证和安全启动/OTA机制是不可或缺的。

**物联网架构** - 具有边缘计算能力的云-边-端架构提供可扩展性和低延迟处理。

**未来趋势** - 5G、TSN、SDN和AI驱动的优化将塑造下一代嵌入式网络。

---

## References / 参考资料

**Standards and Specifications / 标准和规范:**

1. IEEE 802.3 - Ethernet Standard
2. IEEE 802.11 - WiFi Standards  
3. IEEE 802.15.4 - Low-Rate Wireless Personal Area Networks
4. ISO 11898 - CAN Protocol
5. RFC 7252 - The Constrained Application Protocol (CoAP)
6. MQTT Version 3.1.1 / 5.0 Specification
7. 3GPP - NB-IoT and LTE-M Specifications
8. LoRaWAN 1.0.3 Specification
9. IEEE 802.1 TSN Standards
10. TLS 1.3 (RFC 8446) / DTLS 1.2 (RFC 6347)

**Books and Resources / 书籍和资源:**

1. "TCP/IP Illustrated, Volume 1" - W. Richard Stevens
2. "Embedded Systems: Real-Time Operating Systems for ARM Cortex-M" - Jonathan Valvano
3. "Building Wireless Sensor Networks" - Robert Faludi  
4. "IoT and Edge Computing for Architects" - Perry Lea
5. "Designing Embedded Systems with 32-Bit PIC Microcontrollers and MikroC" - Dogan Ibrahim

**Open Source Projects / 开源项目:**

1. lwIP - Lightweight IP Stack: https://savannah.nongnu.org/projects/lwip/
2. mbedTLS - Embedded TLS Library: https://github.com/ARMmbed/mbedtls  
3. Eclipse Paho - MQTT Client: https://www.eclipse.org/paho/
4. libcoap - CoAP Library: https://github.com/obgm/libcoap
5. Contiki-NG - IoT Operating System: https://github.com/contiki-ng/contiki-ng
6. FreeRTOS - Real-Time OS: https://www.freertos.org/
7. Zephyr RTOS: https://www.zephyrproject.org/

**Online Documentation / 在线文档:**

1. ESP-IDF Programming Guide: https://docs.espressif.com/
2. Nordic nRF Connect SDK: https://developer.nordicsemi.com/  
3. STM32 HAL and LL Drivers: https://www.st.com/
4. AWS IoT Core Documentation: https://docs.aws.amazon.com/iot/
5. Azure IoT Hub Documentation: https://docs.microsoft.com/azure/iot-hub/
6. Google Cloud IoT Core: https://cloud.google.com/iot-core

**Tools and Utilities / 工具和实用程序:**

1. Wireshark - Network Protocol Analyzer
2. nmap - Network Discovery and Security Auditing  
3. iperf3 - Network Performance Measurement
4. tcpdump - Packet Analyzer
5. MQTT.fx / MQTT Explorer - MQTT Client Tools
6. Postman - API Testing (for HTTP/CoAP)
7. can-utils - Linux CAN Bus Utilities

---

**Document Information / 文档信息:**

- **Title / 标题:** Embedded System Networks Technical Guide
- **Version / 版本:** 1.0  
- **Date / 日期:** December 2025
- **Language / 语言:** English / 中文 (Bilingual)
- **Target Audience / 目标读者:** Embedded Systems Engineers, IoT Developers, System Architects
- **License / 许可:** Educational and Reference Use

**Revision History / 修订历史:**

| Version | Date     | Changes         | Author         |
| ------- | -------- | --------------- | -------------- |
| 1.0     | Dec 2025 | Initial release | Technical Team |

---

*This document provides a comprehensive overview of embedded system networking technologies and practices. For specific implementation details, please refer to the manufacturer's documentation and relevant standards.*

*本文档提供了嵌入式系统网络技术和实践的全面概述。有关具体实现细节，请参阅制造商文档和相关标准。*