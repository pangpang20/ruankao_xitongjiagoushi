# Database Normalization - Comprehensive Technical Documentation

# 数据库规范化 - 完整技术文档

---

## Table of Contents | 目录

1. [Introduction | 概述](#introduction--概述)
2. [Fundamental Concepts | 基础概念](#fundamental-concepts--基础概念)
3. [Functional Dependencies | 函数依赖](#functional-dependencies--函数依赖)
4. [Normal Forms | 范式](#normal-forms--范式)
5. [Normalization Process | 规范化过程](#normalization-process--规范化过程)
6. [Data Anomalies | 数据异常](#data-anomalies--数据异常)
7. [Denormalization | 反规范化](#denormalization--反规范化)
8. [Practical Applications | 实际应用](#practical-applications--实际应用)
9. [Exam Focus Points | 考试要点](#exam-focus-points--考试要点)
10. [References | 参考资料](#references--参考资料)

---

## Introduction | 概述

### What is Database Normalization? | 什么是数据库规范化?

**English:**

**Database Normalization** is a systematic approach to organizing data in a relational database to reduce data redundancy and improve data integrity. It involves decomposing tables into smaller, well-structured tables and defining relationships between them according to rules designed to protect the data and make the database more flexible.

**Goals of Normalization**:
1. **Eliminate Data Redundancy**: Reduce duplicate data storage
2. **Ensure Data Integrity**: Maintain consistency and accuracy
3. **Prevent Update Anomalies**: Avoid insertion, deletion, and update anomalies
4. **Optimize Query Performance**: Improve data retrieval efficiency
5. **Facilitate Maintenance**: Make database easier to modify and extend

**Benefits**:
- Reduced storage requirements
- Improved data consistency
- Easier database maintenance
- Better data organization
- Enhanced query performance (in most cases)

**Potential Drawbacks**:
- May require more complex queries (joins)
- Can impact read performance if over-normalized
- More tables to manage
- Requires careful design consideration

**中文:**

**数据库规范化**是一种系统化的方法，用于在关系数据库中组织数据，以减少数据冗余并提高数据完整性。它涉及将表分解为更小、结构良好的表，并根据旨在保护数据并使数据库更灵活的规则定义它们之间的关系。

**规范化的目标**:
1. **消除数据冗余**: 减少重复数据存储
2. **确保数据完整性**: 保持一致性和准确性
3. **防止更新异常**: 避免插入、删除和更新异常
4. **优化查询性能**: 提高数据检索效率
5. **便于维护**: 使数据库更易于修改和扩展

**优势**: 减少存储需求、提高数据一致性、易于维护、更好的数据组织、增强查询性能

**潜在缺点**: 可能需要更复杂的查询(连接)、过度规范化可能影响读性能、需要管理更多表

### Brief History | 简史

**English:**

Database normalization theory was first proposed by **Edgar F. Codd** in 1970 as part of his relational model. The theory has evolved through several stages:

- **1970**: First Normal Form (1NF) introduced by Codd
- **1971**: Second (2NF) and Third Normal Forms (3NF) defined
- **1974**: Boyce-Codd Normal Form (BCNF) introduced
- **1977**: Fourth Normal Form (4NF) defined by Fagin
- **1979**: Fifth Normal Form (5NF/PJNF) introduced

**中文:**

数据库规范化理论最早由**Edgar F. Codd**于1970年作为其关系模型的一部分提出。该理论经历了几个发展阶段：

- **1970年**: Codd提出第一范式(1NF)
- **1971年**: 定义第二范式(2NF)和第三范式(3NF)
- **1974年**: 引入Boyce-Codd范式(BCNF)
- **1977年**: Fagin定义第四范式(4NF)
- **1979年**: 引入第五范式(5NF/PJNF)

---

## Fundamental Concepts | 基础概念

### Relational Model Basics | 关系模型基础

**English:**

#### 1. Relation (Table) | 关系(表)

A **relation** is a two-dimensional table consisting of rows and columns.

**Components**:
- **Attributes (Columns)**: Properties or characteristics of the entity
- **Tuples (Rows)**: Individual records or instances
- **Domain**: Set of allowable values for an attribute
- **Cardinality**: Number of tuples in a relation
- **Degree**: Number of attributes in a relation

**Example**:

```
Student Table (Relation)
┌──────────┬─────────────┬──────┬────────────┬───────────┐
│ StudentID│ StudentName │ Age  │ Department │   Email   │
├──────────┼─────────────┼──────┼────────────┼───────────┤
│   S001   │ John Smith  │  20  │    CS      │john@...   │
│   S002   │ Jane Doe    │  21  │    EE      │jane@...   │
│   S003   │ Bob Johnson │  19  │    CS      │bob@...    │
└──────────┴─────────────┴──────┴────────────┴───────────┘

Degree: 5 (5 attributes)
Cardinality: 3 (3 tuples)
```

**中文:**

**关系**是由行和列组成的二维表。

**组成部分**: 属性(列)、元组(行)、域(属性的允许值集合)、基数(元组数量)、度(属性数量)

#### 2. Keys | 键

**English:**

**Superkey (超键)**:
- A set of one or more attributes that uniquely identifies a tuple
- Example: {StudentID}, {StudentID, StudentName}, {Email}

**Candidate Key (候选键)**:
- A minimal superkey (no proper subset is a superkey)
- Example: {StudentID}, {Email}

**Primary Key (主键)**:
- The candidate key chosen to uniquely identify tuples
- Must be unique and not null
- Example: StudentID

**Alternate Key (替换键)**:
- Candidate keys not chosen as primary key
- Example: Email (if StudentID is primary key)

**Foreign Key (外键)**:
- An attribute in one relation that references the primary key of another relation
- Establishes relationships between tables
- Enforces referential integrity

**Composite Key (复合键)**:
- A key consisting of two or more attributes
- Example: {StudentID, CourseID} in enrollment table

**Key Hierarchy**:

```
┌─────────────────────────────────────┐
│          Superkey                   │
│  (Any attribute set that uniquely   │
│   identifies tuples)                │
│                                     │
│  ┌──────────────────────────────┐   │
│  │    Candidate Key             │   │
│  │  (Minimal superkey)          │   │
│  │                              │   │
│  │  ┌────────────────────────┐  │   │
│  │  │   Primary Key          │  │   │
│  │  │  (Chosen candidate key)│  │   │
│  │  └────────────────────────┘  │   │
│  │                              │   │
│  │  ┌────────────────────────┐  │   │
│  │  │   Alternate Keys       │  │   │
│  │  │  (Other candidate keys)│  │   │
│  │  └────────────────────────┘  │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
```

**中文:**

**超键**: 能唯一标识元组的一个或多个属性的集合
**候选键**: 最小超键(没有真子集是超键)
**主键**: 选定用于唯一标识元组的候选键
**替换键**: 未被选为主键的候选键
**外键**: 一个关系中引用另一个关系主键的属性
**复合键**: 由两个或多个属性组成的键

---

## Functional Dependencies | 函数依赖

### Definition and Types | 定义与类型

**English:**

#### 1. Functional Dependency (FD) | 函数依赖

**Definition**: Given a relation R, attribute B is functionally dependent on attribute A (denoted as A → B) if each value of A is associated with exactly one value of B.

**Notation**: A → B (read as "A determines B" or "B is functionally dependent on A")

**Example**:
```
Employee (EmpID, EmpName, Department, Salary)

EmpID → EmpName  (Each employee ID determines one name)
EmpID → Department (Each employee ID determines one department)
EmpID → Salary (Each employee ID determines one salary)

Therefore: EmpID → {EmpName, Department, Salary}
```

**Properties**:
- **Reflexivity**: If Y ⊆ X, then X → Y
- **Augmentation**: If X → Y, then XZ → YZ
- **Transitivity**: If X → Y and Y → Z, then X → Z
- **Decomposition**: If X → YZ, then X → Y and X → Z
- **Union**: If X → Y and X → Z, then X → YZ
- **Pseudotransitivity**: If X → Y and WY → Z, then WX → Z

These are known as **Armstrong's Axioms**.

**中文:**

**函数依赖定义**: 给定关系R，如果属性A的每个值都与属性B的恰好一个值相关联，则属性B函数依赖于属性A(记为A → B)。

**表示法**: A → B (读作"A决定B"或"B函数依赖于A")

**Armstrong公理**: 自反性、增广性、传递性、分解、合并、伪传递性

#### 2. Full Functional Dependency | 完全函数依赖

**English:**

**Definition**: In a relation R, if Y is functionally dependent on X, but not functionally dependent on any proper subset of X, then Y is **fully functionally dependent** on X.

**Notation**: X ⟹ Y (or X ⇒ Y)

**Example**:
```
Enrollment (StudentID, CourseID, Grade, InstructorName)

{StudentID, CourseID} → Grade (Full FD)
{StudentID, CourseID} → InstructorName (Full FD)

But:
CourseID → InstructorName (Partial FD, because InstructorName 
                           depends only on CourseID, not the 
                           full composite key)
```

**Visualization**:

```
Full Functional Dependency:
┌─────────────────────────────┐
│ {StudentID, CourseID}       │
│         (Complete)          │
└─────────────┬───────────────┘
              │ Full FD
              ↓
         ┌─────────┐
         │  Grade  │
         └─────────┘

Partial Functional Dependency:
┌─────────────────────────────┐
│ {StudentID, CourseID}       │
│         (Complete)          │
└───────────┬─────────────────┘
            │ Part of key
     ┌──────┴──────┐
     │  CourseID   │
     └──────┬──────┘
            │ Partial FD
            ↓
    ┌───────────────┐
    │InstructorName │
    └───────────────┘
```

**中文:**

**完全函数依赖定义**: 在关系R中，如果Y函数依赖于X，但不函数依赖于X的任何真子集，则Y**完全函数依赖**于X。

**完全函数依赖**: X的所有属性都必需才能决定Y
**部分函数依赖**: X的某个真子集就能决定Y

#### 3. Partial Functional Dependency | 部分函数依赖

**English:**

**Definition**: In a relation R, if Y is functionally dependent on X, and there exists a proper subset Z of X such that Z → Y, then Y is **partially functionally dependent** on X.

**Problem**: Partial dependencies lead to data redundancy and update anomalies.

**Example**:
```
CourseEnrollment (StudentID, CourseID, StudentName, CourseName, Grade)

Functional Dependencies:
- {StudentID, CourseID} → Grade (Full FD)
- StudentID → StudentName (Partial FD - part of composite key)
- CourseID → CourseName (Partial FD - part of composite key)

Problem:
- StudentName is repeated for each course a student takes
- CourseName is repeated for each student in the course
```

**中文:**

**部分函数依赖定义**: 在关系R中，如果Y函数依赖于X，且存在X的真子集Z使得Z → Y，则Y**部分函数依赖**于X。

**问题**: 部分依赖导致数据冗余和更新异常。

#### 4. Transitive Functional Dependency | 传递函数依赖

**English:**

**Definition**: In a relation R, if X → Y and Y → Z (and Y ↛ X), then Z is **transitively dependent** on X through Y.

**Notation**: X → Y → Z implies X → Z (transitively)

**Example**:
```
Employee (EmpID, EmpName, DeptID, DeptName, DeptLocation)

Functional Dependencies:
- EmpID → DeptID (Direct)
- DeptID → DeptName (Direct)
- DeptID → DeptLocation (Direct)
- EmpID → DeptName (Transitive through DeptID)
- EmpID → DeptLocation (Transitive through DeptID)

Problem:
- Department information is repeated for each employee
- Updating department name requires updating all employee records
```

**Visualization**:

```
Transitive Dependency Chain:

┌────────┐       Direct       ┌────────┐       Direct       ┌──────────┐
│ EmpID  │ ──────────────────→│ DeptID │ ──────────────────→│ DeptName │
└────────┘                    └────────┘                    └──────────┘
    │                                                              ▲
    │                                                              │
    └──────────────────────── Transitive ────────────────────────┘
```

**中文:**

**传递函数依赖定义**: 在关系R中，如果X → Y且Y → Z(且Y ↛ X)，则Z通过Y**传递依赖**于X。

**问题**: 传递依赖导致数据冗余和更新异常。

### Armstrong's Axioms | Armstrong公理

**English:**

Armstrong's Axioms are a set of inference rules used to derive all functional dependencies in a relation.

**Primary Rules**:

| Rule   | Name                    | Formula                        | Description                                                        |
| ------ | ----------------------- | ------------------------------ | ------------------------------------------------------------------ |
| **A1** | Reflexivity<br/>自反律  | If Y ⊆ X, then X → Y           | A set of attributes determines any subset<br/>属性集决定其任意子集 |
| **A2** | Augmentation<br/>增广律 | If X → Y, then XZ → YZ         | Adding attributes preserves FD<br/>添加属性保持函数依赖            |
| **A3** | Transitivity<br/>传递律 | If X → Y and Y → Z, then X → Z | Functional dependencies are transitive<br/>函数依赖具有传递性      |

**Derived Rules**:

| Rule   | Name                            | Formula                          | Description                          |
| ------ | ------------------------------- | -------------------------------- | ------------------------------------ |
| **D1** | Union<br/>合并律                | If X → Y and X → Z, then X → YZ  | Combine dependencies<br/>合并依赖    |
| **D2** | Decomposition<br/>分解律        | If X → YZ, then X → Y and X → Z  | Split dependencies<br/>分解依赖      |
| **D3** | Pseudotransitivity<br/>伪传递律 | If X → Y and WY → Z, then WX → Z | Extended transitivity<br/>扩展传递性 |

**Example - Deriving FDs**:

```
Given:
- A → B
- B → C
- CD → E

Derive:
1. A → C (by transitivity: A → B, B → C)
2. A → BC (by union: A → B, A → C)
3. ACD → E (by augmentation: CD → E, add A to both sides)
4. A → E (by pseudotransitivity: A → C, CD → E)
```

**中文:**

**Armstrong公理**是用于推导关系中所有函数依赖的推理规则集。

**基本规则**: 自反律、增广律、传递律
**派生规则**: 合并律、分解律、伪传递律

### Closure of Attributes | 属性闭包

**English:**

**Definition**: The closure of a set of attributes X (denoted as X⁺) is the set of all attributes that are functionally determined by X.

**Purpose**:
- Determine if X is a superkey (if X⁺ contains all attributes)
- Find candidate keys
- Test if a functional dependency holds

**Algorithm**:

```
Input: Attribute set X, FD set F
Output: X⁺ (closure of X)

1. Initialize: X⁺ = X
2. Repeat until X⁺ doesn't change:
   For each FD (Y → Z) in F:
     If Y ⊆ X⁺, then X⁺ = X⁺ ∪ Z
3. Return X⁺
```

**Example**:

```
Given Relation: R(A, B, C, D, E)
FD Set F: {A → BC, CD → E, B → D, E → A}

Find A⁺:
Step 1: A⁺ = {A}
Step 2: A → BC, so A⁺ = {A, B, C}
Step 3: B → D (B ⊆ A⁺), so A⁺ = {A, B, C, D}
Step 4: CD → E (CD ⊆ A⁺), so A⁺ = {A, B, C, D, E}
Step 5: No more changes

Result: A⁺ = {A, B, C, D, E} = All attributes
Conclusion: A is a superkey (and candidate key)
```

**中文:**

**属性闭包定义**: 属性集X的闭包(记为X⁺)是由X函数决定的所有属性的集合。

**用途**: 确定X是否为超键、查找候选键、测试函数依赖是否成立

---

## Normal Forms | 范式

### First Normal Form (1NF) | 第一范式

**English:**

**Definition**: A relation is in **First Normal Form (1NF)** if:
- All attributes contain only atomic (indivisible) values
- There are no repeating groups or arrays
- Each attribute contains a single value from its domain

**Requirements**:
1. **Atomicity**: No multi-valued attributes
2. **No repeating groups**: No duplicate attribute sets
3. **Single value per cell**: Each cell contains one value only

**Example - Violation of 1NF**:

```sql
-- NOT in 1NF (Multiple values in one column)
CREATE TABLE Employee_Bad (
    EmployeeID INT PRIMARY KEY,
    EmployeeName VARCHAR(100),
    PhoneNumbers VARCHAR(200),  -- "555-1234, 555-5678, 555-9012"
    Skills VARCHAR(200)          -- "Java, Python, SQL"
);

-- Example data showing 1NF violation
┌────────────┬──────────────┬─────────────────────────┬──────────────────┐
│ EmployeeID │ EmployeeName │    PhoneNumbers         │     Skills       │
├────────────┼──────────────┼─────────────────────────┼──────────────────┤
│    101     │  John Smith  │555-1234, 555-5678       │Java, Python, SQL │
│    102     │  Jane Doe    │555-9012                 │C++, JavaScript   │
└────────────┴──────────────┴─────────────────────────┴──────────────────┘

Problems:
- Cannot easily search for a specific phone number
- Cannot query employees with a specific skill
- Difficult to add/remove individual phone numbers or skills
```

**Example - Converted to 1NF**:

**Approach 1: Separate Tables (Recommended)**

```sql
-- In 1NF - Employee Table
CREATE TABLE Employee (
    EmployeeID INT PRIMARY KEY,
    EmployeeName VARCHAR(100)
);

-- In 1NF - Phone Numbers Table
CREATE TABLE EmployeePhone (
    EmployeeID INT,
    PhoneNumber VARCHAR(20),
    PhoneType VARCHAR(20),  -- 'Mobile', 'Home', 'Work'
    PRIMARY KEY (EmployeeID, PhoneNumber),
    FOREIGN KEY (EmployeeID) REFERENCES Employee(EmployeeID)
);

-- In 1NF - Skills Table
CREATE TABLE EmployeeSkill (
    EmployeeID INT,
    SkillName VARCHAR(50),
    ProficiencyLevel VARCHAR(20),  -- 'Beginner', 'Intermediate', 'Expert'
    PRIMARY KEY (EmployeeID, SkillName),
    FOREIGN KEY (EmployeeID) REFERENCES Employee(EmployeeID)
);

-- Data in 1NF
Employee:
┌────────────┬──────────────┐
│ EmployeeID │ EmployeeName │
├────────────┼──────────────┤
│    101     │  John Smith  │
│    102     │  Jane Doe    │
└────────────┴──────────────┘

EmployeePhone:
┌────────────┬──────────────┬───────────┐
│ EmployeeID │ PhoneNumber  │ PhoneType │
├────────────┼──────────────┼───────────┤
│    101     │  555-1234    │  Mobile   │
│    101     │  555-5678    │  Home     │
│    102     │  555-9012    │  Mobile   │
└────────────┴──────────────┴───────────┘

EmployeeSkill:
┌────────────┬────────────┬──────────────────┐
│ EmployeeID │ SkillName  │ ProficiencyLevel │
├────────────┼────────────┼──────────────────┤
│    101     │   Java     │    Expert        │
│    101     │   Python   │  Intermediate    │
│    101     │    SQL     │    Expert        │
│    102     │    C++     │    Expert        │
│    102     │JavaScript  │  Intermediate    │
└────────────┴────────────┴──────────────────┘
```

**Approach 2: Multiple Columns (Less flexible)**

```sql
-- Alternative 1NF (Not recommended - inflexible)
CREATE TABLE Employee_Alt (
    EmployeeID INT PRIMARY KEY,
    EmployeeName VARCHAR(100),
    Phone1 VARCHAR(20),
    Phone2 VARCHAR(20),
    Phone3 VARCHAR(20),
    Skill1 VARCHAR(50),
    Skill2 VARCHAR(50),
    Skill3 VARCHAR(50)
);

Problems with this approach:
- Fixed number of phones/skills
- Many NULL values if employee has fewer items
- Difficult to query
```

**中文:**

**第一范式定义**: 如果关系满足以下条件，则处于**第一范式(1NF)**:
- 所有属性只包含原子(不可分割)值
- 没有重复组或数组
- 每个属性包含其域中的单个值

**要求**: 原子性(无多值属性)、无重复组、每个单元格单值

**1NF转换**: 将多值属性分离到独立表中，建立一对多关系

### Second Normal Form (2NF) | 第二范式

**English:**

**Definition**: A relation is in **Second Normal Form (2NF)** if:
1. It is in 1NF
2. No non-prime attribute is partially dependent on any candidate key
   (All non-key attributes must be fully functionally dependent on the entire primary key)

**Key Point**: 2NF eliminates partial dependencies. Only relevant for tables with composite keys.

**Example - Violation of 2NF**:

```sql
-- NOT in 2NF
CREATE TABLE CourseEnrollment_Bad (
    StudentID INT,
    CourseID INT,
    StudentName VARCHAR(100),    -- Depends only on StudentID
    StudentMajor VARCHAR(50),    -- Depends only on StudentID
    CourseName VARCHAR(100),     -- Depends only on CourseID
    InstructorName VARCHAR(100), -- Depends only on CourseID
    Grade CHAR(2),               -- Depends on both StudentID and CourseID
    EnrollmentDate DATE,         -- Depends on both StudentID and CourseID
    PRIMARY KEY (StudentID, CourseID)
);

-- Sample Data
┌───────────┬──────────┬─────────────┬──────────────┬─────────────┬────────────────┬───────┬────────────────┐
│ StudentID │ CourseID │ StudentName │ StudentMajor │ CourseName  │ InstructorName │ Grade │ EnrollmentDate │
├───────────┼──────────┼─────────────┼──────────────┼─────────────┼────────────────┼───────┼────────────────┤
│   S001    │   C101   │ John Smith  │     CS       │ Database    │   Dr. Brown    │   A   │  2024-01-15    │
│   S001    │   C102   │ John Smith  │     CS       │ Algorithms  │   Dr. Wilson   │   B+  │  2024-01-15    │
│   S002    │   C101   │  Jane Doe   │     EE       │ Database    │   Dr. Brown    │   A-  │  2024-01-16    │
│   S003    │   C101   │ Bob Johnson │     CS       │ Database    │   Dr. Brown    │   B   │  2024-01-16    │
└───────────┴──────────┴─────────────┴──────────────┴─────────────┴────────────────┴───────┴────────────────┘

Functional Dependencies:
- {StudentID, CourseID} → Grade (Full FD) ✓
- {StudentID, CourseID} → EnrollmentDate (Full FD) ✓
- StudentID → StudentName (Partial FD) ✗
- StudentID → StudentMajor (Partial FD) ✗
- CourseID → CourseName (Partial FD) ✗
- CourseID → InstructorName (Partial FD) ✗

Problems (Data Anomalies):
1. Insertion Anomaly: Cannot add a student without enrolling in a course
2. Deletion Anomaly: Deleting last enrollment deletes student information
3. Update Anomaly: Changing student major requires updating multiple rows
4. Redundancy: Student and course information repeated in every enrollment
```

**Example - Converted to 2NF**:

```sql
-- In 2NF - Decompose into 3 tables

-- Student Table (StudentID → StudentName, StudentMajor)
CREATE TABLE Student (
    StudentID INT PRIMARY KEY,
    StudentName VARCHAR(100),
    StudentMajor VARCHAR(50)
);

-- Course Table (CourseID → CourseName, InstructorName)
CREATE TABLE Course (
    CourseID INT PRIMARY KEY,
    CourseName VARCHAR(100),
    InstructorName VARCHAR(100)
);

-- Enrollment Table ({StudentID, CourseID} → Grade, EnrollmentDate)
CREATE TABLE Enrollment (
    StudentID INT,
    CourseID INT,
    Grade CHAR(2),
    EnrollmentDate DATE,
    PRIMARY KEY (StudentID, CourseID),
    FOREIGN KEY (StudentID) REFERENCES Student(StudentID),
    FOREIGN KEY (CourseID) REFERENCES Course(CourseID)
);

-- Data in 2NF
Student:
┌───────────┬─────────────┬──────────────┐
│ StudentID │ StudentName │ StudentMajor │
├───────────┼─────────────┼──────────────┤
│   S001    │ John Smith  │     CS       │
│   S002    │  Jane Doe   │     EE       │
│   S003    │ Bob Johnson │     CS       │
└───────────┴─────────────┴──────────────┘

Course:
┌──────────┬─────────────┬────────────────┐
│ CourseID │ CourseName  │ InstructorName │
├──────────┼─────────────┼────────────────┤
│   C101   │  Database   │   Dr. Brown    │
│   C102   │ Algorithms  │   Dr. Wilson   │
└──────────┴─────────────┴────────────────┘

Enrollment:
┌───────────┬──────────┬───────┬────────────────┐
│ StudentID │ CourseID │ Grade │ EnrollmentDate │
├───────────┼──────────┼───────┼────────────────┤
│   S001    │   C101   │   A   │  2024-01-15    │
│   S001    │   C102   │   B+  │  2024-01-15    │
│   S002    │   C101   │   A-  │  2024-01-16    │
│   S003    │   C101   │   B   │  2024-01-16    │
└───────────┴──────────┴───────┴────────────────┘

Benefits:
✓ No insertion anomaly: Can add students independently
✓ No deletion anomaly: Deleting enrollment preserves student/course data
✓ No update anomaly: Changing student major updates one row
✓ Reduced redundancy: Each fact stored once
```

**Visualization - 2NF Decomposition**:

```
Before 2NF (Partial Dependencies):
┌────────────────────────────────┐
│     CourseEnrollment_Bad       │
│ PK: {StudentID, CourseID}      │
├────────────────────────────────┤
│ StudentID (PK)                 │◄──┐
│ CourseID (PK)                  │   │ Partial
│ StudentName    ────────────────┼───┘ Dependencies
│ StudentMajor   ────────────────┼───┐
│ CourseName     ────────────────┼───┘
│ InstructorName ────────────────┼───┐
│ Grade                          │   │ Full
│ EnrollmentDate                 │◄──┘ Dependencies
└────────────────────────────────┘

After 2NF (Eliminate Partial Dependencies):
┌────────────────┐     ┌────────────────┐     ┌────────────────┐
│    Student     │     │  Enrollment    │     │     Course     │
│ PK: StudentID  │     │ PK: {Stud,Crs} │     │ PK: CourseID   │
├────────────────┤     ├────────────────┤     ├────────────────┤
│ StudentID (PK) │◄───┐│ StudentID (FK) │┌───►│ CourseID (PK)  │
│ StudentName    │    ││ CourseID (FK)  ││    │ CourseName     │
│ StudentMajor   │    │└────────────────┘│    │ InstructorName │
└────────────────┘    │ Grade            │    └────────────────┘
                      │ EnrollmentDate   │
                      └──────────────────┘
```

**中文:**

**第二范式定义**: 如果关系满足以下条件，则处于**第二范式(2NF)**:
1. 已经是1NF
2. 非主属性不部分依赖于任何候选键(所有非键属性必须完全函数依赖于整个主键)

**要点**: 2NF消除部分依赖。仅与具有复合键的表相关。

**2NF转换**: 将部分依赖的属性分离到独立表中，消除冗余

### Third Normal Form (3NF) | 第三范式

**English:**

**Definition**: A relation is in **Third Normal Form (3NF)** if:
1. It is in 2NF
2. No non-prime attribute is transitively dependent on any candidate key
   (No non-key attribute depends on another non-key attribute)

**Key Point**: 3NF eliminates transitive dependencies.

**Example - Violation of 3NF (but in 2NF)**:

```sql
-- In 2NF but NOT in 3NF
CREATE TABLE Employee_2NF (
    EmployeeID INT PRIMARY KEY,
    EmployeeName VARCHAR(100),
    DepartmentID INT,
    DepartmentName VARCHAR(100),   -- Transitively dependent
    DepartmentLocation VARCHAR(100), -- Transitively dependent
    Salary DECIMAL(10, 2)
);

-- Sample Data
┌────────────┬──────────────┬──────────────┬────────────────┬────────────────────┬──────────┐
│ EmployeeID │ EmployeeName │ DepartmentID │ DepartmentName │ DepartmentLocation │  Salary  │
├────────────┼──────────────┼──────────────┼────────────────┼────────────────────┼──────────┤
│    E001    │  John Smith  │     D01      │      Sales     │    New York        │  75000   │
│    E002    │  Jane Doe    │     D01      │      Sales     │    New York        │  80000   │
│    E003    │ Bob Johnson  │     D02      │        IT      │  San Francisco     │  90000   │
│    E004    │ Alice Brown  │     D02      │        IT      │  San Francisco     │  95000   │
│    E005    │ Charlie Lee  │     D03      │       HR       │    Chicago         │  70000   │
└────────────┴──────────────┴──────────────┴────────────────┴────────────────────┴──────────┘

Functional Dependencies:
- EmployeeID → EmployeeName (Direct) ✓
- EmployeeID → DepartmentID (Direct) ✓
- EmployeeID → Salary (Direct) ✓
- DepartmentID → DepartmentName (Direct) ✓
- DepartmentID → DepartmentLocation (Direct) ✓
- EmployeeID → DepartmentName (Transitive through DepartmentID) ✗
- EmployeeID → DepartmentLocation (Transitive through DepartmentID) ✗

Transitive Dependency Chain:
EmployeeID → DepartmentID → DepartmentName
EmployeeID → DepartmentID → DepartmentLocation

Problems:
1. Insertion Anomaly: Cannot add a department without an employee
2. Deletion Anomaly: Deleting last employee in department deletes department info
3. Update Anomaly: Changing department name/location requires updating multiple rows
4. Redundancy: Department information repeated for each employee
```

**Example - Converted to 3NF**:

```sql
-- In 3NF - Decompose into 2 tables

-- Employee Table
CREATE TABLE Employee (
    EmployeeID INT PRIMARY KEY,
    EmployeeName VARCHAR(100),
    DepartmentID INT,
    Salary DECIMAL(10, 2),
    FOREIGN KEY (DepartmentID) REFERENCES Department(DepartmentID)
);

-- Department Table
CREATE TABLE Department (
    DepartmentID INT PRIMARY KEY,
    DepartmentName VARCHAR(100),
    DepartmentLocation VARCHAR(100)
);

-- Data in 3NF
Employee:
┌────────────┬──────────────┬──────────────┬──────────┐
│ EmployeeID │ EmployeeName │ DepartmentID │  Salary  │
├────────────┼──────────────┼──────────────┼──────────┤
│    E001    │  John Smith  │     D01      │  75000   │
│    E002    │  Jane Doe    │     D01      │  80000   │
│    E003    │ Bob Johnson  │     D02      │  90000   │
│    E004    │ Alice Brown  │     D02      │  95000   │
│    E005    │ Charlie Lee  │     D03      │  70000   │
└────────────┴──────────────┴──────────────┴──────────┘

Department:
┌──────────────┬────────────────┬────────────────────┐
│ DepartmentID │ DepartmentName │ DepartmentLocation │
├──────────────┼────────────────┼────────────────────┤
│     D01      │      Sales     │    New York        │
│     D02      │        IT      │  San Francisco     │
│     D03      │       HR       │    Chicago         │
└──────────────┴────────────────┴────────────────────┘

Benefits:
✓ No insertion anomaly: Can add departments independently
✓ No deletion anomaly: Deleting employee preserves department data
✓ No update anomaly: Changing department info updates one row
✓ Reduced redundancy: Each fact stored once
✓ Better data integrity: Department data managed centrally
```

**Visualization - 3NF Decomposition**:

```
Before 3NF (Transitive Dependencies):
┌─────────────────────────────┐
│      Employee_2NF           │
│ PK: EmployeeID              │
├─────────────────────────────┤
│ EmployeeID (PK)             │
│ EmployeeName                │
│ DepartmentID  ──┐           │
│                 │           │
│ DepartmentName  │◄──────────┤ Transitive
│ DeptLocation    │           │ Dependency
│                 │           │
│ Salary          │           │
└─────────────────┴───────────┘

After 3NF (Eliminate Transitive Dependencies):
┌─────────────────┐           ┌─────────────────────┐
│    Employee     │           │    Department       │
│ PK: EmployeeID  │           │ PK: DepartmentID    │
├─────────────────┤           ├─────────────────────┤
│ EmployeeID (PK) │           │ DepartmentID (PK)   │
│ EmployeeName    │           │ DepartmentName      │
│ DepartmentID(FK)│──────────►│ DepartmentLocation  │
│ Salary          │           └─────────────────────┘
└─────────────────┘
```

**中文:**

**第三范式定义**: 如果关系满足以下条件，则处于**第三范式(3NF)**:
1. 已经是2NF
2. 非主属性不传递依赖于任何候选键(非键属性不依赖于另一个非键属性)

**要点**: 3NF消除传递依赖

**3NF转换**: 将传递依赖的属性分离到独立表中，消除冗余

### Boyce-Codd Normal Form (BCNF) | BC范式

**English:**

**Definition**: A relation is in **Boyce-Codd Normal Form (BCNF)** if:
- It is in 3NF
- For every non-trivial functional dependency X → Y, X is a superkey

**Alternative Definition**: A relation is in BCNF if every determinant is a candidate key.

**Key Point**: BCNF is a stronger version of 3NF that handles certain anomalies in relations where:
- There are multiple candidate keys
- Candidate keys are composite
- Candidate keys overlap (share attributes)

**Difference from 3NF**:
- 3NF allows non-prime attributes to determine other non-prime attributes if the determinant is part of a candidate key
- BCNF does not allow this

**Example - In 3NF but NOT in BCNF**:

```sql
-- Scenario: Course Schedule
-- Business Rules:
-- - Each course may be taught by multiple professors
-- - Each professor teaches only one course
-- - A course can have multiple time slots
-- - Each time slot is taught by one professor

CREATE TABLE CourseSchedule_3NF (
    CourseID VARCHAR(10),
    Professor VARCHAR(100),
    TimeSlot VARCHAR(20),
    PRIMARY KEY (CourseID, TimeSlot)
);

-- Sample Data
┌──────────┬─────────────┬───────────┐
│ CourseID │  Professor  │ TimeSlot  │
├──────────┼─────────────┼───────────┤
│  CS101   │  Dr. Smith  │  Mon 9AM  │
│  CS101   │  Dr. Jones  │  Wed 2PM  │
│  CS102   │  Dr. Brown  │  Tue 10AM │
│  CS102   │  Dr. Brown  │  Thu 3PM  │
│  CS103   │  Dr. Smith  │  Fri 1PM  │
└──────────┴─────────────┴───────────┘

Candidate Keys:
- {CourseID, TimeSlot} - Primary
- {Professor, TimeSlot} - Alternate

Functional Dependencies:
- {CourseID, TimeSlot} → Professor ✓
- {Professor, TimeSlot} → CourseID ✓
- Professor → CourseID (BCNF Violation!)
  (Professor is not a superkey, but it determines CourseID)

Why it's in 3NF:
- All non-key attributes fully depend on primary key ✓
- No transitive dependencies ✓

Why it's NOT in BCNF:
- Professor → CourseID, but Professor is not a superkey ✗

Problems:
1. Update Anomaly: If Dr. Brown changes from CS102 to CS104,
   multiple rows need updating
2. Cannot store professor-course assignment without time slot
```

**Example - Converted to BCNF**:

```sql
-- Decompose into 2 tables

-- Professor-Course Assignment
CREATE TABLE ProfessorCourse (
    Professor VARCHAR(100) PRIMARY KEY,
    CourseID VARCHAR(10)
);

-- Course Schedule
CREATE TABLE Schedule (
    CourseID VARCHAR(10),
    TimeSlot VARCHAR(20),
    PRIMARY KEY (CourseID, TimeSlot),
    FOREIGN KEY (CourseID) REFERENCES ProfessorCourse(CourseID)
);

-- Alternative: Use Professor as FK
CREATE TABLE Schedule_Alt (
    Professor VARCHAR(100),
    TimeSlot VARCHAR(20),
    PRIMARY KEY (Professor, TimeSlot),
    FOREIGN KEY (Professor) REFERENCES ProfessorCourse(Professor)
);

-- Data in BCNF
ProfessorCourse:
┌─────────────┬──────────┐
│  Professor  │ CourseID │
├─────────────┼──────────┤
│  Dr. Smith  │  CS101   │
│  Dr. Jones  │  CS101   │
│  Dr. Brown  │  CS102   │
└─────────────┴──────────┘

Schedule:
┌──────────┬───────────┐
│ CourseID │ TimeSlot  │
├──────────┼───────────┤
│  CS101   │  Mon 9AM  │
│  CS101   │  Wed 2PM  │
│  CS102   │  Tue 10AM │
│  CS102   │  Thu 3PM  │
│  CS103   │  Fri 1PM  │
└──────────┴───────────┘

-- Or using Schedule_Alt:
Schedule_Alt:
┌─────────────┬───────────┐
│  Professor  │ TimeSlot  │
├─────────────┼───────────┤
│  Dr. Smith  │  Mon 9AM  │
│  Dr. Jones  │  Wed 2PM  │
│  Dr. Brown  │  Tue 10AM │
│  Dr. Brown  │  Thu 3PM  │
│  Dr. Smith  │  Fri 1PM  │
└─────────────┴───────────┘

Benefits:
✓ All determinants are superkeys
✓ No update anomaly for professor-course assignment
✓ Can store professor-course without time slot
```

**BCNF vs 3NF Comparison**:

| Aspect                                       | 3NF                                                                                      | BCNF                                                                       |
| -------------------------------------------- | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| **Strength**<br/>**强度**                    | Weaker<br/>较弱                                                                          | Stronger<br/>较强                                                          |
| **Rule**<br/>**规则**                        | No transitive dependency of non-prime on non-prime<br/>非主属性不传递依赖于非主属性      | Every determinant is a superkey<br/>每个决定因素都是超键                   |
| **Lossless Decomposition**<br/>**无损分解**  | Always possible<br/>总是可能                                                             | May not be possible<br/>可能不可能                                         |
| **Dependency Preservation**<br/>**保持依赖** | Always preserved<br/>总是保持                                                            | May not be preserved<br/>可能不保持                                        |
| **Use Case**<br/>**使用场景**                | General purpose, when dependency preservation is critical<br/>通用，当保持依赖至关重要时 | When maximum redundancy elimination is needed<br/>当需要最大程度消除冗余时 |

**中文:**

**BCNF定义**: 如果关系满足以下条件，则处于**Boyce-Codd范式(BCNF)**:
- 已经是3NF
- 对于每个非平凡函数依赖X → Y，X是超键

**要点**: BCNF是比3NF更强的范式，处理具有多个候选键、复合候选键、候选键重叠的情况

**与3NF的区别**: BCNF要求每个决定因素都是超键

### Fourth Normal Form (4NF) | 第四范式

**English:**

**Definition**: A relation is in **Fourth Normal Form (4NF)** if:
- It is in BCNF
- It has no non-trivial multi-valued dependencies

**Multi-Valued Dependency (MVD)**: X ↠ Y (X multi-determines Y) means that for a given value of X, there is a set of associated values of Y that is independent of other attributes.

**Key Point**: 4NF deals with independent multi-valued facts that should be stored separately.

**Example - Violation of 4NF**:

```sql
-- Scenario: Employee Skills and Languages
-- Business Rules:
-- - An employee can have multiple skills
-- - An employee can speak multiple languages
-- - Skills and languages are independent of each other

CREATE TABLE EmployeeSkillLanguage_BCNF (
    EmployeeID INT,
    Skill VARCHAR(50),
    Language VARCHAR(50),
    PRIMARY KEY (EmployeeID, Skill, Language)
);

-- Sample Data
┌────────────┬────────────┬──────────┐
│ EmployeeID │   Skill    │ Language │
├────────────┼────────────┼──────────┤
│    E001    │   Java     │ English  │
│    E001    │   Java     │ Spanish  │
│    E001    │   Python   │ English  │
│    E001    │   Python   │ Spanish  │
│    E002    │    C++     │ French   │
│    E002    │    C++     │ German   │
│    E002    │   SQL      │ French   │
│    E002    │   SQL      │ German   │
└────────────┴────────────┴──────────┘

Multi-Valued Dependencies:
- EmployeeID ↠ Skill (For each employee, multiple skills)
- EmployeeID ↠ Language (For each employee, multiple languages)
- Skills and Languages are independent

Problems:
1. Redundancy: If employee E001 adds a new language (e.g., French),
   we need to add rows for ALL existing skills:
   (E001, Java, French), (E001, Python, French)
   
2. Update Anomaly: If we remove a skill or language, we might
   accidentally remove unrelated information
   
3. Insertion Anomaly: To add a skill or language, we must create
   combinations with all existing values of the other attribute

Example: E001 knows Java and Python, speaks English and Spanish
- We need 2 × 2 = 4 rows
- If E001 learns French, we need 2 more rows (one for each skill)
- If E001 learns C++, we need 3 more rows (one for each language)
```

**Example - Converted to 4NF**:

```sql
-- Decompose into 2 tables

-- Employee Skills
CREATE TABLE EmployeeSkill (
    EmployeeID INT,
    Skill VARCHAR(50),
    PRIMARY KEY (EmployeeID, Skill)
);

-- Employee Languages
CREATE TABLE EmployeeLanguage (
    EmployeeID INT,
    Language VARCHAR(50),
    PRIMARY KEY (EmployeeID, Language)
);

-- Data in 4NF
EmployeeSkill:
┌────────────┬────────────┐
│ EmployeeID │   Skill    │
├────────────┼────────────┤
│    E001    │   Java     │
│    E001    │   Python   │
│    E002    │    C++     │
│    E002    │   SQL      │
└────────────┴────────────┘

EmployeeLanguage:
┌────────────┬──────────┐
│ EmployeeID │ Language │
├────────────┼──────────┤
│    E001    │ English  │
│    E001    │ Spanish  │
│    E002    │ French   │
│    E002    │ German   │
└────────────┴──────────┘

Benefits:
✓ No redundancy: 2 + 2 = 4 rows total (vs 4 rows before)
✓ Easy to add skill: Add 1 row (vs 2+ rows before)
✓ Easy to add language: Add 1 row (vs 2+ rows before)
✓ Independent management of skills and languages

Example: E001 learns French
- Before 4NF: Add (E001, Java, French) and (E001, Python, French) = 2 rows
- After 4NF: Add (E001, French) = 1 row

Example: E001 learns C++
- Before 4NF: Add (E001, C++, English) and (E001, C++, Spanish) = 2 rows
- After 4NF: Add (E001, C++) = 1 row
```

**Visualization - Multi-Valued Dependency**:

```
Before 4NF (Multi-Valued Dependencies):

Employee E001:
       ┌──────────┐
       │  E001    │
       └────┬─────┘
            │
      ┌─────┴──────┐
      │            │
  ┌───▼───┐    ┌───▼─────┐
  │ Java  │    │ English │
  │Python │    │ Spanish │
  └───────┘    └─────────┘
  
  Cartesian Product Required:
  Java × English,  Java × Spanish
  Python × English, Python × Spanish
  = 4 rows

After 4NF (Separate Tables):

  ┌──────────┐        ┌──────────┐
  │  E001    │        │  E001    │
  └────┬─────┘        └────┬─────┘
       │                   │
   ┌───▼───┐           ┌───▼─────┐
   │ Java  │           │ English │
   │Python │           │ Spanish │
   └───────┘           └─────────┘
   
   2 rows + 2 rows = 4 rows total
   (More efficient for updates)
```

**中文:**

**第四范式定义**: 如果关系满足以下条件，则处于**第四范式(4NF)**:
- 已经是BCNF
- 没有非平凡多值依赖

**多值依赖**: X ↠ Y表示对于X的给定值，存在一组与Y相关的值，这些值独立于其他属性

**要点**: 4NF处理应该分别存储的独立多值事实

### Fifth Normal Form (5NF) | 第五范式

**English:**

**Definition**: A relation is in **Fifth Normal Form (5NF)**, also called **Project-Join Normal Form (PJNF)**, if:
- It is in 4NF
- It cannot be decomposed into smaller tables without loss of information
- Every join dependency is implied by candidate keys

**Join Dependency**: A relation satisfies a join dependency if it can be losslessly decomposed into multiple tables and then reconstructed by joining them.

**Key Point**: 5NF deals with cases where a table contains information that can be reconstructed from smaller tables.

**Example - Violation of 5NF (but in 4NF)**:

```sql
-- Scenario: Agent, Company, Product relationships
-- Business Rules:
-- - An agent can represent multiple companies
-- - An agent can sell multiple products
-- - A company can offer multiple products
-- - BUT: An agent can sell a product for a company ONLY if:
--   1. The agent represents that company, AND
--   2. The company offers that product, AND
--   3. The agent is authorized to sell that product

CREATE TABLE AgentCompanyProduct_4NF (
    AgentID VARCHAR(10),
    CompanyID VARCHAR(10),
    ProductID VARCHAR(10),
    PRIMARY KEY (AgentID, CompanyID, ProductID)
);

-- Sample Data
┌─────────┬───────────┬───────────┐
│ AgentID │ CompanyID │ ProductID │
├─────────┼───────────┼───────────┤
│  A001   │   C001    │   P001    │
│  A001   │   C001    │   P002    │
│  A001   │   C002    │   P001    │
│  A002   │   C001    │   P001    │
│  A002   │   C002    │   P002    │
└─────────┴───────────┴───────────┘

Join Dependencies:
This table can be losslessly decomposed into 3 binary relationships:
1. Agent-Company: Which agents represent which companies
2. Company-Product: Which companies offer which products  
3. Agent-Product: Which agents can sell which products

The original table can be reconstructed by joining these 3 tables,
but the 3-way table contains redundancy.

Problems:
1. Redundancy: The relationship is determined by 3 binary relationships
2. Update Anomaly: If we need to track any of the binary relationships
   separately, we have redundant storage
```

**Example - Converted to 5NF**:

```sql
-- Decompose into 3 binary relationship tables

-- Agent-Company Relationship
CREATE TABLE AgentCompany (
    AgentID VARCHAR(10),
    CompanyID VARCHAR(10),
    PRIMARY KEY (AgentID, CompanyID)
);

-- Company-Product Relationship
CREATE TABLE CompanyProduct (
    CompanyID VARCHAR(10),
    ProductID VARCHAR(10),
    PRIMARY KEY (CompanyID, ProductID)
);

-- Agent-Product Relationship
CREATE TABLE AgentProduct (
    AgentID VARCHAR(10),
    ProductID VARCHAR(10),
    PRIMARY KEY (AgentID, ProductID)
);

-- Data in 5NF
AgentCompany:
┌─────────┬───────────┐
│ AgentID │ CompanyID │
├─────────┼───────────┤
│  A001   │   C001    │
│  A001   │   C002    │
│  A002   │   C001    │
│  A002   │   C002    │
└─────────┴───────────┘

CompanyProduct:
┌───────────┬───────────┐
│ CompanyID │ ProductID │
├───────────┼───────────┤
│   C001    │   P001    │
│   C001    │   P002    │
│   C002    │   P001    │
│   C002    │   P002    │
└───────────┴───────────┘

AgentProduct:
┌─────────┬───────────┐
│ AgentID │ ProductID │
├─────────┼───────────┤
│  A001   │   P001    │
│  A001   │   P002    │
│  A002   │   P001    │
│  A002   │   P002    │
└─────────┴───────────┘

-- Reconstruct original using natural join:
SELECT ac.AgentID, ac.CompanyID, cp.ProductID
FROM AgentCompany ac
JOIN CompanyProduct cp ON ac.CompanyID = cp.CompanyID
JOIN AgentProduct ap ON ac.AgentID = ap.AgentID 
                    AND cp.ProductID = ap.ProductID;

Benefits:
✓ Each binary relationship stored independently
✓ No redundancy in storing relationships
✓ Easier to maintain individual relationships
✓ Can query specific relationships directly
```

**When is 5NF Practical?**

**English:**

5NF is rarely used in practice because:
1. **Complexity**: Requires deep understanding of join dependencies
2. **Performance**: Multiple joins can impact query performance
3. **Over-normalization**: Often creates too many small tables
4. **Business Logic**: Most business rules don't exhibit join dependencies

**Typical Stopping Point**: Most database designs stop at 3NF or BCNF, which provides a good balance between normalization and practicality.

**中文:**

**第五范式定义**: 如果关系满足以下条件，则处于**第五范式(5NF)**，也称为**投影-连接范式(PJNF)**:
- 已经是4NF
- 不能无损地分解为更小的表
- 每个连接依赖都由候选键隐含

**连接依赖**: 如果关系可以无损分解为多个表，然后通过连接重构，则满足连接依赖

**实用性**: 5NF在实践中很少使用，因为复杂性高、性能影响、过度规范化。大多数设计止于3NF或BCNF

### Normal Forms Summary | 范式总结

**English:**

**Comprehensive Comparison**:

| Normal Form              | Requirements                                                                         | Eliminates                                                                                            | Benefits                                                                                   | Drawbacks                                                                             | Typical Use                                                                                   |
| ------------------------ | ------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| **1NF**<br/>**第一范式** | • Atomic values<br/>• 原子值<br/>• No repeating groups<br/>• 无重复组                | • Multi-valued attributes<br/>• 多值属性<br/>• Repeating groups<br/>• 重复组                          | • Basic table structure<br/>• 基本表结构<br/>• Queryable data<br/>• 可查询数据             | • Still has redundancy<br/>• 仍有冗余<br/>• Anomalies present<br/>• 存在异常          | • All relational databases<br/>• 所有关系数据库                                               |
| **2NF**<br/>**第二范式** | • In 1NF<br/>• 满足1NF<br/>• No partial dependencies<br/>• 无部分依赖                | • Partial dependencies<br/>• 部分依赖<br/>• Some redundancy<br/>• 部分冗余                            | • Reduced redundancy<br/>• 减少冗余<br/>• Better for composite keys<br/>• 更适合复合键     | • Still has transitive deps<br/>• 仍有传递依赖<br/>• Some anomalies<br/>• 部分异常    | • Tables with composite keys<br/>• 具有复合键的表                                             |
| **3NF**<br/>**第三范式** | • In 2NF<br/>• 满足2NF<br/>• No transitive deps<br/>• 无传递依赖                     | • Transitive dependencies<br/>• 传递依赖<br/>• Most anomalies<br/>• 大部分异常                        | • Good data integrity<br/>• 良好数据完整性<br/>• Minimal redundancy<br/>• 最小冗余         | • May need many joins<br/>• 可能需要多连接<br/>• Complex queries<br/>• 复杂查询       | • Most OLTP systems<br/>• 大多数OLTP系统<br/>• Standard practice<br/>• 标准做法               |
| **BCNF**<br/>**BC范式**  | • In 3NF<br/>• 满足3NF<br/>• All determinants are superkeys<br/>• 所有决定因素为超键 | • All anomalies from FDs<br/>• 所有函数依赖异常<br/>• Overlapping candidate keys<br/>• 重叠候选键问题 | • Maximum FD normalization<br/>• 最大函数依赖规范化<br/>• Strictest rules<br/>• 最严格规则 | • May lose dependencies<br/>• 可能丢失依赖<br/>• Complex decomposition<br/>• 复杂分解 | • High integrity requirements<br/>• 高完整性需求<br/>• Strict data quality<br/>• 严格数据质量 |
| **4NF**<br/>**第四范式** | • In BCNF<br/>• 满足BCNF<br/>• No multi-valued deps<br/>• 无多值依赖                 | • Multi-valued dependencies<br/>• 多值依赖<br/>• Independent facts<br/>• 独立事实                     | • Separate independent facts<br/>• 分离独立事实<br/>• Flexible updates<br/>• 灵活更新      | • More tables<br/>• 更多表<br/>• More joins needed<br/>• 需要更多连接                 | • Many-to-many relationships<br/>• 多对多关系<br/>• Independent attributes<br/>• 独立属性     |
| **5NF**<br/>**第五范式** | • In 4NF<br/>• 满足4NF<br/>• No join dependencies<br/>• 无连接依赖                   | • Join dependencies<br/>• 连接依赖<br/>• Reconstruction redundancy<br/>• 重构冗余                     | • Complete normalization<br/>• 完全规范化<br/>• Maximum decomposition<br/>• 最大分解       | • Over-normalized<br/>• 过度规范化<br/>• Performance issues<br/>• 性能问题            | • Rarely used in practice<br/>• 实践中很少使用<br/>• Theoretical interest<br/>• 理论价值      |

**Normalization Ladder**:

```
┌─────────────────────────────────────────────────┐
│                    5NF/PJNF                     │  Most Normalized
│           (No Join Dependencies)                │  最规范化
├─────────────────────────────────────────────────┤      ▲
│                      4NF                        │      │
│       (No Multi-Valued Dependencies)            │      │
├─────────────────────────────────────────────────┤      │
│                     BCNF                        │      │
│    (All Determinants are Superkeys)             │      │
├─────────────────────────────────────────────────┤      │
│                      3NF                        │      │
│      (No Transitive Dependencies)               │      │  Increasing
├─────────────────────────────────────────────────┤      │  Normalization
│                      2NF                        │      │
│       (No Partial Dependencies)                 │      │
├─────────────────────────────────────────────────┤      │
│                      1NF                        │      │
│      (Atomic Values, No Repeating Groups)       │      │
├─────────────────────────────────────────────────┤      │
│              Un-normalized Data                 │  Least Normalized
│         (Spreadsheets, Flat Files)              │  最不规范
└─────────────────────────────────────────────────┘
```

**中文:**

**范式对比**: 从1NF到5NF，规范化程度递增，数据冗余递减，但查询复杂度增加。实践中，3NF或BCNF是最常用的范式级别。

---

## Normalization Process | 规范化过程

### Step-by-Step Normalization | 规范化步骤

**English:**

**Complete Example: Student Course System**

Let's normalize a student course registration system from un-normalized to 3NF.

#### Step 1: Un-normalized Data (Spreadsheet)

```
Student-Course Data:
┌────────┬─────────────┬───────┬───────────┬──────────────────────────┬──────────────────────────┬──────────────────────────┐
│StudentID│ StudentName │ Major │Department │     Courses              │       Grades             │      Instructors         │
├────────┼─────────────┼───────┼───────────┼──────────────────────────┼──────────────────────────┼──────────────────────────┤
│  S001  │ John Smith  │  CS   │Computing  │CS101, CS102, MATH201     │A, B+, A-                 │Dr.Brown, Dr.Wilson, Dr.Lee│
│  S002  │ Jane Doe    │  EE   │Engineering│EE101, MATH201           │B, A                      │Dr.Smith, Dr.Lee          │
│  S003  │ Bob Johnson │  CS   │Computing  │CS101, CS103             │A-, B                     │Dr.Brown, Dr.Taylor       │
└────────┴─────────────┴───────┴───────────┴──────────────────────────┴──────────────────────────┴──────────────────────────┘

Problems:
- Multi-valued attributes (Courses, Grades, Instructors)
- Repeating groups
- Cannot query individual course enrollments
- Cannot determine which instructor teaches which course
```

#### Step 2: Convert to 1NF (Eliminate Repeating Groups)

```sql
CREATE TABLE StudentCourse_1NF (
    StudentID VARCHAR(10),
    StudentName VARCHAR(100),
    Major VARCHAR(50),
    Department VARCHAR(100),
    CourseID VARCHAR(10),
    CourseName VARCHAR(100),
    Grade CHAR(2),
    InstructorName VARCHAR(100),
    PRIMARY KEY (StudentID, CourseID)
);

-- Data in 1NF
┌──────────┬─────────────┬───────┬───────────┬──────────┬─────────────┬───────┬────────────────┐
│StudentID │ StudentName │ Major │Department │ CourseID │ CourseName  │ Grade │InstructorName  │
├──────────┼─────────────┼───────┼───────────┼──────────┼─────────────┼───────┼────────────────┤
│  S001    │ John Smith  │  CS   │Computing  │  CS101   │ Database    │  A    │ Dr. Brown      │
│  S001    │ John Smith  │  CS   │Computing  │  CS102   │ Algorithms  │  B+   │ Dr. Wilson     │
│  S001    │ John Smith  │  CS   │Computing  │ MATH201  │ Calculus    │  A-   │ Dr. Lee        │
│  S002    │ Jane Doe    │  EE   │Engineering│  EE101   │ Circuits    │  B    │ Dr. Smith      │
│  S002    │ Jane Doe    │  EE   │Engineering│ MATH201  │ Calculus    │  A    │ Dr. Lee        │
│  S003    │ Bob Johnson │  CS   │Computing  │  CS101   │ Database    │  A-   │ Dr. Brown      │
│  S003    │ Bob Johnson │  CS   │Computing  │  CS103   │ Programming │  B    │ Dr. Taylor     │
└──────────┴─────────────┴───────┴───────────┴──────────┴─────────────┴───────┴────────────────┘

Achievements:
✓ Atomic values only
✓ No repeating groups
✓ Each row represents one enrollment

Remaining Problems:
✗ Student information repeated (partial dependency)
✗ Course information repeated (partial dependency)
✗ Department depends on Major (transitive dependency)
```

#### Step 3: Convert to 2NF (Eliminate Partial Dependencies)

**Functional Dependencies Analysis**:
```
Primary Key: {StudentID, CourseID}

Partial Dependencies:
- StudentID → StudentName, Major, Department
- CourseID → CourseName, InstructorName

Full Dependencies:
- {StudentID, CourseID} → Grade
```

**Decomposition**:

```sql
-- Table 1: Student
CREATE TABLE Student_2NF (
    StudentID VARCHAR(10) PRIMARY KEY,
    StudentName VARCHAR(100),
    Major VARCHAR(50),
    Department VARCHAR(100)
);

-- Table 2: Course  
CREATE TABLE Course_2NF (
    CourseID VARCHAR(10) PRIMARY KEY,
    CourseName VARCHAR(100),
    InstructorName VARCHAR(100)
);

-- Table 3: Enrollment
CREATE TABLE Enrollment_2NF (
    StudentID VARCHAR(10),
    CourseID VARCHAR(10),
    Grade CHAR(2),
    PRIMARY KEY (StudentID, CourseID),
    FOREIGN KEY (StudentID) REFERENCES Student_2NF(StudentID),
    FOREIGN KEY (CourseID) REFERENCES Course_2NF(CourseID)
);

-- Data in 2NF
Student_2NF:
┌──────────┬─────────────┬───────┬───────────┐
│StudentID │ StudentName │ Major │Department │
├──────────┼─────────────┼───────┼───────────┤
│  S001    │ John Smith  │  CS   │Computing  │
│  S002    │ Jane Doe    │  EE   │Engineering│
│  S003    │ Bob Johnson │  CS   │Computing  │
└──────────┴─────────────┴───────┴───────────┘

Course_2NF:
┌──────────┬─────────────┬────────────────┐
│ CourseID │ CourseName  │InstructorName  │
├──────────┼─────────────┼────────────────┤
│  CS101   │ Database    │ Dr. Brown      │
│  CS102   │ Algorithms  │ Dr. Wilson     │
│  CS103   │ Programming │ Dr. Taylor     │
│  EE101   │ Circuits    │ Dr. Smith      │
│ MATH201  │ Calculus    │ Dr. Lee        │
└──────────┴─────────────┴────────────────┘

Enrollment_2NF:
┌──────────┬──────────┬───────┐
│StudentID │ CourseID │ Grade │
├──────────┼──────────┼───────┤
│  S001    │  CS101   │  A    │
│  S001    │  CS102   │  B+   │
│  S001    │ MATH201  │  A-   │
│  S002    │  EE101   │  B    │
│  S002    │ MATH201  │  A    │
│  S003    │  CS101   │  A-   │
│  S003    │  CS103   │  B    │
└──────────┴──────────┴───────┘

Achievements:
✓ No partial dependencies
✓ Student data stored once
✓ Course data stored once

Remaining Problems:
✗ Department depends on Major (transitive dependency in Student table)
```

#### Step 4: Convert to 3NF (Eliminate Transitive Dependencies)

**Transitive Dependency Analysis**:
```
In Student_2NF:
- StudentID → Major (Direct)
- Major → Department (Direct)
- StudentID → Department (Transitive through Major)
```

**Final Decomposition**:

```sql
-- Table 1: Student (final)
CREATE TABLE Student (
    StudentID VARCHAR(10) PRIMARY KEY,
    StudentName VARCHAR(100),
    Major VARCHAR(50),
    FOREIGN KEY (Major) REFERENCES MajorDepartment(Major)
);

-- Table 2: Major-Department
CREATE TABLE MajorDepartment (
    Major VARCHAR(50) PRIMARY KEY,
    Department VARCHAR(100)
);

-- Table 3: Course (final)
CREATE TABLE Course (
    CourseID VARCHAR(10) PRIMARY KEY,
    CourseName VARCHAR(100),
    InstructorName VARCHAR(100)
);

-- Table 4: Enrollment (final)
CREATE TABLE Enrollment (
    StudentID VARCHAR(10),
    CourseID VARCHAR(10),
    Grade CHAR(2),
    PRIMARY KEY (StudentID, CourseID),
    FOREIGN KEY (StudentID) REFERENCES Student(StudentID),
    FOREIGN KEY (CourseID) REFERENCES Course(CourseID)
);

-- Data in 3NF
Student:
┌──────────┬─────────────┬───────┐
│StudentID │ StudentName │ Major │
├──────────┼─────────────┼───────┤
│  S001    │ John Smith  │  CS   │
│  S002    │ Jane Doe    │  EE   │
│  S003    │ Bob Johnson │  CS   │
└──────────┴─────────────┴───────┘

MajorDepartment:
┌───────┬────────────┐
│ Major │ Department │
├───────┼────────────┤
│  CS   │ Computing  │
│  EE   │ Engineering│
└───────┴────────────┘

Course:
┌──────────┬─────────────┬────────────────┐
│ CourseID │ CourseName  │InstructorName  │
├──────────┼─────────────┼────────────────┤
│  CS101   │ Database    │ Dr. Brown      │
│  CS102   │ Algorithms  │ Dr. Wilson     │
│  CS103   │ Programming │ Dr. Taylor     │
│  EE101   │ Circuits    │ Dr. Smith      │
│ MATH201  │ Calculus    │ Dr. Lee        │
└──────────┴─────────────┴────────────────┘

Enrollment:
┌──────────┬──────────┬───────┐
│StudentID │ CourseID │ Grade │
├──────────┼──────────┼───────┤
│  S001    │  CS101   │  A    │
│  S001    │  CS102   │  B+   │
│  S001    │ MATH201  │  A-   │
│  S002    │  EE101   │  B    │
│  S002    │ MATH201  │  A    │
│  S003    │  CS101   │  A-   │
│  S003    │  CS103   │  B    │
└──────────┴──────────┴───────┘

Final Achievements:
✓ No partial dependencies
✓ No transitive dependencies
✓ Minimal redundancy
✓ Good data integrity
✓ Easy to maintain
```

**中文:**

**完整规范化示例**: 从非规范化数据到3NF的完整转换过程，包括识别函数依赖、分解表、建立外键关系。

---

## Data Anomalies | 数据异常

### Types of Anomalies | 异常类型

**English:**

Data anomalies are problems that occur in poorly designed databases, particularly in un-normalized or under-normalized tables.

#### 1. Insertion Anomaly | 插入异常

**Definition**: Inability to insert data into the database without the presence of other data.

**Example**:

```sql
-- Problem Table (Not in 2NF)
CREATE TABLE EmployeeDepartment_Bad (
    EmployeeID INT PRIMARY KEY,
    EmployeeName VARCHAR(100),
    DepartmentID INT,
    DepartmentName VARCHAR(100),
    DepartmentBudget DECIMAL(12, 2)
);

┌────────────┬──────────────┬──────────────┬────────────────┬──────────────────┐
│ EmployeeID │ EmployeeName │ DepartmentID │ DepartmentName │ DepartmentBudget │
├────────────┼──────────────┼──────────────┼────────────────┼──────────────────┤
│    E001    │  John Smith  │     D01      │      Sales     │    500000.00     │
│    E002    │  Jane Doe    │     D01      │      Sales     │    500000.00     │
└────────────┴──────────────┴──────────────┴────────────────┴──────────────────┘

Insertion Anomaly:
❌ Cannot add a new department (D03, HR, 300000) without hiring an employee
❌ Need to create a "dummy" employee just to store department information
```

**Solution (2NF/3NF)**:

```sql
-- Separate tables
CREATE TABLE Employee (
    EmployeeID INT PRIMARY KEY,
    EmployeeName VARCHAR(100),
    DepartmentID INT,
    FOREIGN KEY (DepartmentID) REFERENCES Department(DepartmentID)
);

CREATE TABLE Department (
    DepartmentID INT PRIMARY KEY,
    DepartmentName VARCHAR(100),
    DepartmentBudget DECIMAL(12, 2)
);

-- Now we can insert department independently:
INSERT INTO Department VALUES (D03, 'HR', 300000.00); ✓
```

#### 2. Deletion Anomaly | 删除异常

**Definition**: Deletion of data results in unintended loss of other important data.

**Example**:

```sql
-- Using the same EmployeeDepartment_Bad table

┌────────────┬──────────────┬──────────────┬────────────────┬──────────────────┐
│ EmployeeID │ EmployeeName │ DepartmentID │ DepartmentName │ DepartmentBudget │
├────────────┼──────────────┼──────────────┼────────────────┼──────────────────┤
│    E001    │  John Smith  │     D01      │      Sales     │    500000.00     │
│    E002    │  Jane Doe    │     D01      │      Sales     │    500000.00     │
│    E003    │ Bob Johnson  │     D02      │        IT      │    800000.00     │ ← Only IT employee
└────────────┴──────────────┴──────────────┴────────────────┴──────────────────┘

Deletion Anomaly:
❌ If we delete Bob Johnson (E003), we lose ALL information about IT department
❌ Department D02's name and budget information is lost

-- Delete employee
DELETE FROM EmployeeDepartment_Bad WHERE EmployeeID = 'E003';

-- Result: IT department information is gone!
```

**Solution (2NF/3NF)**:

```sql
-- With separate tables:
DELETE FROM Employee WHERE EmployeeID = 'E003';

-- Department information is preserved in Department table ✓
SELECT * FROM Department WHERE DepartmentID = 'D02';
-- Returns: D02, IT, 800000.00
```

#### 3. Update Anomaly | 更新异常

**Definition**: Updates to data require multiple row changes, leading to possible inconsistencies.

**Example**:

```sql
-- Using EmployeeDepartment_Bad table

┌────────────┬──────────────┬──────────────┬────────────────┬──────────────────┐
│ EmployeeID │ EmployeeName │ DepartmentID │ DepartmentName │ DepartmentBudget │
├────────────┼──────────────┼──────────────┼────────────────┼──────────────────┤
│    E001    │  John Smith  │     D01      │      Sales     │    500000.00     │
│    E002    │  Jane Doe    │     D01      │      Sales     │    500000.00     │
│    E003    │ Bob Johnson  │     D01      │      Sales     │    500000.00     │
│    E004    │ Alice Brown  │     D01      │      Sales     │    500000.00     │
└────────────┴──────────────┴──────────────┴────────────────┴──────────────────┘

Update Anomaly:
❌ To change Sales department budget from 500000 to 600000:
   Need to update 4 rows (one for each employee)
   
❌ Risk of inconsistency if update fails partially:

-- Problematic update
UPDATE EmployeeDepartment_Bad 
SET DepartmentBudget = 600000.00 
WHERE DepartmentID = 'D01';

-- If this fails after updating 2 rows, data becomes inconsistent:
┌────────────┬──────────────┬──────────────┬────────────────┬──────────────────┐
│ EmployeeID │ EmployeeName │ DepartmentID │ DepartmentName │ DepartmentBudget │
├────────────┼──────────────┼──────────────┼────────────────┼──────────────────┤
│    E001    │  John Smith  │     D01      │      Sales     │    600000.00     │ ✓ Updated
│    E002    │  Jane Doe    │     D01      │      Sales     │    600000.00     │ ✓ Updated
│    E003    │ Bob Johnson  │     D01      │      Sales     │    500000.00     │ ✗ Not updated
│    E004    │ Alice Brown  │     D01      │      Sales     │    500000.00     │ ✗ Not updated
└────────────┴──────────────┴──────────────┴────────────────┴──────────────────┘
                                                        ↑
                                          Data Inconsistency!
```

**Solution (2NF/3NF)**:

```sql
-- With normalized tables:
UPDATE Department 
SET DepartmentBudget = 600000.00 
WHERE DepartmentID = 'D01';

-- Only ONE row updated ✓
-- No risk of inconsistency ✓
```

**Anomalies Summary**:

| Anomaly Type                   | Problem                                                        | Cause                                             | Solution                                             |
| ------------------------------ | -------------------------------------------------------------- | ------------------------------------------------- | ---------------------------------------------------- |
| **Insertion**<br/>**插入异常** | Cannot insert data without other data<br/>无法单独插入某类数据 | Partial/Transitive dependencies<br/>部分/传递依赖 | Decompose to 2NF/3NF<br/>分解到2NF/3NF               |
| **Deletion**<br/>**删除异常**  | Deleting data loses other information<br/>删除数据丢失其他信息 | Data redundancy<br/>数据冗余                      | Separate tables<br/>分离表                           |
| **Update**<br/>**更新异常**    | Updates require multiple row changes<br/>更新需要修改多行      | Data duplication<br/>数据重复                     | Normalize to eliminate redundancy<br/>规范化消除冗余 |

**中文:**

**数据异常**: 设计不良的数据库中出现的问题，特别是在非规范化或规范化不足的表中。

**三种异常**:
1. **插入异常**: 无法单独插入某类数据
2. **删除异常**: 删除数据导致其他信息丢失
3. **更新异常**: 更新需要修改多行，可能导致不一致

**解决方案**: 通过规范化到2NF/3NF，将数据分解到独立的表中

---

## Denormalization | 反规范化

### When and Why to Denormalize | 何时及为何反规范化

**English:**

**Denormalization** is the intentional introduction of redundancy into a database design to improve read performance. It's a trade-off between normalization (data integrity) and performance (query speed).

**When to Consider Denormalization**:

1. **Read-Heavy Workloads**: When reads significantly outnumber writes
2. **Performance Critical Queries**: When joins are causing performance bottlenecks
3. **Reporting/Analytics**: For OLAP systems or data warehouses
4. **Frequently Accessed Aggregations**: When summary data is queried often
5. **Historical Data**: When data doesn't change frequently

**Denormalization Techniques**:

#### 1. Adding Redundant Columns

**Example**:

```sql
-- Fully Normalized (3NF)
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    CustomerName VARCHAR(100),
    CustomerEmail VARCHAR(100),
    CustomerCity VARCHAR(50)
);

-- Query requiring join:
SELECT O.OrderID, O.OrderDate, C.CustomerName, C.CustomerCity
FROM Orders O
JOIN Customers C ON O.CustomerID = C.CustomerID
WHERE O.OrderDate >= '2024-01-01';

-- Denormalized (adding redundant column)
CREATE TABLE Orders_Denorm (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    CustomerName VARCHAR(100),  -- Redundant!
    OrderDate DATE,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

-- Faster query (no join needed):
SELECT OrderID, OrderDate, CustomerName
FROM Orders_Denorm
WHERE OrderDate >= '2024-01-01';

Trade-offs:
✓ Faster reads (no join)
✗ Data redundancy
✗ Update complexity (must update both tables when customer name changes)
✗ Storage overhead
```

#### 2. Derived/Calculated Columns

**Example**:

```sql
-- Normalized
CREATE TABLE OrderItems (
    OrderItemID INT PRIMARY KEY,
    OrderID INT,
    ProductID INT,
    Quantity INT,
    UnitPrice DECIMAL(10, 2)
);

-- Query calculating total:
SELECT OrderID, 
       SUM(Quantity * UnitPrice) AS OrderTotal
FROM OrderItems
GROUP BY OrderID;

-- Denormalized (add calculated column)
CREATE TABLE Orders_Denorm2 (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE,
    OrderTotal DECIMAL(12, 2)  -- Derived/Calculated!
);

-- Faster query:
SELECT OrderID, OrderTotal
FROM Orders_Denorm2
WHERE OrderDate >= '2024-01-01';

Maintenance (using triggers):
CREATE TRIGGER UpdateOrderTotal
AFTER INSERT OR UPDATE OR DELETE ON OrderItems
FOR EACH ROW
BEGIN
    UPDATE Orders_Denorm2
    SET OrderTotal = (
        SELECT SUM(Quantity * UnitPrice)
        FROM OrderItems
        WHERE OrderID = NEW.OrderID
    )
    WHERE OrderID = NEW.OrderID;
END;

Trade-offs:
✓ Instant access to aggregated data
✗ Must maintain consistency with triggers or application logic
✗ Storage for derived data
```

#### 3. Summary/Aggregation Tables

**Example**:

```sql
-- Normalized transaction table
CREATE TABLE Sales (
    SaleID INT PRIMARY KEY,
    ProductID INT,
    SaleDate DATE,
    Quantity INT,
    Amount DECIMAL(10, 2)
);

-- Expensive query for daily sales report:
SELECT 
    DATE(SaleDate) AS SaleDay,
    SUM(Amount) AS DailySales,
    SUM(Quantity) AS ItemsSold,
    COUNT(*) AS TransactionCount
FROM Sales
WHERE SaleDate >= '2024-01-01'
GROUP BY DATE(SaleDate);

-- Denormalized summary table
CREATE TABLE DailySalesSummary (
    SaleDate DATE PRIMARY KEY,
    TotalSales DECIMAL(12, 2),
    TotalQuantity INT,
    TransactionCount INT,
    LastUpdated TIMESTAMP
);

-- Fast query:
SELECT * FROM DailySalesSummary
WHERE SaleDate >= '2024-01-01';

-- Maintain with scheduled job or trigger
INSERT INTO DailySalesSummary
SELECT 
    DATE(SaleDate),
    SUM(Amount),
    SUM(Quantity),
    COUNT(*),
    NOW()
FROM Sales
WHERE DATE(SaleDate) = CURRENT_DATE
GROUP BY DATE(SaleDate)
ON DUPLICATE KEY UPDATE
    TotalSales = VALUES(TotalSales),
    TotalQuantity = VALUES(TotalQuantity),
    TransactionCount = VALUES(TransactionCount),
    LastUpdated = VALUES(LastUpdated);

Trade-offs:
✓ Extremely fast reporting queries
✗ Additional storage
✗ Maintenance overhead
✗ Potential staleness (eventual consistency)
```

#### 4. Materialized Views

**Example**:

```sql
-- Normalized schema
CREATE TABLE Products (ProductID INT PRIMARY KEY, ProductName VARCHAR(100), CategoryID INT);
CREATE TABLE Categories (CategoryID INT PRIMARY KEY, CategoryName VARCHAR(100));
CREATE TABLE OrderItems (OrderItemID INT PRIMARY KEY, ProductID INT, Quantity INT, Price DECIMAL(10,2));

-- Complex query:
SELECT 
    C.CategoryName,
    P.ProductName,
    SUM(OI.Quantity) AS TotalQuantitySold,
    SUM(OI.Quantity * OI.Price) AS TotalRevenue
FROM OrderItems OI
JOIN Products P ON OI.ProductID = P.ProductID
JOIN Categories C ON P.CategoryID = C.CategoryID
GROUP BY C.CategoryName, P.ProductName;

-- Materialized view (PostgreSQL example)
CREATE MATERIALIZED VIEW ProductSalesSummary AS
SELECT 
    C.CategoryName,
    P.ProductName,
    SUM(OI.Quantity) AS TotalQuantitySold,
    SUM(OI.Quantity * OI.Price) AS TotalRevenue
FROM OrderItems OI
JOIN Products P ON OI.ProductID = P.ProductID
JOIN Categories C ON P.CategoryID = C.CategoryID
GROUP BY C.CategoryName, P.ProductName;

-- Fast query:
SELECT * FROM ProductSalesSummary
WHERE CategoryName = 'Electronics';

-- Refresh when needed:
REFRESH MATERIALIZED VIEW ProductSalesSummary;

Trade-offs:
✓ Pre-computed joins and aggregations
✓ Database-managed
✗ Needs periodic refresh
✗ May be stale between refreshes
```

**Denormalization Decision Matrix**:

| Factor                                  | Normalize                        | Denormalize                                   |
| --------------------------------------- | -------------------------------- | --------------------------------------------- |
| **Write Frequency**<br/>**写入频率**    | High writes<br/>高频写入         | Low writes, high reads<br/>低频写入，高频读取 |
| **Data Volatility**<br/>**数据变化**    | Frequently changing<br/>频繁变化 | Stable/Historical<br/>稳定/历史数据           |
| **Query Complexity**<br/>**查询复杂度** | Simple queries<br/>简单查询      | Complex joins/aggregations<br/>复杂连接/聚合  |
| **Data Integrity**<br/>**数据完整性**   | Critical<br/>关键                | Less critical<br/>不太关键                    |
| **Storage Cost**<br/>**存储成本**       | Limited storage<br/>存储有限     | Storage abundant<br/>存储充足                 |
| **Consistency Req**<br/>**一致性需求**  | Strong consistency<br/>强一致性  | Eventual consistency OK<br/>最终一致性可接受  |

**Best Practices for Denormalization**:

1. **Document Everything**: Clearly document denormalized structures
2. **Maintain Integrity**: Use triggers, stored procedures, or application logic
3. **Monitor Performance**: Measure actual performance gains
4. **Version Control**: Keep normalized schema as source of truth
5. **Selective Denormalization**: Only denormalize where truly needed
6. **Consider Alternatives**: Try indexes, query optimization, caching first

**中文:**

**反规范化**: 为提高读取性能而有意引入冗余到数据库设计中。这是数据完整性和查询速度之间的权衡。

**何时考虑反规范化**:
- 读密集型工作负载
- 性能关键查询
- 报表/分析系统
- 频繁访问的聚合数据
- 历史数据

**反规范化技术**:
1. 添加冗余列
2. 派生/计算列
3. 汇总/聚合表
4. 物化视图

**权衡决策**: 根据写入频率、数据变化、查询复杂度、数据完整性、存储成本、一致性需求等因素决定

---

## Exam Focus Points | 考试要点

### Key Exam Topics | 重点考试内容

**English:**

#### 1. Functional Dependency Identification

**Common Question Types**:
- Given a relation and business rules, identify all functional dependencies
- Determine candidate keys from functional dependencies
- Calculate attribute closure

**Example Exam Question**:

```
Question:
Given relation R(A, B, C, D, E) and functional dependencies:
F = {A → BC, CD → E, B → D, E → A}

a) Find all candidate keys
b) Calculate the closure of A (A⁺)
c) Determine if AB → E holds

Solution:

a) Finding candidate keys:
   - Start with attributes not on RHS: None (all appear on RHS)
   - Try single attributes:
     A⁺ = {A, B, C, D, E} = All attributes ✓ (A is a candidate key)
     B⁺ = {B, D} ✗
     C⁺ = {C} ✗
     D⁺ = {D} ✗
     E⁺ = {E, A, B, C, D} = All attributes ✓ (E is a candidate key)
   
   Candidate Keys: {A}, {E}

b) A⁺ calculation:
   Step 1: A⁺ = {A}
   Step 2: A → BC, so A⁺ = {A, B, C}
   Step 3: B → D, so A⁺ = {A, B, C, D}
   Step 4: CD → E (CD ⊆ A⁺), so A⁺ = {A, B, C, D, E}
   
   Result: A⁺ = {A, B, C, D, E}

c) Testing AB → E:
   Calculate (AB)⁺:
   (AB)⁺ = {A, B}
   A → BC, so (AB)⁺ = {A, B, C}
   B → D, so (AB)⁺ = {A, B, C, D}
   CD → E, so (AB)⁺ = {A, B, C, D, E}
   
   Since E ∈ (AB)⁺, AB → E holds ✓
```

#### 2. Normal Form Determination

**Common Question Types**:
- Given a relation and FDs, determine the highest normal form
- Identify violations of specific normal forms

**Example Exam Question**:

```
Question:
Relation R(StudentID, CourseID, InstructorID, Grade, InstructorName)
Functional Dependencies:
- {StudentID, CourseID} → Grade
- {StudentID, CourseID} → InstructorID
- InstructorID → InstructorName
- CourseID → InstructorID

Primary Key: {StudentID, CourseID}

Determine the highest normal form of R and explain.

Solution:

1NF Check:
✓ All attributes are atomic
✓ No repeating groups
Conclusion: R is in 1NF

2NF Check:
- Is InstructorName fully dependent on {StudentID, CourseID}?
  CourseID → InstructorID → InstructorName (partial dependency)
  ✗ InstructorName depends only on CourseID (part of key)
- Is InstructorID fully dependent on {StudentID, CourseID}?
  CourseID → InstructorID (partial dependency)
  ✗ InstructorID depends only on CourseID (part of key)

Conclusion: R is NOT in 2NF due to partial dependencies

Answer: R is in 1NF but NOT in 2NF
```

#### 3. Schema Decomposition

**Common Question Types**:
- Decompose a relation to achieve a specific normal form
- Verify if decomposition is lossless
- Check if decomposition preserves dependencies

**Example Exam Question**:

```
Question:
Decompose the following relation to 3NF:

R(OrderID, CustomerID, CustomerName, CustomerCity, OrderDate, TotalAmount)

Functional Dependencies:
- OrderID → CustomerID, OrderDate, TotalAmount
- CustomerID → CustomerName, CustomerCity

Solution:

Step 1: Identify violations
- Primary Key: OrderID
- Transitive dependency: OrderID → CustomerID → CustomerName
- Transitive dependency: OrderID → CustomerID → CustomerCity

Step 2: Decompose to eliminate transitive dependencies

R1 (Order):
- Attributes: (OrderID, CustomerID, OrderDate, TotalAmount)
- Primary Key: OrderID
- Foreign Key: CustomerID references R2
- FD: OrderID → CustomerID, OrderDate, TotalAmount

R2 (Customer):
- Attributes: (CustomerID, CustomerName, CustomerCity)
- Primary Key: CustomerID
- FD: CustomerID → CustomerName, CustomerCity

Step 3: Verify 3NF
R1: ✓ No transitive dependencies (all non-key depend only on OrderID)
R2: ✓ No transitive dependencies (all non-key depend only on CustomerID)

Step 4: Verify lossless join
Join R1 and R2 on CustomerID:
R1 ⋈ R2 = Original R ✓

Step 5: Verify dependency preservation
All original FDs can be checked in R1 or R2 ✓

Answer: Decomposed to R1(OrderID, CustomerID, OrderDate, TotalAmount) 
         and R2(CustomerID, CustomerName, CustomerCity)
```

### Exam Tips | 考试技巧

**English:**

**For Multiple Choice Questions**:

1. **Identify the primary key first** - This helps determine dependencies
2. **Check normal forms in order** - 1NF → 2NF → 3NF → BCNF
3. **Look for keywords**:
   - "Atomic values" → 1NF
   - "Partial dependency" → Violates 2NF
   - "Transitive dependency" → Violates 3NF
   - "Determinant is not superkey" → Violates BCNF

**For Case Analysis Questions**:

1. **Read business rules carefully** - They define functional dependencies
2. **Draw dependency diagrams** - Visualize relationships
3. **Show your work** - Demonstrate normalization steps
4. **Verify your answer** - Check that anomalies are eliminated

**Common Mistakes to Avoid**:

❌ Confusing partial and transitive dependencies
❌ Forgetting to check all candidate keys
❌ Over-decomposing (creating too many tables)
❌ Not verifying lossless join property
❌ Missing foreign key relationships

**Answer Templates**:

**Template 1: Normal Form Determination**
```
1. State the relation and primary key
2. List all functional dependencies
3. Check each normal form in order:
   - 1NF: Atomic values? Yes/No
   - 2NF: No partial dependencies? Yes/No
   - 3NF: No transitive dependencies? Yes/No
   - BCNF: All determinants are superkeys? Yes/No
4. Conclude: "The relation is in [X]NF but not in [X+1]NF because..."
```

**Template 2: Decomposition**
```
1. Identify the problem (partial/transitive dependency)
2. For each table:
   - List attributes
   - Specify primary key
   - Specify foreign keys
   - List functional dependencies
3. Verify:
   - Lossless join (natural join reconstructs original)
   - Dependency preservation (all FDs checkable)
   - Target normal form achieved
```

**中文:**

**考试重点**:
1. 函数依赖识别
2. 范式判定
3. 模式分解

**答题技巧**:
- 先识别主键
- 按顺序检查范式
- 注意关键词
- 画依赖图
- 展示步骤
- 验证答案

**常见错误**:
- 混淆部分依赖和传递依赖
- 忘记检查所有候选键
- 过度分解
- 未验证无损连接
- 遗漏外键关系

---

## References | 参考资料

**English:**

### Books | 书籍

1. **Database System Concepts** by Silberschatz, Korth, and Sudarshan
   - Comprehensive coverage of normalization theory
   - Chapter on relational database design

2. **Fundamentals of Database Systems** by Elmasri and Navathe
   - Detailed explanation of normal forms
   - Practical examples and exercises

3. **Database Design for Mere Mortals** by Michael J. Hernandez
   - Beginner-friendly approach to normalization
   - Real-world case studies

### Online Resources | 在线资源

1. **Stanford Database Course** (db.stanford.edu)
   - Free online lectures on database design
   - Normalization tutorials

2. **W3Schools SQL Tutorial** (w3schools.com/sql)
   - Interactive SQL examples
   - Database design basics

### Key Papers | 重要论文

1. **E.F. Codd (1970)**: "A Relational Model of Data for Large Shared Data Banks"
   - Original paper introducing relational model

2. **E.F. Codd (1972)**: "Further Normalization of the Data Base Relational Model"
   - Introduction of 2NF and 3NF

**中文:**

### 推荐书籍

1. **《数据库系统概念》** (中文版)
   - 数据库理论经典教材
   - 详细讲解规范化理论

2. **《数据库系统实现》**
   - 实践导向的数据库设计
   - 包含大量案例分析

3. **《软考架构师教程》**
   - 针对软考的复习资料
   - 历年真题分析

### 学习建议

1. **理论与实践结合**: 理解概念后，动手设计数据库
2. **多做练习题**: 特别是范式判定和模式分解
3. **分析实际系统**: 研究成熟系统的数据库设计
4. **掌握权衡**: 理解何时规范化，何时反规范化

---

**Document Prepared by Database Normalization Expert**

**文档由数据库规范化专家编写**

*Last Updated: December 2024*

*最后更新: 2024年12月*