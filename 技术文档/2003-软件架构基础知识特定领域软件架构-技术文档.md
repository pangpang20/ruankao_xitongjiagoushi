# Domain-Specific Software Architecture
# 软件架构基础知识特定领域软件架构

## Table of Contents | 目录

1. [Overview](#overview)
2. [Domain-Driven Design Fundamentals](#ddd-fundamentals)
3. [Domain-Specific Architectural Patterns](#architectural-patterns)
4. [Industry-Specific Architectures](#industry-architectures)
5. [Domain Modeling Techniques](#domain-modeling)
6. [Architecture Decision Records](#architecture-decisions)
7. [Integration and Bounded Context Collaboration](#integration)
8. [Quality Attributes for Domain Architecture](#quality-attributes)
9. [Migration and Evolution Strategies](#migration-strategies)
10. [Tools and Frameworks](#tools-frameworks)
11. [Best Practices](#best-practices)
12. [Common Pitfalls](#common-pitfalls)

---

## 1. Overview

### 1.1 Definition | 定义

**Domain-Specific Software Architecture** refers to software architecture designs that are tailored to the specific characteristics, requirements, and constraints of a particular business domain or industry sector. Unlike generic architectural patterns, domain-specific architectures deeply integrate business rules, processes, and domain knowledge into the structural design of the system.

**特定领域软件架构**是指针对特定业务领域或行业部门的特定特征、需求和约束而定制的软件架构设计。与通用架构模式不同,特定领域架构将业务规则、流程和领域知识深度集成到系统的结构设计中。

### 1.2 Key Characteristics | 关键特征

**Domain-Centric Design Principles:**

**以领域为中心的设计原则:**

```
Traditional Architecture          Domain-Specific Architecture
传统架构                          特定领域架构

┌─────────────────────┐          ┌─────────────────────┐
│   Presentation      │          │  Bounded Context 1  │
│   表示层            │          │  限界上下文1         │
├─────────────────────┤          │  ┌──────────────┐   │
│   Business Logic    │          │  │ Domain Model │   │
│   业务逻辑          │    VS    │  │ 领域模型     │   │
├─────────────────────┤          │  └──────────────┘   │
│   Data Access       │          └─────────────────────┘
│   数据访问          │          ┌─────────────────────┐
├─────────────────────┤          │  Bounded Context 2  │
│   Database          │          │  限界上下文2         │
│   数据库            │          │  ┌──────────────┐   │
└─────────────────────┘          │  │ Domain Model │   │
                                 │  │ 领域模型     │   │
Generic Layers                   │  └──────────────┘   │
通用分层                         └─────────────────────┘

                                 Business-Driven Boundaries
                                 业务驱动的边界
```

**Core Characteristics:**

**核心特征:**

1. **Ubiquitous Language** - Shared vocabulary between developers and domain experts
   - **通用语言** - 开发人员和领域专家之间的共享词汇

2. **Bounded Contexts** - Explicit boundaries around domain models
   - **限界上下文** - 领域模型周围的显式边界

3. **Domain Models** - Rich behavioral models, not just data structures
   - **领域模型** - 丰富的行为模型,而不仅仅是数据结构

4. **Business Logic Centralization** - Core domain logic isolated from infrastructure
   - **业务逻辑集中化** - 核心领域逻辑与基础设施隔离

5. **Continuous Refinement** - Architecture evolves with domain understanding
   - **持续精炼** - 架构随领域理解而演进

### 1.3 Benefits and Challenges | 优势和挑战

**Benefits:**

**优势:**

✅ **Business Alignment** - Architecture directly reflects business concepts
- **业务对齐** - 架构直接反映业务概念

✅ **Maintainability** - Clear boundaries and responsibilities
- **可维护性** - 清晰的边界和职责

✅ **Flexibility** - Easier to adapt to changing business requirements
- **灵活性** - 更容易适应不断变化的业务需求

✅ **Knowledge Preservation** - Domain knowledge captured in code structure
- **知识保存** - 领域知识在代码结构中被捕获

✅ **Team Organization** - Clear ownership of bounded contexts
- **团队组织** - 限界上下文的明确所有权

**Challenges:**

**挑战:**

⚠️ **Learning Curve** - Requires domain expertise and DDD knowledge
- **学习曲线** - 需要领域专业知识和DDD知识

⚠️ **Initial Complexity** - More upfront design effort
- **初始复杂性** - 更多的前期设计工作

⚠️ **Integration Complexity** - Multiple bounded contexts need coordination
- **集成复杂性** - 多个限界上下文需要协调

⚠️ **Organizational Challenges** - Requires close collaboration with domain experts
- **组织挑战** - 需要与领域专家密切合作

---

## 2. Domain-Driven Design Fundamentals

### 2.1 Strategic Design | 战略设计

#### 2.1.1 Bounded Context | 限界上下文

**Definition**: A bounded context is a conceptual boundary where a particular domain model is defined and applicable. Within this boundary, all terms, definitions, and rules have specific, unambiguous meanings.

**定义**: 限界上下文是一个概念边界,在其中定义和应用特定的领域模型。在此边界内,所有术语、定义和规则都具有特定的、明确的含义。

**Example: E-commerce System**

**示例: 电子商务系统**

```
┌─────────────────────────────────────────────────────────────┐
│           E-Commerce Domain                                 │
│           电子商务领域                                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────────┐      ┌──────────────────┐           │
│  │  Catalog Context │      │  Order Context   │           │
│  │  目录上下文      │      │  订单上下文      │           │
│  │                  │      │                  │           │
│  │  - Product       │      │  - Order         │           │
│  │  - Category      │      │  - OrderItem     │           │
│  │  - Price         │      │  - Customer      │           │
│  │    产品/分类/价格│      │    订单/订单项   │           │
│  └──────────────────┘      └──────────────────┘           │
│           │                         │                      │
│           │                         │                      │
│  ┌──────────────────┐      ┌──────────────────┐           │
│  │ Inventory Context│      │ Payment Context  │           │
│  │ 库存上下文       │      │ 支付上下文       │           │
│  │                  │      │                  │           │
│  │  - Stock         │      │  - Payment       │           │
│  │  - Warehouse     │      │  - Transaction   │           │
│  │  - Reservation   │      │  - Refund        │           │
│  │    库存/仓库     │      │    支付/交易     │           │
│  └──────────────────┘      └──────────────────┘           │
│                                                             │
└─────────────────────────────────────────────────────────────┘

Note: "Customer" in Order Context vs. Catalog Context
注意: 订单上下文中的"客户"与目录上下文中的不同

Order Context: Customer = Buyer with shipping address
订单上下文: 客户 = 有收货地址的买家

Catalog Context: Customer = Anonymous viewer with preferences
目录上下文: 客户 = 有偏好的匿名查看者
```

**Bounded Context Identification Guidelines:**

**限界上下文识别指南:**

1. **Linguistic Boundaries** - Different meanings of same terms
   - **语言边界** - 相同术语的不同含义

2. **Team Boundaries** - Different teams own different parts
   - **团队边界** - 不同团队拥有不同部分

3. **Functional Cohesion** - Related capabilities grouped together
   - **功能内聚** - 相关能力组合在一起

4. **Change Frequency** - Parts that change together
   - **变更频率** - 一起变更的部分

5. **Data Ownership** - Clear data responsibilities
   - **数据所有权** - 明确的数据职责

#### 2.1.2 Context Mapping | 上下文映射

**Context Map Patterns:**

**上下文映射模式:**

```
Context Mapping Patterns
上下文映射模式

1. Partnership (合作关系)
   ┌─────────┐ ←──mutual dependency──→ ┌─────────┐
   │Context A│      相互依赖           │Context B│
   └─────────┘                         └─────────┘

2. Shared Kernel (共享内核)
   ┌─────────┐                         ┌─────────┐
   │Context A│ ──shared model──        │Context B│
   └─────────┘   共享模型              └─────────┘
        └──────────┬──────────┘
                   ▼
            ┌──────────────┐
            │Shared Kernel │
            │  共享内核    │
            └──────────────┘

3. Customer-Supplier (客户-供应商)
   ┌─────────┐                         ┌─────────┐
   │Upstream │ ────provides API───→    │Downstream│
   │上游     │      提供API            │下游      │
   └─────────┘                         └─────────┘
   (Supplier)                          (Customer)
   (供应商)                            (客户)

4. Conformist (遵奉者)
   ┌─────────┐                         ┌─────────┐
   │External │ ────must conform───→    │Our      │
   │System   │      必须遵从           │Context  │
   │外部系统 │                         │我们的    │
   └─────────┘                         └─────────┘

5. Anti-Corruption Layer (防腐层)
   ┌─────────┐     ┌─────┐             ┌─────────┐
   │Legacy   │────→│ ACL │────→        │New      │
   │System   │     │防腐层│            │Context  │
   │遗留系统 │     └─────┘             │新上下文 │
   └─────────┘                         └─────────┘

6. Open Host Service (开放主机服务)
   ┌─────────┐                         ┌─────────┐
   │Context  │ ←──published API───     │Multiple │
   │with OHS │      发布的API          │Clients  │
   │开放主机 │                         │多个客户 │
   └─────────┘                         └─────────┘

7. Published Language (发布语言)
   ┌─────────┐                         ┌─────────┐
   │Context A│ ←──standard format──→   │Context B│
   └─────────┘      标准格式           └─────────┘
                (e.g., JSON, XML, Protocol Buffers)
                (例如: JSON、XML、Protocol Buffers)

8. Separate Ways (各行其道)
   ┌─────────┐                         ┌─────────┐
   │Context A│      no integration     │Context B│
   └─────────┘        无集成           └─────────┘
```

**Real-World Example: Financial Services**

**真实世界示例: 金融服务**

```
Financial Institution Context Map
金融机构上下文映射

┌──────────────────────────────────────────────────────────┐
│                                                          │
│  ┌────────────┐        Partnership        ┌───────────┐ │
│  │  Trading   │ ←──────────────────────→  │   Risk    │ │
│  │  Context   │        合作关系           │  Management│ │
│  │  交易上下文│                           │风险管理   │ │
│  └────────────┘                           └───────────┘ │
│       │                                         │        │
│       │ Customer-Supplier                       │        │
│       │ 客户-供应商                              │        │
│       ▼                                         ▼        │
│  ┌────────────┐                           ┌───────────┐ │
│  │ Settlement │                           │ Regulatory│ │
│  │  Context   │                           │ Reporting │ │
│  │  结算上下文│                           │监管报告   │ │
│  └────────────┘                           └───────────┘ │
│       │                                                  │
│       │ Anti-Corruption Layer                           │
│       │ 防腐层                                          │
│       ▼                                                  │
│  ┌────────────┐                                         │
│  │  Legacy    │                                         │
│  │  Accounting│                                         │
│  │  System    │                                         │
│  │遗留会计系统│                                         │
│  └────────────┘                                         │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

#### 2.1.3 Ubiquitous Language | 通用语言

**Definition**: A common, rigorous language shared by developers and domain experts, used in code, conversations, and documentation.

**定义**: 开发人员和领域专家共享的通用、严谨的语言,用于代码、对话和文档。

**Example: Healthcare Domain**

**示例: 医疗保健领域**

```
Healthcare Ubiquitous Language
医疗保健通用语言

❌ Wrong (Generic Terms)        ✅ Right (Domain Terms)
   错误(通用术语)                  正确(领域术语)

Person                          Patient (患者)
Meeting                         Appointment (预约)
Item                            Medication (药物)
Record                          Clinical Note (临床笔记)
Action                          Treatment (治疗)
Event                           Medical Procedure (医疗程序)
Status                          Patient Condition (患者状况)
Document                        Medical Record (病历)

Example in Code:
代码示例:

// ❌ Generic
public class Person {
    public string Name { get; set; }
    public List<Meeting> Meetings { get; set; }
}

// ✅ Domain-Specific
public class Patient {
    public PatientId Id { get; private set; }
    public PatientName Name { get; private set; }
    public MedicalRecordNumber MRN { get; private set; }
    
    private List<Appointment> _appointments;
    
    public void ScheduleAppointment(
        Physician physician, 
        DateTime scheduledTime, 
        AppointmentType type)
    {
        // Domain logic with ubiquitous language
        // 使用通用语言的领域逻辑
    }
}
```

**Building Ubiquitous Language:**

**构建通用语言:**

1. **Event Storming Sessions** - Collaborative discovery with domain experts
   - **事件风暴会议** - 与领域专家协作发现

2. **Glossary** - Document terms and definitions
   - **词汇表** - 记录术语和定义

3. **Code Reflects Language** - Class and method names use domain terms
   - **代码反映语言** - 类和方法名使用领域术语

4. **Continuous Refinement** - Language evolves with understanding
   - **持续精炼** - 语言随理解演进

5. **Avoid Translation** - Same terms in conversations and code
   - **避免翻译** - 对话和代码中使用相同术语

### 2.2 Tactical Design | 战术设计

#### 2.2.1 Building Blocks | 构建块

**DDD Tactical Patterns:**

**DDD战术模式:**

```
Domain Model Building Blocks
领域模型构建块

┌─────────────────────────────────────────────────────────┐
│                  Aggregate                              │
│                  聚合                                   │
│  ┌────────────────────────────────────────────────┐    │
│  │         Aggregate Root (Entity)                │    │
│  │         聚合根(实体)                           │    │
│  │  ┌──────────────────────────────────────┐     │    │
│  │  │  - Identity (唯一标识)               │     │    │
│  │  │  - Domain Logic (领域逻辑)           │     │    │
│  │  │  - Invariants (不变量)               │     │    │
│  │  └──────────────────────────────────────┘     │    │
│  │           │                                    │    │
│  │           │ contains (包含)                    │    │
│  │           ▼                                    │    │
│  │  ┌──────────────────┐  ┌──────────────────┐  │    │
│  │  │  Entity          │  │  Value Object    │  │    │
│  │  │  实体            │  │  值对象          │  │    │
│  │  │  - Has Identity  │  │  - Immutable     │  │    │
│  │  │    有标识        │  │    不可变        │  │    │
│  │  │  - Mutable       │  │  - No Identity   │  │    │
│  │  │    可变          │  │    无标识        │  │    │
│  │  └──────────────────┘  └──────────────────┘  │    │
│  └────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
         │
         │ emits (发出)
         ▼
┌─────────────────────────────────────────────────────────┐
│              Domain Events                              │
│              领域事件                                   │
│  - OrderPlaced (订单已下)                              │
│  - PaymentReceived (收到付款)                          │
│  - ProductShipped (产品已发货)                         │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│         Domain Services                                 │
│         领域服务                                        │
│  - Operations that don't belong to any entity           │
│    不属于任何实体的操作                                │
│  - Coordinate multiple aggregates                       │
│    协调多个聚合                                        │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│         Repositories                                    │
│         仓储                                            │
│  - Persistence abstraction                              │
│    持久化抽象                                          │
│  - Collection-like interface                            │
│    类似集合的接口                                      │
└─────────────────────────────────────────────────────────┘
```

#### 2.2.2 Entities vs. Value Objects | 实体与值对象

**Comparison:**

**对比:**

| Aspect 方面        | Entity 实体                  | Value Object 值对象       |
| ------------------ | ---------------------------- | ------------------------- |
| Identity 标识      | Has unique ID 有唯一ID       | No identity 无标识        |
| Equality 相等性    | By ID 通过ID                 | By value 通过值           |
| Mutability 可变性  | Mutable 可变                 | Immutable 不可变          |
| Lifecycle 生命周期 | Tracked over time 随时间跟踪 | Replaceable 可替换        |
| Example 示例       | Customer, Order 客户、订单   | Address, Money 地址、金额 |

**Code Example: Order Aggregate**

**代码示例: 订单聚合**

```csharp
// Entity: Order (Aggregate Root)
// 实体: 订单(聚合根)
public class Order
{
    public OrderId Id { get; private set; } // Identity 标识
    public CustomerId CustomerId { get; private set; }
    private List<OrderLine> _orderLines = new List<OrderLine>();
    public OrderStatus Status { get; private set; }
    public Money TotalAmount { get; private set; } // Value Object 值对象
    
    // Aggregate invariant: Total must be sum of line items
    // 聚合不变量: 总额必须是订单项的总和
    public void AddOrderLine(Product product, Quantity quantity)
    {
        var orderLine = new OrderLine(product, quantity);
        _orderLines.Add(orderLine);
        RecalculateTotal(); // Maintain invariant 维护不变量
    }
    
    // Domain logic: Business rule enforcement
    // 领域逻辑: 业务规则执行
    public void Submit()
    {
        if (_orderLines.Count == 0)
            throw new DomainException("Cannot submit empty order");
            
        if (Status != OrderStatus.Draft)
            throw new DomainException("Only draft orders can be submitted");
            
        Status = OrderStatus.Submitted;
        
        // Emit domain event 发出领域事件
        AddDomainEvent(new OrderSubmittedEvent(this.Id, DateTime.UtcNow));
    }
    
    private void RecalculateTotal()
    {
        TotalAmount = new Money(
            _orderLines.Sum(line => line.LineTotal.Amount),
            Currency.USD
        );
    }
}

// Value Object: Money
// 值对象: 金额
public class Money : IEquatable<Money>
{
    public decimal Amount { get; }
    public Currency Currency { get; }
    
    public Money(decimal amount, Currency currency)
    {
        if (amount < 0)
            throw new ArgumentException("Amount cannot be negative");
            
        Amount = amount;
        Currency = currency;
    }
    
    // Immutable: operations return new instances
    // 不可变: 操作返回新实例
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Cannot add different currencies");
            
        return new Money(Amount + other.Amount, Currency);
    }
    
    // Equality by value 通过值判断相等
    public bool Equals(Money other)
    {
        if (other is null) return false;
        return Amount == other.Amount && Currency == other.Currency;
    }
    
    public override int GetHashCode()
    {
        return HashCode.Combine(Amount, Currency);
    }
}

// Value Object: Address
// 值对象: 地址
public record Address(
    string Street,
    string City,
    string State,
    string ZipCode,
    string Country
)
{
    // Records in C# 9+ are immutable by default
    // C# 9+中的记录默认不可变
    
    public bool IsInSameCity(Address other)
    {
        return City == other.City && State == other.State;
    }
}
```

#### 2.2.3 Aggregates and Consistency Boundaries | 聚合和一致性边界

**Aggregate Design Principles:**

**聚合设计原则:**

1. **Protect Business Invariants** - Aggregates enforce consistency rules
   - **保护业务不变量** - 聚合执行一致性规则

2. **Small Aggregates** - Design aggregates as small as possible
   - **小聚合** - 将聚合设计得尽可能小

3. **Reference by ID** - Use IDs to reference other aggregates
   - **通过ID引用** - 使用ID引用其他聚合

4. **Eventual Consistency Between Aggregates** - Use domain events
   - **聚合间最终一致性** - 使用领域事件

5. **One Transaction = One Aggregate** - Transaction boundary
   - **一个事务 = 一个聚合** - 事务边界

**Example: E-commerce Aggregates**

**示例: 电子商务聚合**

```
E-commerce Aggregate Design
电子商务聚合设计

┌───────────────────────────────────────────────────────────┐
│  Order Aggregate (订单聚合)                              │
│  ┌─────────────────────────────────────────────────┐     │
│  │  Order (Aggregate Root)                         │     │
│  │  订单(聚合根)                                   │     │
│  │  - OrderId                                      │     │
│  │  - CustomerId (Reference! 引用!)                │     │
│  │  - OrderStatus                                  │     │
│  │  - TotalAmount                                  │     │
│  │                                                 │     │
│  │  Invariant: Total = Sum of line items          │     │
│  │  不变量: 总额 = 订单项总和                      │     │
│  └─────────────────────────────────────────────────┘     │
│         │ contains (包含)                               │
│         ▼                                               │
│  ┌─────────────────────────────────────────────────┐     │
│  │  OrderLine (Entity within aggregate)            │     │
│  │  订单项(聚合内实体)                             │     │
│  │  - ProductId (Reference! 引用!)                 │     │
│  │  - Quantity                                     │     │
│  │  - UnitPrice                                    │     │
│  │  - LineTotal                                    │     │
│  └─────────────────────────────────────────────────┘     │
└───────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────┐
│  Product Aggregate (产品聚合)                            │
│  ┌─────────────────────────────────────────────────┐     │
│  │  Product (Aggregate Root)                       │     │
│  │  产品(聚合根)                                   │     │
│  │  - ProductId                                    │     │
│  │  - Name, Description                            │     │
│  │  - Price                                        │     │
│  │  - CategoryId (Reference! 引用!)                │     │
│  └─────────────────────────────────────────────────┘     │
└───────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────┐
│  Inventory Aggregate (库存聚合)                          │
│  ┌─────────────────────────────────────────────────┐     │
│  │  Inventory (Aggregate Root)                     │     │
│  │  库存(聚合根)                                   │     │
│  │  - ProductId                                    │     │
│  │  - QuantityOnHand                               │     │
│  │  - ReservedQuantity                             │     │
│  │                                                 │     │
│  │  Invariant: Reserved <= OnHand                  │     │
│  │  不变量: 预留 <= 现有                           │     │
│  └─────────────────────────────────────────────────┘     │
└───────────────────────────────────────────────────────────┘

Transaction Boundaries:
事务边界:

Transaction 1: Create Order
事务1: 创建订单
┌─────────────────────┐
│  Order Aggregate    │  ← Single transaction
│  订单聚合           │    单个事务
└─────────────────────┘

Transaction 2: Reserve Inventory (separate!)
事务2: 预留库存(分离!)
┌─────────────────────┐
│ Inventory Aggregate │  ← Separate transaction
│ 库存聚合            │    单独事务
└─────────────────────┘

Coordination: Domain Events (eventual consistency)
协调: 领域事件(最终一致性)
OrderCreated Event → Reserve Inventory
订单创建事件 → 预留库存
```

**Aggregate Size Guidelines:**

**聚合大小指南:**

```
❌ Too Large (Over-Aggregation)
   过大(过度聚合)

Customer Aggregate contains:
客户聚合包含:
- Customer (root)
- All Orders (hundreds!)
- All Payments
- All Addresses
- All Preferences

Problem: Large transaction scope, performance issues
问题: 大事务范围,性能问题

✅ Right-Sized Aggregates
   适当大小的聚合

Customer Aggregate:
客户聚合:
- Customer (root)
- Primary contact info
- Customer status

Order Aggregate:
订单聚合:
- Order (root)
- Order lines (limited)
- Order status

Payment Aggregate:
支付聚合:
- Payment (root)
- Payment method
- Transaction status

Coordination: Domain events
协调: 领域事件
```

#### 2.2.4 Domain Events | 领域事件

**Definition**: Domain events represent something significant that happened in the domain.

**定义**: 领域事件表示领域中发生的重要事情。

**Characteristics:**

**特征:**

- **Past Tense** - Named with past-tense verbs (OrderPlaced, PaymentReceived)
- **过去时** - 用过去时动词命名(订单已下、收到付款)

- **Immutable** - Once created, cannot be changed
- **不可变** - 一旦创建,不能更改

- **Rich Information** - Contains relevant data about what happened
- **丰富信息** - 包含关于发生了什么的相关数据

**Example: Order Domain Events**

**示例: 订单领域事件**

```csharp
// Domain Event Base Class
// 领域事件基类
public abstract class DomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredOn { get; } = DateTime.UtcNow;
}

// Specific Domain Events
// 具体领域事件

public class OrderPlacedEvent : DomainEvent
{
    public OrderId OrderId { get; }
    public CustomerId CustomerId { get; }
    public Money TotalAmount { get; }
    public List<OrderLineData> OrderLines { get; }
    
    public OrderPlacedEvent(
        OrderId orderId, 
        CustomerId customerId, 
        Money totalAmount,
        List<OrderLineData> orderLines)
    {
        OrderId = orderId;
        CustomerId = customerId;
        TotalAmount = totalAmount;
        OrderLines = orderLines;
    }
}

public class OrderCancelledEvent : DomainEvent
{
    public OrderId OrderId { get; }
    public string Reason { get; }
    
    public OrderCancelledEvent(OrderId orderId, string reason)
    {
        OrderId = orderId;
        Reason = reason;
    }
}

public class PaymentReceivedEvent : DomainEvent
{
    public OrderId OrderId { get; }
    public Money Amount { get; }
    public PaymentMethod PaymentMethod { get; }
    
    public PaymentReceivedEvent(
        OrderId orderId, 
        Money amount, 
        PaymentMethod paymentMethod)
    {
        OrderId = orderId;
        Amount = amount;
        PaymentMethod = paymentMethod;
    }
}
```

**Event Flow in Bounded Contexts:**

**限界上下文中的事件流:**

```
Event-Driven Integration Between Bounded Contexts
限界上下文之间的事件驱动集成

┌─────────────────────────────────────────────────────────────┐
│  Order Context (订单上下文)                                 │
│                                                             │
│  1. Customer places order                                   │
│     客户下订单                                              │
│     ┌──────────────┐                                        │
│     │   Order      │                                        │
│     │   Aggregate  │                                        │
│     │   订单聚合   │                                        │
│     └──────────────┘                                        │
│            │                                                │
│            │ emits 发出                                     │
│            ▼                                                │
│     ┌──────────────────────────┐                            │
│     │  OrderPlacedEvent        │                            │
│     │  订单已下事件            │                            │
│     └──────────────────────────┘                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                    │
                    │ published to event bus
                    │ 发布到事件总线
                    │
        ┌───────────┴───────────┬───────────────────┐
        │                       │                   │
        ▼                       ▼                   ▼
┌───────────────────┐  ┌──────────────────┐  ┌──────────────┐
│ Inventory Context │  │ Payment Context  │  │Notification  │
│ 库存上下文        │  │ 支付上下文       │  │Context       │
│                   │  │                  │  │通知上下文    │
│ 2. Reserve stock  │  │ 3. Charge payment│  │4. Send email │
│    预留库存       │  │    收取款项      │  │   发送邮件   │
│                   │  │                  │  │              │
│ ┌───────────────┐ │  │ ┌──────────────┐ │  │┌────────────┐│
│ │InventoryItem  │ │  │ │ Payment      │ │  ││Notification││
│ │ Aggregate     │ │  │ │ Aggregate    │ │  ││Service     ││
│ │库存项聚合     │ │  │ │ 支付聚合     │ │  ││通知服务    ││
│ └───────────────┘ │  │ └──────────────┘ │  │└────────────┘│
└───────────────────┘  └──────────────────┘  └──────────────┘

Eventual Consistency: Each context handles event independently
最终一致性: 每个上下文独立处理事件
```

**Event Handler Example:**

**事件处理器示例:**

```csharp
// Event Handler in Inventory Context
// 库存上下文中的事件处理器
public class OrderPlacedEventHandler : IHandleEvent<OrderPlacedEvent>
{
    private readonly IInventoryRepository _inventoryRepository;
    
    public OrderPlacedEventHandler(IInventoryRepository inventoryRepository)
    {
        _inventoryRepository = inventoryRepository;
    }
    
    public async Task Handle(OrderPlacedEvent domainEvent)
    {
        // React to event from another bounded context
        // 对来自另一个限界上下文的事件做出反应
        
        foreach (var orderLine in domainEvent.OrderLines)
        {
            var inventory = await _inventoryRepository
                .GetByProductId(orderLine.ProductId);
            
            if (inventory == null)
            {
                // Publish compensation event
                // 发布补偿事件
                await PublishEvent(new InventoryNotAvailableEvent(
                    domainEvent.OrderId, 
                    orderLine.ProductId));
                return;
            }
            
            // Reserve inventory
            // 预留库存
            inventory.Reserve(orderLine.Quantity, domainEvent.OrderId);
            
            await _inventoryRepository.Save(inventory);
        }
        
        // Publish success event
        // 发布成功事件
        await PublishEvent(new InventoryReservedEvent(domainEvent.OrderId));
    }
}
```

#### 2.2.5 Domain Services | 领域服务

**When to Use Domain Services:**

**何时使用领域服务:**

Use domain services when:
当以下情况时使用领域服务:

1. **Operation doesn't belong to any entity** - Crosses multiple aggregates
   - **操作不属于任何实体** - 跨多个聚合

2. **Stateless operation** - No state to maintain
   - **无状态操作** - 无需维护状态

3. **Coordinates multiple aggregates** - Orchestration logic
   - **协调多个聚合** - 编排逻辑

**Example: Money Transfer Domain Service**

**示例: 转账领域服务**

```csharp
// Domain Service: Transfer between accounts
// 领域服务: 账户间转账
public interface IMoneyTransferService
{
    Task<TransferResult> Transfer(
        AccountId fromAccountId,
        AccountId toAccountId,
        Money amount);
}

public class MoneyTransferService : IMoneyTransferService
{
    private readonly IAccountRepository _accountRepository;
    private readonly IEventPublisher _eventPublisher;
    
    public MoneyTransferService(
        IAccountRepository accountRepository,
        IEventPublisher eventPublisher)
    {
        _accountRepository = accountRepository;
        _eventPublisher = eventPublisher;
    }
    
    public async Task<TransferResult> Transfer(
        AccountId fromAccountId,
        AccountId toAccountId,
        Money amount)
    {
        // Coordinate two separate aggregates
        // 协调两个独立的聚合
        
        var fromAccount = await _accountRepository.GetById(fromAccountId);
        var toAccount = await _accountRepository.GetById(toAccountId);
        
        if (fromAccount == null || toAccount == null)
            return TransferResult.AccountNotFound();
        
        // Business logic that doesn't belong to either account
        // 不属于任一账户的业务逻辑
        if (!fromAccount.CanWithdraw(amount))
            return TransferResult.InsufficientFunds();
        
        // Modify both aggregates
        // 修改两个聚合
        fromAccount.Withdraw(amount);
        toAccount.Deposit(amount);
        
        // Save both (ideally in a transaction or saga)
        // 保存两者(理想情况下在事务或saga中)
        await _accountRepository.Save(fromAccount);
        await _accountRepository.Save(toAccount);
        
        // Publish domain event
        // 发布领域事件
        await _eventPublisher.Publish(new MoneyTransferredEvent(
            fromAccountId, toAccountId, amount, DateTime.UtcNow));
        
        return TransferResult.Success();
    }
}
```

**Domain Service vs. Application Service:**

**领域服务与应用服务:**

| Aspect 方面       | Domain Service 领域服务           | Application Service 应用服务          |
| ----------------- | --------------------------------- | ------------------------------------- |
| Contains 包含     | Domain logic 领域逻辑             | Orchestration 编排                    |
| Layer 层          | Domain layer 领域层               | Application layer 应用层              |
| Example 示例      | Money transfer logic 转账逻辑     | Handle HTTP request 处理HTTP请求      |
| Dependencies 依赖 | Other domain objects 其他领域对象 | Domain + infrastructure 领域+基础设施 |

#### 2.2.6 Repositories | 仓储

**Purpose**: Provide collection-like interface for aggregate persistence, hiding database details.

**目的**: 为聚合持久化提供类似集合的接口,隐藏数据库细节。

**Repository Pattern:**

**仓储模式:**

```csharp
// Repository Interface (in Domain Layer)
// 仓储接口(在领域层)
public interface IOrderRepository
{
    // Collection-like interface
    // 类似集合的接口
    Task<Order> GetById(OrderId id);
    Task<IEnumerable<Order>> GetByCustomerId(CustomerId customerId);
    Task Add(Order order);
    Task Update(Order order);
    Task Delete(OrderId id);
    
    // Query methods for business use cases
    // 业务用例的查询方法
    Task<IEnumerable<Order>> GetPendingOrders();
    Task<bool> ExistsByOrderNumber(string orderNumber);
}

// Repository Implementation (in Infrastructure Layer)
// 仓储实现(在基础设施层)
public class OrderRepository : IOrderRepository
{
    private readonly DbContext _dbContext;
    private readonly IEventPublisher _eventPublisher;
    
    public OrderRepository(
        DbContext dbContext,
        IEventPublisher eventPublisher)
    {
        _dbContext = dbContext;
        _eventPublisher = eventPublisher;
    }
    
    public async Task<Order> GetById(OrderId id)
    {
        // Load aggregate with all related entities
        // 加载聚合及所有相关实体
        return await _dbContext.Orders
            .Include(o => o.OrderLines)
            .FirstOrDefaultAsync(o => o.Id == id);
    }
    
    public async Task Add(Order order)
    {
        await _dbContext.Orders.AddAsync(order);
        await _dbContext.SaveChangesAsync();
        
        // Publish domain events after persistence
        // 持久化后发布领域事件
        await PublishDomainEvents(order);
    }
    
    private async Task PublishDomainEvents(Order order)
    {
        var events = order.DomainEvents;
        order.ClearDomainEvents();
        
        foreach (var domainEvent in events)
        {
            await _eventPublisher.Publish(domainEvent);
        }
    }
}
```

**Repository Guidelines:**

**仓储指南:**

✅ **Do:**
- One repository per aggregate root
  每个聚合根一个仓储
  
- Return fully loaded aggregates
  返回完全加载的聚合
  
- Hide persistence technology
  隐藏持久化技术
  
- Interface in domain layer, implementation in infrastructure
  接口在领域层,实现在基础设施层

❌ **Don't:**
- Repository for every entity
  为每个实体创建仓储
  
- Expose IQueryable directly
  直接暴露IQueryable
  
- Include infrastructure concerns in interface
  在接口中包含基础设施关注点
  
- Generic repository anti-pattern
  通用仓储反模式

---

## 3. Domain-Specific Architectural Patterns

### 3.1 Layered Architecture | 分层架构

**Classic Domain-Centric Layered Architecture:**

**经典以领域为中心的分层架构:**

```
┌─────────────────────────────────────────────────────────┐
│         Presentation Layer (表示层)                     │
│  - UI Components (UI组件)                              │
│  - Controllers/Presenters (控制器/展示器)               │
│  - View Models (视图模型)                              │
│                                                         │
│  Responsibility: User interaction                       │
│  职责: 用户交互                                        │
└─────────────────────────────────────────────────────────┘
                        ▼ depends on 依赖
┌─────────────────────────────────────────────────────────┐
│         Application Layer (应用层)                      │
│  - Application Services (应用服务)                      │
│  - DTOs (Data Transfer Objects)                        │
│  - Use Case Orchestration (用例编排)                    │
│  - Transaction Management (事务管理)                    │
│                                                         │
│  Responsibility: Orchestrate domain logic               │
│  职责: 编排领域逻辑                                    │
└─────────────────────────────────────────────────────────┘
                        ▼ depends on 依赖
┌─────────────────────────────────────────────────────────┐
│         Domain Layer (领域层) ★ CORE                    │
│  - Entities (实体)                                      │
│  - Value Objects (值对象)                               │
│  - Aggregates (聚合)                                    │
│  - Domain Services (领域服务)                           │
│  - Domain Events (领域事件)                             │
│  - Repository Interfaces (仓储接口)                     │
│                                                         │
│  Responsibility: Business logic and rules               │
│  职责: 业务逻辑和规则                                  │
└─────────────────────────────────────────────────────────┘
                        ▲ implements 实现
┌─────────────────────────────────────────────────────────┐
│         Infrastructure Layer (基础设施层)                │
│  - Repository Implementations (仓储实现)                │
│  - Database Access (数据库访问)                         │
│  - External Service Clients (外部服务客户端)            │
│  - Message Queue (消息队列)                             │
│  - Caching (缓存)                                       │
│                                                         │
│  Responsibility: Technical capabilities                 │
│  职责: 技术能力                                        │
└─────────────────────────────────────────────────────────┘

Dependency Rule: Layers depend only on layers below
依赖规则: 层仅依赖于下层
Domain layer has NO dependencies on outer layers
领域层对外层无依赖
```

### 3.2 Hexagonal Architecture (Ports and Adapters) | 六边形架构

**Concept**: Isolate domain logic from external concerns through ports (interfaces) and adapters (implementations).

**概念**: 通过端口(接口)和适配器(实现)将领域逻辑与外部关注点隔离。

**Structure:**

**结构:**

```
Hexagonal Architecture (Ports and Adapters)
六边形架构(端口和适配器)

                    External World 外部世界
                          │
         ┌────────────────┼────────────────┐
         │                │                │
         ▼                ▼                ▼
    ┌────────┐       ┌────────┐      ┌────────┐
    │REST API│       │  UI    │      │Message │
    │Adapter │       │ Adapter│      │Queue   │
    │REST API│       │UI适配器│      │Adapter │
    │适配器  │       │        │      │消息队列│
    └────────┘       └────────┘      │适配器  │
         │                │           └────────┘
         │                │                │
         │   Primary/Driving Adapters     │
         │   主要/驱动适配器              │
         └────────────────┼────────────────┘
                          │
                          ▼
                ┌──────────────────┐
                │  Primary Ports   │
                │  主要端口        │
                │  (Interfaces)    │
                │  (接口)          │
                └──────────────────┘
                          │
                          ▼
         ┌──────────────────────────────┐
         │                              │
         │     Domain Layer             │
         │     领域层 (Hexagon core)    │
         │                              │
         │  - Aggregates                │
         │  - Domain Services           │
         │  - Domain Events             │
         │  - Business Logic            │
         │    聚合/领域服务/领域事件     │
         │                              │
         └──────────────────────────────┘
                          │
                          ▼
                ┌──────────────────┐
                │ Secondary Ports  │
                │ 次要端口         │
                │  (Interfaces)    │
                │  (接口)          │
                └──────────────────┘
                          │
         ┌────────────────┼────────────────┐
         │                │                │
         ▼                ▼                ▼
    ┌────────┐       ┌────────┐      ┌────────┐
    │Database│       │Email   │      │Payment │
    │Adapter │       │Adapter │      │Gateway │
    │数据库  │       │邮件    │      │Adapter │
    │适配器  │       │适配器  │      │支付网关│
    └────────┘       └────────┘      │适配器  │
         │                │           └────────┘
         │                │                │
         │   Secondary/Driven Adapters    │
         │   次要/被驱动适配器            │
         └────────────────┼────────────────┘
                          │
                    External World 外部世界

Key Principle: Domain depends on Ports (interfaces), 
not Adapters (implementations)
关键原则: 领域依赖端口(接口),而非适配器(实现)
```

**Code Example:**

**代码示例:**

```csharp
// ============================================
// DOMAIN LAYER (HEXAGON CORE)
// 领域层(六边形核心)
// ============================================

// Domain Entity
// 领域实体
public class Order
{
    public OrderId Id { get; private set; }
    public List<OrderLine> Lines { get; private set; }
    public OrderStatus Status { get; private set; }
    
    public void Submit()
    {
        if (Lines.Count == 0)
            throw new DomainException("Cannot submit empty order");
            
        Status = OrderStatus.Submitted;
    }
}

// ============================================
// PORTS (INTERFACES IN DOMAIN)
// 端口(领域中的接口)
// ============================================

// Secondary Port: Repository
// 次要端口: 仓储
public interface IOrderRepository
{
    Task<Order> GetById(OrderId id);
    Task Save(Order order);
}

// Secondary Port: Email Service
// 次要端口: 邮件服务
public interface IEmailService
{
    Task SendOrderConfirmation(OrderId orderId, string customerEmail);
}

// Primary Port: Use Case
// 主要端口: 用例
public interface IPlaceOrderUseCase
{
    Task<OrderId> Execute(PlaceOrderCommand command);
}

// ============================================
// APPLICATION SERVICE (IN HEXAGON)
// 应用服务(在六边形内)
// ============================================

public class PlaceOrderUseCase : IPlaceOrderUseCase
{
    private readonly IOrderRepository _orderRepository;
    private readonly IEmailService _emailService;
    
    // Depends on ports, not adapters
    // 依赖端口,而非适配器
    public PlaceOrderUseCase(
        IOrderRepository orderRepository,
        IEmailService emailService)
    {
        _orderRepository = orderRepository;
        _emailService = emailService;
    }
    
    public async Task<OrderId> Execute(PlaceOrderCommand command)
    {
        // Domain logic
        // 领域逻辑
        var order = new Order(command.CustomerId, command.Items);
        order.Submit();
        
        // Use ports
        // 使用端口
        await _orderRepository.Save(order);
        await _emailService.SendOrderConfirmation(
            order.Id, 
            command.CustomerEmail);
        
        return order.Id;
    }
}

// ============================================
// ADAPTERS (IMPLEMENTATIONS OUTSIDE HEXAGON)
// 适配器(六边形外的实现)
// ============================================

// Secondary Adapter: Database Repository
// 次要适配器: 数据库仓储
public class SqlOrderRepository : IOrderRepository
{
    private readonly DbContext _dbContext;
    
    public SqlOrderRepository(DbContext dbContext)
    {
        _dbContext = dbContext;
    }
    
    public async Task<Order> GetById(OrderId id)
    {
        // SQL implementation details
        // SQL实现细节
        return await _dbContext.Orders
            .FirstOrDefaultAsync(o => o.Id == id);
    }
    
    public async Task Save(Order order)
    {
        _dbContext.Orders.Update(order);
        await _dbContext.SaveChangesAsync();
    }
}

// Secondary Adapter: SMTP Email Service
// 次要适配器: SMTP邮件服务
public class SmtpEmailService : IEmailService
{
    private readonly SmtpClient _smtpClient;
    
    public SmtpEmailService(SmtpClient smtpClient)
    {
        _smtpClient = smtpClient;
    }
    
    public async Task SendOrderConfirmation(
        OrderId orderId, 
        string customerEmail)
    {
        // SMTP implementation details
        // SMTP实现细节
        var message = new MailMessage
        {
            To = { customerEmail },
            Subject = "Order Confirmation",
            Body = $"Your order {orderId} has been received."
        };
        
        await _smtpClient.SendMailAsync(message);
    }
}

// Primary Adapter: REST API Controller
// 主要适配器: REST API控制器
[ApiController]
[Route("api/orders")]
public class OrdersController : ControllerBase
{
    private readonly IPlaceOrderUseCase _placeOrderUseCase;
    
    public OrdersController(IPlaceOrderUseCase placeOrderUseCase)
    {
        _placeOrderUseCase = placeOrderUseCase;
    }
    
    [HttpPost]
    public async Task<ActionResult<OrderResponse>> PlaceOrder(
        [FromBody] PlaceOrderRequest request)
    {
        // Convert HTTP request to domain command
        // 将HTTP请求转换为领域命令
        var command = new PlaceOrderCommand(
            request.CustomerId,
            request.Items,
            request.CustomerEmail
        );
        
        // Invoke use case through port
        // 通过端口调用用例
        var orderId = await _placeOrderUseCase.Execute(command);
        
        return Ok(new OrderResponse { OrderId = orderId.Value });
    }
}
```

**Benefits of Hexagonal Architecture:**

**六边形架构的优势:**

✅ **Testability** - Easy to test domain logic with mock adapters
- **可测试性** - 易于用模拟适配器测试领域逻辑

✅ **Technology Independence** - Swap adapters without changing domain
- **技术独立性** - 在不更改领域的情况下交换适配器

✅ **Clear Boundaries** - Explicit separation of concerns
- **清晰边界** - 明确的关注点分离

✅ **Flexibility** - Multiple adapters for same port (e.g., SQL + NoSQL)
- **灵活性** - 同一端口的多个适配器(例如,SQL + NoSQL)

### 3.3 Clean Architecture | 整洁架构

**Concept**: Concentric layers with dependency pointing inward, domain at the center.

**概念**: 同心圆层,依赖指向内部,领域在中心。

**Structure:**

**结构:**

```
Clean Architecture (Concentric Circles)
整洁架构(同心圆)

┌───────────────────────────────────────────────────────┐
│  Frameworks & Drivers (最外层)                        │
│  框架和驱动器                                         │
│  - Web Framework (Web框架)                           │
│  - Database (数据库)                                 │
│  - UI (用户界面)                                     │
│  - External Interfaces (外部接口)                     │
│                                                       │
│  ┌─────────────────────────────────────────────────┐ │
│  │ Interface Adapters (接口适配器)                  │ │
│  │ - Controllers (控制器)                          │ │
│  │ - Gateways (网关)                               │ │
│  │ - Presenters (展示器)                           │ │
│  │                                                 │ │
│  │  ┌───────────────────────────────────────────┐ │ │
│  │  │ Application Business Rules (应用业务规则) │ │ │
│  │  │ - Use Cases (用例)                       │ │ │
│  │  │ - Application Services (应用服务)        │ │ │
│  │  │                                          │ │ │
│  │  │  ┌─────────────────────────────────────┐│ │ │
│  │  │  │ Enterprise Business Rules           ││ │ │
│  │  │  │ 企业业务规则 (CORE 核心)            ││ │ │
│  │  │  │                                     ││ │ │
│  │  │  │  - Entities (实体)                  ││ │ │
│  │  │  │  - Domain Logic (领域逻辑)          ││ │ │
│  │  │  │  - Domain Services (领域服务)       ││ │ │
│  │  │  │                                     ││ │ │
│  │  │  └─────────────────────────────────────┘│ │ │
│  │  │                                          │ │ │
│  │  └───────────────────────────────────────────┘ │ │
│  │                                                 │ │
│  └─────────────────────────────────────────────────┘ │
│                                                       │
└───────────────────────────────────────────────────────┘

Dependency Rule: Source code dependencies point INWARD
依赖规则: 源代码依赖指向内部

Inner layers know NOTHING about outer layers
内层对外层一无所知
```

**Dependency Inversion:**

**依赖反转:**

```
Traditional Dependency (Wrong)
传统依赖(错误)

┌───────────────┐
│ Use Case      │ ───→ ┌──────────────┐
│ 用例          │      │ Repository   │
└───────────────┘      │ (SQL)        │
                       │ 仓储(SQL)    │
                       └──────────────┘

Problem: High-level policy depends on low-level detail
问题: 高级策略依赖于低级细节

Clean Architecture (Correct)
整洁架构(正确)

┌───────────────┐      ┌──────────────┐
│ Use Case      │ ───→ │IRepository   │
│ 用例          │      │(Interface)   │
└───────────────┘      │(接口)        │
                       └──────────────┘
                              ▲
                              │ implements
                              │ 实现
                       ┌──────────────┐
                       │SqlRepository │
                       │(Detail)      │
                       │SQL仓储(细节) │
                       └──────────────┘

Solution: Both depend on abstraction (interface)
解决方案: 两者都依赖抽象(接口)
```

### 3.4 Onion Architecture | 洋葱架构

**Similar to Clean Architecture, explicit layering:**

**类似整洁架构,显式分层:**

```
Onion Architecture Layers
洋葱架构层

┌──────────────────────────────────────────────────┐
│  Infrastructure (基础设施)                        │
│  - ORM, Database                                 │
│  - File System                                   │
│  - External Services                             │
│                                                  │
│  ┌────────────────────────────────────────────┐ │
│  │ Application Services (应用服务)            │ │
│  │ - Use Case Orchestration                  │ │
│  │ - DTOs                                    │ │
│  │                                           │ │
│  │  ┌──────────────────────────────────────┐│ │
│  │  │ Domain Services (领域服务)           ││ │
│  │  │                                      ││ │
│  │  │  ┌────────────────────────────────┐ ││ │
│  │  │  │ Domain Model (领域模型)        │ ││ │
│  │  │  │ - Entities                    │ ││ │
│  │  │  │ - Value Objects               │ ││ │
│  │  │  │ - Aggregates                  │ ││ │
│  │  │  │   实体/值对象/聚合            │ ││ │
│  │  │  └────────────────────────────────┘ ││ │
│  │  │                                      ││ │
│  │  └──────────────────────────────────────┘│ │
│  │                                           │ │
│  └────────────────────────────────────────────┘ │
│                                                  │
└──────────────────────────────────────────────────┘

All dependencies point inward toward domain model
所有依赖指向内部的领域模型
```

### 3.5 CQRS (Command Query Responsibility Segregation) | 命令查询职责分离

**Concept**: Separate read and write models for better scalability and performance.

**概念**: 分离读写模型以获得更好的可扩展性和性能。

**Traditional vs. CQRS:**

**传统与CQRS:**

```
Traditional Architecture (单一模型)
传统架构

┌──────────────┐
│     UI       │
│   用户界面    │
└──────────────┘
       │
       ▼
┌──────────────┐
│  Single      │
│  Model       │  ← Same model for reads and writes
│  单一模型    │    读写使用相同模型
└──────────────┘
       │
       ▼
┌──────────────┐
│  Database    │
│  数据库      │
└──────────────┘

CQRS Architecture (分离模型)

┌──────────────────────────────────────────────┐
│              UI / Application                │
│              用户界面/应用程序                │
└──────────────────────────────────────────────┘
       │                            │
       │ Commands                   │ Queries
       │ 命令                        │ 查询
       ▼                            ▼
┌──────────────┐            ┌──────────────┐
│  Write Model │            │  Read Model  │
│  写模型      │            │  读模型      │
│              │            │              │
│ - Domain     │            │ - DTOs       │
│   Logic      │            │ - Denormalized│
│ - Aggregates │            │ - Optimized  │
│ - Events     │   sync     │   for queries│
│   领域逻辑    │ ────────→  │   为查询优化  │
└──────────────┘            └──────────────┘
       │                            │
       ▼                            ▼
┌──────────────┐            ┌──────────────┐
│ Write DB     │            │  Read DB     │
│ 写数据库     │            │  读数据库    │
│ (Normalized) │            │(Denormalized)│
│  (规范化)    │            │  (非规范化)  │
└──────────────┘            └──────────────┘
```

**Code Example:**

**代码示例:**

```csharp
// COMMAND SIDE (写端)
// ==================

// Command
public class CreateOrderCommand
{
    public Guid CustomerId { get; set; }
    public List<OrderItemDto> Items { get; set; }
}

// Command Handler
public class CreateOrderCommandHandler
{
    private readonly IOrderRepository _repository;
    private readonly IEventBus _eventBus;
    
    public async Task<OrderId> Handle(CreateOrderCommand command)
    {
        // Use rich domain model
        // 使用丰富的领域模型
        var order = new Order(
            OrderId.New(),
            new CustomerId(command.CustomerId),
            command.Items.Select(i => new OrderLine(...))
        );
        
        // Business logic
        // 业务逻辑
        order.Submit();
        
        // Save to write database
        // 保存到写数据库
        await _repository.Save(order);
        
        // Publish event for read model update
        // 发布事件以更新读模型
        await _eventBus.Publish(new OrderCreatedEvent(order));
        
        return order.Id;
    }
}

// QUERY SIDE (读端)
// ==================

// Query
public class GetOrderByIdQuery
{
    public Guid OrderId { get; set; }
}

// Read Model (DTO)
public class OrderDto
{
    public Guid Id { get; set; }
    public string CustomerName { get; set; }
    public decimal TotalAmount { get; set; }
    public List<OrderLineDto> Items { get; set; }
    public string Status { get; set; }
    // Denormalized, optimized for display
    // 非规范化,为显示优化
}

// Query Handler
public class GetOrderByIdQueryHandler
{
    private readonly IReadOnlyRepository<OrderDto> _readRepository;
    
    public async Task<OrderDto> Handle(GetOrderByIdQuery query)
    {
        // Direct read from optimized read model
        // 直接从优化的读模型读取
        return await _readRepository.GetById(query.OrderId);
    }
}

// Read Model Updater (listens to events)
// 读模型更新器(监听事件)
public class OrderCreatedEventHandler
{
    private readonly IReadModelDatabase _readDb;
    
    public async Task Handle(OrderCreatedEvent @event)
    {
        // Update denormalized read model
        // 更新非规范化读模型
        var orderDto = new OrderDto
        {
            Id = @event.OrderId,
            CustomerName = await GetCustomerName(@event.CustomerId),
            TotalAmount = @event.TotalAmount,
            Items = @event.Items,
            Status = @event.Status
        };
        
        await _readDb.Upsert(orderDto);
    }
}
```

**When to Use CQRS:**

**何时使用CQRS:**

✅ **Use CQRS when:**
- High read/write ratio (many more reads than writes)
  读写比率高(读远多于写)
  
- Complex queries that don't fit domain model
  不适合领域模型的复杂查询
  
- Different scalability needs for reads vs. writes
  读写的可扩展性需求不同
  
- Need for eventual consistency is acceptable
  可接受最终一致性

❌ **Don't use CQRS when:**
- Simple CRUD applications
  简单CRUD应用程序
  
- Strong consistency required everywhere
  到处都需要强一致性
  
- Small team with limited expertise
  小团队且专业知识有限
  
- Similar read and write patterns
  相似的读写模式

---

## 4. Industry-Specific Architectures

### 4.1 E-commerce Architecture | 电子商务架构

**Bounded Contexts:**

**限界上下文:**

```
E-commerce System Architecture
电子商务系统架构

┌────────────────────────────────────────────────────────┐
│                                                        │
│  ┌──────────────┐      ┌──────────────┐              │
│  │   Catalog    │      │   Shopping   │              │
│  │   Context    │      │     Cart     │              │
│  │   目录上下文  │      │   Context    │              │
│  │              │      │  购物车上下文 │              │
│  │ - Product    │      │ - Cart       │              │
│  │ - Category   │      │ - CartItem   │              │
│  │ - Search     │      │ - Session    │              │
│  └──────────────┘      └──────────────┘              │
│                              │                        │
│                              │                        │
│  ┌──────────────┐      ┌──────────────┐              │
│  │   Order      │      │  Payment     │              │
│  │   Context    │      │  Context     │              │
│  │  订单上下文   │      │  支付上下文   │              │
│  │              │      │              │              │
│  │ - Order      │      │ - Payment    │              │
│  │ - OrderLine  │      │ - Transaction│              │
│  │ - Customer   │      │ - Gateway    │              │
│  └──────────────┘      └──────────────┘              │
│        │                     │                        │
│        │                     │                        │
│  ┌──────────────┐      ┌──────────────┐              │
│  │  Inventory   │      │  Shipping    │              │
│  │   Context    │      │   Context    │              │
│  │  库存上下文   │      │  发货上下文   │              │
│  │              │      │              │              │
│  │ - Stock      │      │ - Shipment   │              │
│  │ - Warehouse  │      │ - Carrier    │              │
│  │ - Reservation│      │ - Tracking   │              │
│  └──────────────┘      └──────────────┘              │
│                                                        │
└────────────────────────────────────────────────────────┘

Key Patterns:
关键模式:
- Saga for order fulfillment (订单履行的Saga)
- Event sourcing for inventory (库存的事件溯源)
- CQRS for product catalog (产品目录的CQRS)
```

### 4.2 Financial Services Architecture | 金融服务架构

**Trading System Example:**

**交易系统示例:**

```
Financial Trading System
金融交易系统

┌────────────────────────────────────────────────────────┐
│                                                        │
│  ┌──────────────┐      ┌──────────────┐              │
│  │   Trading    │      │     Risk     │              │
│  │   Context    │ ←→   │  Management  │              │
│  │  交易上下文   │      │   Context    │              │
│  │              │      │  风险管理上下文│             │
│  │ - Order      │      │ - Portfolio  │              │
│  │ - Trade      │      │ - Exposure   │              │
│  │ - Position   │      │ - Limit      │              │
│  └──────────────┘      └──────────────┘              │
│        │                     │                        │
│        │                     │                        │
│  ┌──────────────┐      ┌──────────────┐              │
│  │  Settlement  │      │  Compliance  │              │
│  │   Context    │      │   Context    │              │
│  │  结算上下文   │      │  合规上下文   │              │
│  │              │      │              │              │
│  │ - Payment    │      │ - Report     │              │
│  │ - Clearing   │      │ - Audit      │              │
│  └──────────────┘      └──────────────┘              │
│                                                        │
└────────────────────────────────────────────────────────┘

Key Requirements:
关键要求:
- Low latency (< 1ms) (低延迟 < 1毫秒)
- Audit trail (complete history) (审计跟踪(完整历史))
- Regulatory compliance (监管合规)
- High availability (99.999%) (高可用性 99.999%)
```

### 4.3 Healthcare Architecture | 医疗保健架构

**Electronic Health Record (EHR) System:**

**电子健康记录(EHR)系统:**

```
Healthcare EHR System
医疗保健EHR系统

┌────────────────────────────────────────────────────────┐
│                                                        │
│  ┌──────────────┐      ┌──────────────┐              │
│  │   Patient    │      │  Appointment │              │
│  │   Context    │      │   Context    │              │
│  │  患者上下文   │      │  预约上下文   │              │
│  │              │      │              │              │
│  │ - Patient    │      │ - Appointment│              │
│  │ - MRN        │      │ - Schedule   │              │
│  │ - Demographics│     │ - Provider   │              │
│  └──────────────┘      └──────────────┘              │
│                              │                        │
│  ┌──────────────┐      ┌──────────────┐              │
│  │   Clinical   │      │   Billing    │              │
│  │   Context    │      │   Context    │              │
│  │  临床上下文   │      │  计费上下文   │              │
│  │              │      │              │              │
│  │ - Encounter  │      │ - Claim      │              │
│  │ - Diagnosis  │      │ - Insurance  │              │
│  │ - Medication │      │ - Payment    │              │
│  └──────────────┘      └──────────────┘              │
│                                                        │
└────────────────────────────────────────────────────────┘

Compliance:
合规性:
- HIPAA privacy and security (HIPAA隐私和安全)
- HL7/FHIR interoperability (HL7/FHIR互操作性)
- Audit logging (审计日志)
```

---

## 5. Domain Modeling Techniques

### 5.1 Event Storming | 事件风暴

**Process:**

**流程:**

```
Event Storming Workshop
事件风暴研讨会

Step 1: Domain Events (橙色便签)
步骤1: 领域事件
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│Order Placed │  │Payment      │  │Product      │
│订单已下     │  │Received     │  │Shipped      │
│             │  │收到付款     │  │产品已发货   │
└─────────────┘  └─────────────┘  └─────────────┘

Step 2: Commands (蓝色便签)
步骤2: 命令
┌─────────────┐  ┌─────────────┐
│Place Order  │  │Make Payment │
│下订单       │  │进行支付     │
└─────────────┘  └─────────────┘
       │                │
       ▼                ▼
┌─────────────┐  ┌─────────────┐
│Order Placed │  │Payment      │
│订单已下     │  │Received     │
└─────────────┘  └─────────────┘

Step 3: Aggregates (黄色便签)
步骤3: 聚合
┌─────────────┐
│   Order     │ ← Handles commands, emits events
│   订单      │   处理命令,发出事件
└─────────────┘

Step 4: Bounded Contexts (边界)
步骤4: 限界上下文
┌───────────────────────────────┐
│  Order Management Context     │
│  订单管理上下文               │
│  ┌─────┐  ┌──────┐  ┌──────┐ │
│  │Order│  │Payment│ │Product│ │
│  └─────┘  └──────┘  └──────┘ │
└───────────────────────────────┘
```

**Benefits:**

**优势:**

✅ **Shared Understanding** - Business and tech align
- **共同理解** - 业务和技术对齐

✅ **Identify Bounded Contexts** - Natural boundaries emerge
- **识别限界上下文** - 自然边界浮现

✅ **Discover Domain Events** - What happens in the domain
- **发现领域事件** - 领域中发生了什么

✅ **Fast Feedback** - Iterate quickly
- **快速反馈** - 快速迭代

### 5.2 Domain Model Canvas | 领域模型画布

**Template:**

**模板:**

```
Domain Model Canvas
领域模型画布

┌──────────────────────────────────────────────────┐
│ Bounded Context: Order Management               │
│ 限界上下文: 订单管理                             │
├──────────────────────────────────────────────────┤
│                                                  │
│ Ubiquitous Language:                             │
│ 通用语言:                                        │
│ - Order, OrderLine, Customer, Product            │
│ - Submit, Cancel, Fulfill                        │
│                                                  │
├──────────────────────────────────────────────────┤
│ Aggregates:                                      │
│ 聚合:                                            │
│ - Order (root: OrderId)                          │
│   - OrderLines (entities)                        │
│   - TotalAmount (value object)                   │
│                                                  │
├──────────────────────────────────────────────────┤
│ Domain Events:                                   │
│ 领域事件:                                        │
│ - OrderPlaced                                    │
│ - OrderCancelled                                 │
│ - OrderFulfilled                                 │
│                                                  │
├──────────────────────────────────────────────────┤
│ Business Rules:                                  │
│ 业务规则:                                        │
│ - Order total must equal sum of line items       │
│ - Cannot cancel fulfilled orders                 │
│ - Minimum order amount: $10                      │
│                                                  │
├──────────────────────────────────────────────────┤
│ External Dependencies:                           │
│ 外部依赖:                                        │
│ - Payment Service (支付服务)                     │
│ - Inventory Service (库存服务)                   │
│ - Notification Service (通知服务)                │
│                                                  │
└──────────────────────────────────────────────────┘
```

---

## 6. Best Practices

### 6.1 General Principles | 一般原则

1. **Start with Strategic Design** - Bounded contexts before code
   - **从战略设计开始** - 编码前先确定限界上下文

2. **Ubiquitous Language Everywhere** - Code should read like business
   - **到处使用通用语言** - 代码应该像业务那样可读

3. **Small Aggregates** - Keep them focused and cohesive
   - **小聚合** - 保持专注和内聚

4. **Event-Driven Integration** - Loose coupling between contexts
   - **事件驱动集成** - 上下文间松耦合

5. **Explicit Boundaries** - Clear context boundaries and APIs
   - **显式边界** - 清晰的上下文边界和API

6. **Domain First, Infrastructure Last** - Focus on business logic
   - **领域优先,基础设施最后** - 关注业务逻辑

7. **Iterative Refinement** - Architecture evolves with understanding
   - **迭代精炼** - 架构随理解演进

8. **Test Domain Logic** - Unit test aggregates and domain services
   - **测试领域逻辑** - 单元测试聚合和领域服务

### 6.2 Architecture Decision Guidelines | 架构决策指南

**Decision Matrix:**

**决策矩阵:**

| Factor 因素                        | Monolith 单体    | Microservices 微服务 | Serverless 无服务器 |
| ---------------------------------- | ---------------- | -------------------- | ------------------- |
| Team Size 团队规模                 | Small 小         | Large 大             | Variable 可变       |
| Domain Complexity 领域复杂性       | Low-Medium 低-中 | High 高              | Low 低              |
| Scalability Needs 可扩展性需求     | Moderate 适度    | High 高              | Variable 可变       |
| Deployment Frequency 部署频率      | Weekly 每周      | Daily 每天           | Continuous 持续     |
| Organizational Maturity 组织成熟度 | Low 低           | High 高              | Medium 中           |

---

## 7. Common Pitfalls

### 7.1 Anti-Patterns | 反模式

❌ **Anemic Domain Model**
- **贫血领域模型**

```csharp
// ❌ Anemic: Just getters/setters, no behavior
// 贫血: 只有getter/setter,没有行为
public class Order
{
    public Guid Id { get; set; }
    public List<OrderLine> Lines { get; set; }
    public decimal Total { get; set; }
}

public class OrderService
{
    public void SubmitOrder(Order order)
    {
        // Business logic in service, not domain
        // 业务逻辑在服务中,不在领域中
        order.Total = order.Lines.Sum(l => l.Total);
        order.Status = "Submitted";
    }
}

// ✅ Rich Domain Model
// 丰富领域模型
public class Order
{
    public OrderId Id { get; private set; }
    private List<OrderLine> _lines;
    public Money Total { get; private set; }
    
    // Business logic in domain entity
    // 业务逻辑在领域实体中
    public void Submit()
    {
        if (_lines.Count == 0)
            throw new DomainException("Cannot submit empty order");
            
        RecalculateTotal();
        Status = OrderStatus.Submitted;
        AddDomainEvent(new OrderSubmittedEvent(Id));
    }
}
```

❌ **Over-Engineering**
- **过度工程**

```
Don't use DDD for:
不要对以下场景使用DDD:
- Simple CRUD applications (简单CRUD应用)
- Small team prototypes (小团队原型)
- Well-understood domains (充分理解的领域)
- Short-lived projects (短期项目)
```

❌ **Large Aggregates**
- **大聚合**

Problem: Performance issues, transaction conflicts
问题: 性能问题,事务冲突

Solution: Break into smaller aggregates, use eventual consistency
解决方案: 拆分为更小的聚合,使用最终一致性

### 7.2 Common Mistakes | 常见错误

1. **Skipping Strategic Design** - Jumping to code too quickly
   - **跳过战略设计** - 过快开始编码

2. **Generic Language** - Not using domain terminology
   - **通用语言** - 不使用领域术语

3. **Ignoring Bounded Contexts** - One model for everything
   - **忽略限界上下文** - 所有事物一个模型

4. **CRUD Mindset** - Thinking in terms of database tables
   - **CRUD思维** - 以数据库表的方式思考

5. **Technology First** - Choosing frameworks before understanding domain
   - **技术优先** - 在理解领域前选择框架

---

## 8. Tools and Frameworks

### 8.1 DDD Libraries | DDD库

**.NET:**
- **MediatR** - CQRS pattern implementation
- **EventStore** - Event sourcing database
- **NEventStore** - Event sourcing framework
- **Aggregate.NET** - Aggregate management

**Java:**
- **Axon Framework** - CQRS and event sourcing
- **Spring Data** - Repository pattern
- **Eventuate** - Event-driven microservices

**Python:**
- **Eventsourcing** - Event sourcing library
- **Domain** - DDD building blocks

### 8.2 Modeling Tools | 建模工具

- **Context Mapper** - Bounded context modeling
  上下文映射器 - 限界上下文建模
  
- **EventStorming** - Collaborative modeling
  事件风暴 - 协作建模
  
- **PlantUML** - Architecture diagrams
  PlantUML - 架构图
  
- **C4 Model** - Software architecture visualization
  C4模型 - 软件架构可视化

---

## 9. Summary

**Domain-Specific Software Architecture** is a powerful approach for building complex business systems that:

**特定领域软件架构**是构建复杂业务系统的强大方法:

✅ **Aligns with Business** - Architecture reflects business structure
- **与业务对齐** - 架构反映业务结构

✅ **Manages Complexity** - Clear boundaries and responsibilities
- **管理复杂性** - 清晰的边界和职责

✅ **Enables Evolution** - Adapts to changing requirements
- **支持演进** - 适应不断变化的需求

✅ **Preserves Knowledge** - Domain expertise captured in code
- **保存知识** - 领域专业知识在代码中捕获

**Key Takeaways:**

**关键要点:**

1. Start with **Strategic Design** - bounded contexts and context mapping
   从**战略设计**开始 - 限界上下文和上下文映射

2. Use **Tactical Patterns** appropriately - aggregates, entities, value objects
   适当使用**战术模式** - 聚合、实体、值对象

3. Choose architecture patterns based on **domain characteristics**
   基于**领域特征**选择架构模式

4. **Event-Driven Integration** for bounded context collaboration
   限界上下文协作使用**事件驱动集成**

5. **Iterative refinement** as domain understanding deepens
   随领域理解加深**迭代精炼**

---

**Remember**: Domain-Driven Design is not a silver bullet. Use it for complex domains where the investment in modeling pays off through better maintainability and business alignment.

**记住**: 领域驱动设计不是银弹。将其用于复杂领域,在这些领域中,建模投资通过更好的可维护性和业务对齐得到回报。