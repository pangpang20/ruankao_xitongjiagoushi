# Design Patterns (设计模式)

## 1. Design Patterns Overview (设计模式概述)

### 1.1 Definition and Origin (定义和起源)

**Design Pattern** is a general, reusable solution to a commonly occurring problem within a given context in software design. It is a description or template for how to solve a problem that can be used in many different situations.

**设计模式**是在软件设计中针对特定上下文中常见问题的通用、可复用解决方案。它是一种描述或模板，说明如何解决可在多种不同情况下使用的问题。

**Historical Background (历史背景):**

The concept of design patterns was first introduced by Christopher Alexander in architecture (1977), and later adapted to software engineering by the "Gang of Four" (GoF): Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides in their seminal book "Design Patterns: Elements of Reusable Object-Oriented Software" (1994).

设计模式的概念最初由Christopher Alexander在建筑学中提出(1977年)，后来由"四人帮"(GoF)：Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides在其开创性著作《设计模式：可复用面向对象软件的基础》(1994年)中应用到软件工程领域。

**Key Characteristics (关键特征):**
- Proven solutions to recurring problems (经过验证的、针对重复出现问题的解决方案)
- Capture best practices and expert knowledge (捕获最佳实践和专家知识)
- Provide a common vocabulary for developers (为开发人员提供通用词汇)
- Not code, but design templates (不是代码，而是设计模板)
- Language and implementation independent (与语言和实现无关)

### 1.2 Pattern Elements (模式要素)

Every design pattern consists of four essential elements:

每个设计模式包含四个基本要素：

**1. Pattern Name (模式名称)**
- A handle to describe a design problem, its solutions, and consequences (描述设计问题、解决方案和后果的名称)
- Becomes part of design vocabulary (成为设计词汇的一部分)
- Example: "Singleton", "Observer", "Factory Method" (示例："单例"、"观察者"、"工厂方法")

**2. Problem (问题)**
- Describes when to apply the pattern (描述何时应用模式)
- Explains the problem and its context (解释问题及其上下文)
- May include conditions that must be met (可能包括必须满足的条件)

**3. Solution (解决方案)**
- Describes the elements that make up the design (描述构成设计的元素)
- Their relationships, responsibilities, and collaborations (它们的关系、职责和协作)
- Does not describe a concrete implementation (不描述具体实现)
- Provides an abstract description (提供抽象描述)

**4. Consequences (后果)**
- Results and trade-offs of applying the pattern (应用模式的结果和权衡)
- Addresses time and space trade-offs (涉及时间和空间权衡)
- Language and implementation issues (语言和实现问题)
- Impact on system's flexibility, extensibility, and portability (对系统灵活性、可扩展性和可移植性的影响)

### 1.3 Pattern Classification (模式分类体系)

Design patterns are classified into three main categories based on their purpose:

设计模式根据其目的分为三大类：

```
Design Patterns (23 GoF Patterns)
│
├── Creational Patterns (创建型模式) - 5 patterns
│   ├── Singleton (单例)
│   ├── Factory Method (工厂方法)
│   ├── Abstract Factory (抽象工厂)
│   ├── Builder (建造者)
│   └── Prototype (原型)
│
├── Structural Patterns (结构型模式) - 7 patterns
│   ├── Adapter (适配器)
│   ├── Bridge (桥接)
│   ├── Composite (组合)
│   ├── Decorator (装饰器)
│   ├── Facade (外观)
│   ├── Flyweight (享元)
│   └── Proxy (代理)
│
└── Behavioral Patterns (行为型模式) - 11 patterns
    ├── Chain of Responsibility (责任链)
    ├── Command (命令)
    ├── Interpreter (解释器)
    ├── Iterator (迭代器)
    ├── Mediator (中介者)
    ├── Memento (备忘录)
    ├── Observer (观察者)
    ├── State (状态)
    ├── Strategy (策略)
    ├── Template Method (模板方法)
    └── Visitor (访问者)
```

**Category Descriptions (类别描述):**

| Category   | Purpose                        | Focus                            | 类别   | 目的          | 关注点          |
| ---------- | ------------------------------ | -------------------------------- | ------ | ------------- | --------------- |
| Creational | Object creation mechanisms     | How objects are created          | 创建型 | 对象创建机制  | 如何创建对象    |
| Structural | Composition of classes/objects | How classes/objects are composed | 结构型 | 类/对象的组成 | 如何组成类/对象 |
| Behavioral | Interaction and responsibility | How classes/objects interact     | 行为型 | 交互和职责    | 类/对象如何交互 |

### 1.4 Patterns and Software Architecture (设计模式与软件架构的关系)

**Relationship (关系):**

```
Software Architecture (软件架构)
        ↓
Architectural Patterns (架构模式)
    - Layered, MVC, Microservices
        ↓
Design Patterns (设计模式)
    - GoF 23 Patterns
        ↓
Idioms (惯用法)
    - Language-specific patterns
```

**Key Differences (主要区别):**

| Aspect      | Architectural Patterns | Design Patterns       | 方面 | 架构模式    | 设计模式   |
| ----------- | ---------------------- | --------------------- | ---- | ----------- | ---------- |
| Scope       | System-level           | Component/class level | 范围 | 系统级      | 组件/类级  |
| Granularity | Coarse-grained         | Fine-grained          | 粒度 | 粗粒度      | 细粒度     |
| Impact      | Fundamental structure  | Local design          | 影响 | 基础结构    | 局部设计   |
| Examples    | MVC, Microservices     | Singleton, Factory    | 示例 | MVC、微服务 | 单例、工厂 |

### 1.5 Advantages and Limitations (优势和局限性)

**Advantages (优势):**

1. **Reusability (可复用性)**
   - Proven solutions that can be applied repeatedly (可重复应用的经过验证的解决方案)
   - Reduce reinventing the wheel (减少重复造轮子)

2. **Communication (沟通)**
   - Common vocabulary for developers (开发人员的通用词汇)
   - Facilitates team collaboration (促进团队协作)
   - Easier documentation and knowledge transfer (更容易的文档和知识转移)

3. **Maintainability (可维护性)**
   - Well-structured code (结构良好的代码)
   - Easier to understand and modify (更容易理解和修改)
   - Separation of concerns (关注点分离)

4. **Flexibility and Extensibility (灵活性和可扩展性)**
   - Support for changing requirements (支持变化的需求)
   - Open for extension, closed for modification (对扩展开放，对修改关闭)

5. **Quality Improvement (质量提升)**
   - Fewer defects through proven solutions (通过经过验证的解决方案减少缺陷)
   - Better software design (更好的软件设计)

**Limitations (局限性):**

1. **Complexity (复杂性)**
   - Can introduce unnecessary complexity if overused (过度使用会引入不必要的复杂性)
   - Learning curve for beginners (初学者的学习曲线)

2. **Performance Overhead (性能开销)**
   - Additional abstraction layers may impact performance (额外的抽象层可能影响性能)
   - More objects and indirection (更多对象和间接调用)

3. **Misapplication (误用)**
   - Using patterns when not needed (在不需要时使用模式)
   - "Pattern mania" - forcing patterns everywhere (模式狂热-到处强制使用模式)

4. **Context Dependency (上下文依赖)**
   - Not all patterns suit all situations (并非所有模式都适合所有情况)
   - Requires understanding of problem context (需要理解问题上下文)

**When NOT to Use Patterns (何时不使用模式):**
- Simple problems with simple solutions (简单问题有简单解决方案)
- When YAGNI (You Aren't Gonna Need It) applies (当YAGNI原则适用时)
- When pattern overhead exceeds benefits (当模式开销超过收益时)
- When the team lacks pattern knowledge (当团队缺乏模式知识时)

## 2. Object-Oriented Design Principles (面向对象设计原则)

### 2.1 SOLID Principles (SOLID原则)

The SOLID principles are five fundamental principles of object-oriented design that make software more understandable, flexible, and maintainable.

SOLID原则是面向对象设计的五个基本原则，使软件更易理解、更灵活、更易维护。

#### 2.1.1 Single Responsibility Principle (SRP) (单一职责原则)

**Definition (定义):**
A class should have only one reason to change. Every class should have only one responsibility.

一个类应该只有一个引起它变化的原因。每个类应该只有一个职责。

**Intent (意图):**
- High cohesion within classes (类内高内聚)
- Each class focuses on a single concern (每个类关注单一关注点)
- Easier to understand and maintain (更容易理解和维护)

**Example (示例):**

```java
// Bad: Multiple responsibilities (不好：多个职责)
class Employee {
    private String name;
    private double salary;
    
    public void calculatePay() { /* 计算工资 */ }
    public void save() { /* 保存到数据库 */ }
    public void generateReport() { /* 生成报告 */ }
}

// Good: Single responsibility (好：单一职责)
class Employee {
    private String name;
    private double salary;
    // 只包含员工数据
}

class PayrollCalculator {
    public double calculatePay(Employee employee) {
        // 计算工资逻辑
    }
}

class EmployeeRepository {
    public void save(Employee employee) {
        // 数据库保存逻辑
    }
}

class EmployeeReportGenerator {
    public Report generate(Employee employee) {
        // 报告生成逻辑
    }
}
```

**Benefits (收益):**
- Easier testing (更容易测试)
- Less coupling (更少耦合)
- Better organization (更好的组织)

#### 2.1.2 Open-Closed Principle (OCP) (开闭原则)

**Definition (定义):**
Software entities (classes, modules, functions) should be open for extension but closed for modification.

软件实体（类、模块、函数）应该对扩展开放，对修改关闭。

**Intent (意图):**
- Add new functionality without changing existing code (在不改变现有代码的情况下添加新功能)
- Minimize risk of breaking existing functionality (最小化破坏现有功能的风险)
- Achieved through abstraction and polymorphism (通过抽象和多态实现)

**Example (示例):**

```java
// Bad: Modification required for new shapes (不好：新形状需要修改)
class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Rectangle) {
            Rectangle rect = (Rectangle) shape;
            return rect.width * rect.height;
        } else if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return Math.PI * circle.radius * circle.radius;
        }
        // 添加新形状需要修改此方法
        return 0;
    }
}

// Good: Extension without modification (好：扩展而不修改)
interface Shape {
    double calculateArea();
}

class Rectangle implements Shape {
    private double width, height;
    
    public double calculateArea() {
        return width * height;
    }
}

class Circle implements Shape {
    private double radius;
    
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

// 添加新形状只需实现接口，无需修改现有代码
class Triangle implements Shape {
    private double base, height;
    
    public double calculateArea() {
        return 0.5 * base * height;
    }
}

class AreaCalculator {
    public double calculateArea(Shape shape) {
        return shape.calculateArea(); // 无需修改
    }
}
```

**Implementation Strategies (实现策略):**
- Use abstract classes and interfaces (使用抽象类和接口)
- Apply Strategy pattern (应用策略模式)
- Use dependency injection (使用依赖注入)

#### 2.1.3 Liskov Substitution Principle (LSP) (里氏替换原则)

**Definition (定义):**
Objects of a superclass should be replaceable with objects of its subclasses without breaking the application. Subtypes must be substitutable for their base types.

超类的对象应该可以被其子类的对象替换而不破坏应用程序。子类型必须能够替换其基类型。

**Intent (意图):**
- Ensure correct inheritance hierarchy (确保正确的继承层次结构)
- Subclasses should extend, not replace base class behavior (子类应该扩展而不是替换基类行为)
- Maintain behavioral consistency (保持行为一致性)

**Example (示例):**

```java
// Bad: Violates LSP (不好：违反LSP)
class Bird {
    public void fly() {
        System.out.println("Flying...");
    }
}

class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly!");
        // 企鹅不能飞，破坏了基类的契约
    }
}

// Good: Follows LSP (好：遵循LSP)
interface Bird {
    void eat();
    void sleep();
}

interface FlyingBird extends Bird {
    void fly();
}

class Sparrow implements FlyingBird {
    public void fly() {
        System.out.println("Sparrow flying...");
    }
    public void eat() { }
    public void sleep() { }
}

class Penguin implements Bird {
    // 企鹅不实现fly方法，因为它不是FlyingBird
    public void eat() { }
    public void sleep() { }
}
```

**LSP Rules (LSP规则):**
- Preconditions cannot be strengthened in subtype (子类型中前置条件不能加强)
- Postconditions cannot be weakened in subtype (子类型中后置条件不能削弱)
- Invariants must be preserved (不变量必须保持)
- History constraint (历史约束)

#### 2.1.4 Interface Segregation Principle (ISP) (接口隔离原则)

**Definition (定义):**
No client should be forced to depend on methods it does not use. Many client-specific interfaces are better than one general-purpose interface.

不应该强迫客户端依赖它不使用的方法。多个特定客户端接口优于一个通用接口。

**Intent (意图):**
- Create focused, cohesive interfaces (创建专注、内聚的接口)
- Avoid "fat" interfaces (避免"胖"接口)
- Reduce coupling between clients and interfaces (减少客户端和接口之间的耦合)

**Example (示例):**

```java
// Bad: Fat interface (不好：胖接口)
interface Worker {
    void work();
    void eat();
    void sleep();
}

class HumanWorker implements Worker {
    public void work() { System.out.println("Working..."); }
    public void eat() { System.out.println("Eating..."); }
    public void sleep() { System.out.println("Sleeping..."); }
}

class RobotWorker implements Worker {
    public void work() { System.out.println("Working..."); }
    public void eat() { /* 机器人不需要吃饭 */ }
    public void sleep() { /* 机器人不需要睡觉 */ }
    // 被迫实现不需要的方法
}

// Good: Segregated interfaces (好：隔离的接口)
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

interface Sleepable {
    void sleep();
}

class HumanWorker implements Workable, Eatable, Sleepable {
    public void work() { System.out.println("Working..."); }
    public void eat() { System.out.println("Eating..."); }
    public void sleep() { System.out.println("Sleeping..."); }
}

class RobotWorker implements Workable {
    public void work() { System.out.println("Working..."); }
    // 只实现需要的接口
}
```

**Benefits (收益):**
- Better decoupling (更好的解耦)
- Easier to understand and implement (更容易理解和实现)
- More flexible and maintainable (更灵活和可维护)

#### 2.1.5 Dependency Inversion Principle (DIP) (依赖倒置原则)

**Definition (定义):**
- High-level modules should not depend on low-level modules. Both should depend on abstractions.
- Abstractions should not depend on details. Details should depend on abstractions.

- 高层模块不应该依赖低层模块。两者都应该依赖抽象。
- 抽象不应该依赖细节。细节应该依赖抽象。

**Intent (意图):**
- Reduce coupling between modules (减少模块间耦合)
- Make code more flexible and reusable (使代码更灵活和可复用)
- Facilitate testing and mocking (便于测试和模拟)

**Example (示例):**

```java
// Bad: High-level depends on low-level (不好：高层依赖低层)
class MySQLDatabase {
    public void connect() { /* MySQL连接 */ }
    public void query(String sql) { /* 查询 */ }
}

class UserService {
    private MySQLDatabase database = new MySQLDatabase();
    
    public User getUser(int id) {
        database.connect();
        // 直接依赖具体实现，难以测试和切换数据库
        return null;
    }
}

// Good: Both depend on abstraction (好：都依赖抽象)
interface Database {
    void connect();
    void query(String sql);
}

class MySQLDatabase implements Database {
    public void connect() { /* MySQL连接 */ }
    public void query(String sql) { /* 查询 */ }
}

class MongoDatabase implements Database {
    public void connect() { /* MongoDB连接 */ }
    public void query(String sql) { /* 查询 */ }
}

class UserService {
    private Database database;
    
    // 依赖注入
    public UserService(Database database) {
        this.database = database;
    }
    
    public User getUser(int id) {
        database.connect();
        // 依赖抽象，易于测试和切换实现
        return null;
    }
}

// 使用示例
Database mysql = new MySQLDatabase();
UserService service = new UserService(mysql);
```

**Implementation Techniques (实现技术):**
- Dependency Injection (依赖注入)
- Factory Pattern (工厂模式)
- Service Locator (服务定位器)

### 2.2 Other Important Principles (其他重要原则)

#### 2.2.1 Law of Demeter (LoD) (迪米特法则)

**Definition (定义):**
A method of an object should only call methods of:
- The object itself (对象本身)
- Objects passed as parameters (作为参数传递的对象)
- Objects it creates (它创建的对象)
- Its direct component objects (其直接组件对象)

**Also Known As (也称为):** Principle of Least Knowledge (最少知识原则)

**Example (示例):**

```java
// Bad: Violates LoD (不好：违反迪米特法则)
class Customer {
    public Wallet getWallet() { return wallet; }
}

class Wallet {
    public double getAmount() { return amount; }
}

class ShoppingCart {
    public void checkout(Customer customer, double price) {
        // 过多了解Customer的内部结构
        double balance = customer.getWallet().getAmount();
        if (balance >= price) {
            // 处理支付
        }
    }
}

// Good: Follows LoD (好：遵循迪米特法则)
class Customer {
    private Wallet wallet;
    
    // 封装内部细节
    public boolean canAfford(double amount) {
        return wallet.getAmount() >= amount;
    }
    
    public void pay(double amount) {
        wallet.deduct(amount);
    }
}

class ShoppingCart {
    public void checkout(Customer customer, double price) {
        // 只与Customer交互，不了解其内部结构
        if (customer.canAfford(price)) {
            customer.pay(price);
        }
    }
}
```

**Benefits (收益):**
- Reduced coupling (减少耦合)
- Improved maintainability (提高可维护性)
- Better encapsulation (更好的封装)

#### 2.2.2 Composition Over Inheritance (组合优于继承原则)

**Definition (定义):**
Favor object composition over class inheritance to achieve code reuse and flexibility.

优先使用对象组合而不是类继承来实现代码复用和灵活性。

**Reasons (原因):**
- Inheritance creates tight coupling (继承创建紧密耦合)
- Fragile base class problem (脆弱基类问题)
- Limited to single inheritance in many languages (许多语言限制为单继承)
- Composition provides more flexibility (组合提供更多灵活性)

**Example (示例):**

```java
// Using Inheritance (使用继承)
class Bird {
    public void eat() { }
}

class FlyingBird extends Bird {
    public void fly() { }
}

class SwimmingBird extends Bird {
    public void swim() { }
}

// 问题：如果有既能飞又能游的鸟怎么办？

// Using Composition (使用组合)
interface FlyBehavior {
    void fly();
}

interface SwimBehavior {
    void swim();
}

class Bird {
    private FlyBehavior flyBehavior;
    private SwimBehavior swimBehavior;
    
    public Bird(FlyBehavior fb, SwimBehavior sb) {
        this.flyBehavior = fb;
        this.swimBehavior = sb;
    }
    
    public void performFly() {
        if (flyBehavior != null) {
            flyBehavior.fly();
        }
    }
    
    public void performSwim() {
        if (swimBehavior != null) {
            swimBehavior.swim();
        }
    }
}

// 灵活组合不同行为
Bird duck = new Bird(new CanFly(), new CanSwim());
Bird penguin = new Bird(null, new CanSwim());
```

**When to Use Each (何时使用):**
- **Inheritance (继承):** "is-a" relationship, stable hierarchy (is-a关系，稳定层次结构)
- **Composition (组合):** "has-a" relationship, dynamic behavior (has-a关系，动态行为)

## 3. Creational Patterns (创建型模式)

Creational patterns abstract the instantiation process. They help make a system independent of how its objects are created, composed, and represented.

创建型模式抽象了实例化过程。它们帮助系统独立于对象的创建、组合和表示方式。

### 3.1 Singleton Pattern (单例模式)

**Intent (意图):**
Ensure a class has only one instance and provide a global point of access to it.

确保一个类只有一个实例，并提供一个全局访问点。

**Problem (问题):**
- Need exactly one instance of a class (需要类的确切一个实例)
- Instance must be accessible from a well-known access point (实例必须从一个众所周知的访问点访问)
- Instance should be extensible without modifying code (实例应该可扩展而不修改代码)

**Structure (结构):**

```
┌─────────────────┐
│   Singleton     │
├─────────────────┤
│ - instance      │
├─────────────────┤
│ + getInstance() │
│ - Singleton()   │
└─────────────────┘
```

**Implementation Approaches (实现方法):**

```java
// 1. Eager Initialization (饿汉式)
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() { }
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}

// Pros: Thread-safe, simple (线程安全，简单)
// Cons: Instance created even if never used (即使从未使用也创建实例)

// 2. Lazy Initialization (懒汉式 - 线程不安全)
public class Singleton {
    private static Singleton instance;
    
    private Singleton() { }
    
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

// Pros: Lazy loading (延迟加载)
// Cons: Not thread-safe (非线程安全)

// 3. Double-Checked Locking (双重检查锁定)
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() { }
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

// Pros: Thread-safe, lazy, good performance (线程安全，延迟，性能好)
// Cons: Verbose, volatile required (冗长，需要volatile)

// 4. Static Inner Class (静态内部类 - 推荐)
public class Singleton {
    private Singleton() { }
    
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}

// Pros: Thread-safe, lazy, elegant (线程安全，延迟，优雅)
// Cons: None (无)

// 5. Enum (枚举 - 最佳实践)
public enum Singleton {
    INSTANCE;
    
    public void doSomething() {
        // 业务方法
    }
}

// Pros: Thread-safe, serialization safe, prevents reflection (线程安全，序列化安全，防止反射)
// Cons: Not lazy, enum-specific (非延迟，特定于枚举)
```

**Applicability (适用场景):**
- Logger classes (日志类)
- Configuration managers (配置管理器)
- Thread pools (线程池)
- Cache managers (缓存管理器)
- Database connection pools (数据库连接池)

**Consequences (后果):**

**Advantages (优点):**
- ✓ Controlled access to sole instance (对唯一实例的受控访问)
- ✓ Reduced namespace pollution (减少命名空间污染)
- ✓ Permits refinement of operations (允许操作的精化)
- ✓ Can be extended by subclassing (可以通过子类化扩展)

**Disadvantages (缺点):**
- ✗ Violates Single Responsibility Principle (违反单一职责原则)
- ✗ Difficult to unit test (难以单元测试)
- ✗ Can hide dependencies (可能隐藏依赖关系)
- ✗ Global state issues in concurrent programs (并发程序中的全局状态问题)

**Real-World Examples (实际应用示例):**

```java
// Spring Framework
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
// Bean默认为单例

// Java Runtime
Runtime runtime = Runtime.getRuntime();

// Logger
Logger logger = Logger.getLogger(MyClass.class.getName());
```

### 3.2 Factory Method Pattern (工厂方法模式)

**Intent (意图):**
Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

定义一个创建对象的接口，但让子类决定实例化哪个类。工厂方法让类将实例化延迟到子类。

**Problem (问题):**
- A class cannot anticipate the class of objects it must create (类无法预测它必须创建的对象的类)
- A class wants its subclasses to specify the objects it creates (类希望其子类指定它创建的对象)
- Classes delegate responsibility to helper subclasses (类将职责委托给辅助子类)

**Structure (结构):**

```
┌──────────────┐                    ┌──────────────┐
│   Creator    │                    │   Product    │
├──────────────┤                    └──────────────┘
│ factoryMethod│                           △
└──────┬───────┘                           │
       △                                   │
       │                                   │
┌──────┴───────────┐              ┌────────┴────────┐
│ ConcreteCreatorA │              │ ConcreteProductA│
├──────────────────┤              └─────────────────┘
│ factoryMethod()  │──creates──>
└──────────────────┘              ┌─────────────────┐
                                  │ ConcreteProductB│
┌──────────────────┐              └─────────────────┘
│ ConcreteCreatorB │──creates──>
├──────────────────┤
│ factoryMethod()  │
└──────────────────┘
```

**Implementation (实现):**

```java
// Product interface (产品接口)
interface Document {
    void open();
    void save();
    void close();
}

// Concrete Products (具体产品)
class WordDocument implements Document {
    public void open() { System.out.println("Opening Word document"); }
    public void save() { System.out.println("Saving Word document"); }
    public void close() { System.out.println("Closing Word document"); }
}

class PDFDocument implements Document {
    public void open() { System.out.println("Opening PDF document"); }
    public void save() { System.out.println("Saving PDF document"); }
    public void close() { System.out.println("Closing PDF document"); }
}

// Creator (创建者)
abstract class Application {
    // Factory Method (工厂方法)
    public abstract Document createDocument();
    
    // Template method using factory method (使用工厂方法的模板方法)
    public void newDocument() {
        Document doc = createDocument();
        doc.open();
        // Additional logic
    }
}

// Concrete Creators (具体创建者)
class WordApplication extends Application {
    @Override
    public Document createDocument() {
        return new WordDocument();
    }
}

class PDFApplication extends Application {
    @Override
    public Document createDocument() {
        return new PDFDocument();
    }
}

// Client code (客户端代码)
Application app = new WordApplication();
Document doc = app.createDocument();
doc.open();
```

**Comparison with Simple Factory (与简单工厂对比):**

```java
// Simple Factory (简单工厂 - 不是GoF模式)
class DocumentFactory {
    public static Document createDocument(String type) {
        switch (type) {
            case "word": return new WordDocument();
            case "pdf": return new PDFDocument();
            default: throw new IllegalArgumentException();
        }
    }
}
// 优点：简单
// 缺点：违反开闭原则，添加新类型需修改工厂代码

// Factory Method (工厂方法)
// 优点：符合开闭原则，扩展性好
// 缺点：类的数量增加
```

**Applicability (适用场景):**
- When a class can't anticipate the class of objects it must create (当类无法预测必须创建的对象的类时)
- When a class wants its subclasses to specify the objects it creates (当类希望其子类指定它创建的对象时)
- When classes delegate responsibility to helper subclasses (当类将职责委托给辅助子类时)

**Real-World Examples (实际应用示例):**

```java
// Java Collections Framework
List<String> list = Collections.emptyList(); // Factory method

// JDBC
Connection conn = DriverManager.getConnection(url);

// Calendar
Calendar calendar = Calendar.getInstance();
```

### 3.3 Abstract Factory Pattern (抽象工厂模式)

**Intent (意图):**
Provide an interface for creating families of related or dependent objects without specifying their concrete classes.

提供一个接口用于创建相关或依赖对象的家族，而不需要指定它们的具体类。

**Problem (问题):**
- System should be independent of how its products are created (系统应独立于产品的创建方式)
- System should be configured with one of multiple families of products (系统应配置多个产品家族中的一个)
- Family of related product objects must be used together (相关产品对象家族必须一起使用)
- Want to provide a library of products without revealing implementations (想提供产品库而不暴露实现)

**Structure (结构):**

```
┌──────────────────┐         ┌──────────────────┐
│ AbstractFactory  │         │  AbstractProductA│
├──────────────────┤         └──────────────────┘
│ +createProductA()│                  △
│ +createProductB()│                  │
└────────△─────────┘         ┌────────┴─────────┐
         │                   │ ConcreteProductA1│
┌────────┴─────────┐         └──────────────────┘
│ ConcreteFactory1 │         ┌──────────────────┐
├──────────────────┤         │ ConcreteProductA2│
│ +createProductA()│────>    └──────────────────┘
│ +createProductB()│
└──────────────────┘         ┌──────────────────┐
                             │  AbstractProductB│
┌──────────────────┐         └──────────────────┘
│ ConcreteFactory2 │                  △
├──────────────────┤                  │
│ +createProductA()│         ┌────────┴─────────┐
│ +createProductB()│────>    │ ConcreteProductB1│
└──────────────────┘         └──────────────────┘
                             ┌──────────────────┐
                             │ ConcreteProductB2│
                             └──────────────────┘
```

**Implementation (实现):**

```java
// Abstract Products (抽象产品)
interface Button {
    void paint();
}

interface Checkbox {
    void paint();
}

// Concrete Products for Windows (Windows具体产品)
class WindowsButton implements Button {
    public void paint() {
        System.out.println("Rendering Windows button");
    }
}

class WindowsCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Rendering Windows checkbox");
    }
}

// Concrete Products for Mac (Mac具体产品)
class MacButton implements Button {
    public void paint() {
        System.out.println("Rendering Mac button");
    }
}

class MacCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Rendering Mac checkbox");
    }
}

// Abstract Factory (抽象工厂)
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Concrete Factories (具体工厂)
class WindowsFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

class MacFactory implements GUIFactory {
    public Button createButton() {
        return new MacButton();
    }
    
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}

// Client code (客户端代码)
class Application {
    private Button button;
    private Checkbox checkbox;
    
    public Application(GUIFactory factory) {
        button = factory.createButton();
        checkbox = factory.createCheckbox();
    }
    
    public void paint() {
        button.paint();
        checkbox.paint();
    }
}

// Usage (使用)
GUIFactory factory;
String osName = System.getProperty("os.name").toLowerCase();

if (osName.contains("win")) {
    factory = new WindowsFactory();
} else if (osName.contains("mac")) {
    factory = new MacFactory();
}

Application app = new Application(factory);
app.paint();
```

**Comparison: Factory Method vs Abstract Factory (工厂方法vs抽象工厂对比):**

| Aspect     | Factory Method   | Abstract Factory | 方面     | 工厂方法   | 抽象工厂  |
| ---------- | ---------------- | ---------------- | -------- | ---------- | --------- |
| Focus      | Single product   | Product families | 关注点   | 单个产品   | 产品家族  |
| Hierarchy  | Uses inheritance | Uses composition | 层次结构 | 使用继承   | 使用组合  |
| Complexity | Simpler          | More complex     | 复杂度   | 更简单     | 更复杂    |
| Example    | Document creator | GUI toolkit      | 示例     | 文档创建器 | GUI工具包 |

**Applicability (适用场景):**
- UI toolkits (different look and feel) (UI工具包-不同外观)
- Database access layers (支持多种数据库)
- Cross-platform applications (跨平台应用)
- Product families that must be used together (必须一起使用的产品家族)

**Real-World Examples (实际应用示例):**

```java
// JDBC DriverManager
Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement();
PreparedStatement pstmt = conn.prepareStatement(sql);

// Java AWT/Swing
Toolkit toolkit = Toolkit.getDefaultToolkit();
```

### 3.4 Builder Pattern (建造者模式)

**Intent (意图):**
Separate the construction of a complex object from its representation so that the same construction process can create different representations.

将复杂对象的构建与其表示分离，使得相同的构建过程可以创建不同的表示。

**Problem (问题):**
- Object construction is complex with many parameters (对象构造复杂且有许多参数)
- Need different representations of the object (需要对象的不同表示)
- Construction algorithm should be independent of parts (构造算法应独立于部件)
- Avoid telescoping constructor anti-pattern (避免伸缩构造函数反模式)

**Structure (结构):**

```
┌─────────┐          ┌──────────┐         ┌─────────┐
│Director │─builds──>│ Builder  │<──────>│ Product │
└─────────┘          └─────△────┘         └─────────┘
                           │
                  ┌────────┴────────┐
                  │               │
          ┌───────┴────────┐ ┌────┴──────────┐
          │ConcreteBuilder1│ │ConcreteBuilder2│
          └────────────────┘ └───────────────┘
```

**Implementation (实现):**

```java
// Product (产品)
class Computer {
    // Required parameters (必需参数)
    private String CPU;
    private String RAM;
    
    // Optional parameters (可选参数)
    private String storage;
    private String GPU;
    private String motherboard;
    private String powerSupply;
    
    private Computer(Builder builder) {
        this.CPU = builder.CPU;
        this.RAM = builder.RAM;
        this.storage = builder.storage;
        this.GPU = builder.GPU;
        this.motherboard = builder.motherboard;
        this.powerSupply = builder.powerSupply;
    }
    
    // Builder class (建造者类)
    public static class Builder {
        // Required parameters (必需参数)
        private final String CPU;
        private final String RAM;
        
        // Optional parameters - initialized to default values
        // (可选参数 - 初始化为默认值)
        private String storage = "256GB SSD";
        private String GPU = "Integrated";
        private String motherboard = "Standard";
        private String powerSupply = "500W";
        
        public Builder(String CPU, String RAM) {
            this.CPU = CPU;
            this.RAM = RAM;
        }
        
        public Builder storage(String val) {
            storage = val;
            return this;
        }
        
        public Builder GPU(String val) {
            GPU = val;
            return this;
        }
        
        public Builder motherboard(String val) {
            motherboard = val;
            return this;
        }
        
        public Builder powerSupply(String val) {
            powerSupply = val;
            return this;
        }
        
        public Computer build() {
            return new Computer(this);
        }
    }
    
    @Override
    public String toString() {
        return "Computer{" +
               "CPU='" + CPU + '\'' +
               ", RAM='" + RAM + '\'' +
               ", storage='" + storage + '\'' +
               ", GPU='" + GPU + '\'' +
               ", motherboard='" + motherboard + '\'' +
               ", powerSupply='" + powerSupply + '\'' +
               '}';
    }
}

// Usage (使用)
Computer gamingPC = new Computer.Builder("Intel i9", "32GB")
    .storage("1TB NVMe SSD")
    .GPU("RTX 4090")
    .powerSupply("850W")
    .build();

Computer officePC = new Computer.Builder("Intel i5", "16GB")
    .storage("512GB SSD")
    .build();
```

**Classic Builder with Director (带导演的经典建造者):**

```java
// Builder interface (建造者接口)
interface HouseBuilder {
    void buildFoundation();
    void buildStructure();
    void buildRoof();
    void buildInterior();
    House getHouse();
}

// Concrete Builders (具体建造者)
class ConcreteHouseBuilder implements HouseBuilder {
    private House house;
    
    public ConcreteHouseBuilder() {
        this.house = new House();
    }
    
    public void buildFoundation() {
        house.setFoundation("Concrete foundation");
    }
    
    public void buildStructure() {
        house.setStructure("Concrete walls");
    }
    
    public void buildRoof() {
        house.setRoof("Concrete roof");
    }
    
    public void buildInterior() {
        house.setInterior("Standard interior");
    }
    
    public House getHouse() {
        return this.house;
    }
}

class WoodenHouseBuilder implements HouseBuilder {
    private House house;
    
    public WoodenHouseBuilder() {
        this.house = new House();
    }
    
    public void buildFoundation() {
        house.setFoundation("Wood foundation");
    }
    
    public void buildStructure() {
        house.setStructure("Wood walls");
    }
    
    public void buildRoof() {
        house.setRoof("Wood roof");
    }
    
    public void buildInterior() {
        house.setInterior("Wooden interior");
    }
    
    public House getHouse() {
        return this.house;
    }
}

// Director (导演)
class ConstructionDirector {
    private HouseBuilder houseBuilder;
    
    public ConstructionDirector(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }
    
    public House constructHouse() {
        houseBuilder.buildFoundation();
        houseBuilder.buildStructure();
        houseBuilder.buildRoof();
        houseBuilder.buildInterior();
        return houseBuilder.getHouse();
    }
}

// Usage (使用)
HouseBuilder builder = new ConcreteHouseBuilder();
ConstructionDirector director = new ConstructionDirector(builder);
House house = director.constructHouse();
```

**Applicability (适用场景):**
- Complex object creation with many parameters (具有许多参数的复杂对象创建)
- Immutable objects (不可变对象)
- Step-by-step object construction (逐步对象构造)
- Different representations of the same object (同一对象的不同表示)

**Real-World Examples (实际应用示例):**

```java
// StringBuilder
StringBuilder sb = new StringBuilder()
    .append("Hello")
    .append(" ")
    .append("World");

// Java 8 Stream API
Stream<Integer> stream = Stream.builder()
    .add(1)
    .add(2)
    .add(3)
    .build();

// HTTP Client (Java 11+)
HttpClient client = HttpClient.newBuilder()
    .version(HttpClient.Version.HTTP_2)
    .connectTimeout(Duration.ofSeconds(20))
    .build();
```

### 3.5 Prototype Pattern (原型模式)

**Intent (意图):**
Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.

使用原型实例指定要创建的对象类型，并通过复制此原型创建新对象。

**Problem (问题):**
- Object creation is expensive (对象创建成本高)
- Need to avoid subclassing the creator (需要避免创建者的子类化)
- Number of classes should be minimized (应最小化类的数量)
- Runtime specification of objects (运行时指定对象)

**Structure (结构):**

```
┌─────────────┐
│  Prototype  │
├─────────────┤
│ + clone()   │
└──────△──────┘
       │
       │
┌──────┴──────────┐
│ConcretePrototype│
├─────────────────┤
│ + clone()       │
└─────────────────┘
```

**Implementation (实现):**

```java
// Prototype interface (原型接口)
interface Shape extends Cloneable {
    Shape clone();
    void draw();
}

// Concrete Prototypes (具体原型)
class Circle implements Shape {
    private int x, y, radius;
    private String color;
    
    public Circle(int x, int y, int radius, String color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
    }
    
    @Override
    public Shape clone() {
        return new Circle(x, y, radius, color);
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing " + color + " circle at (" + 
                         x + "," + y + ") with radius " + radius);
    }
}

class Rectangle implements Shape {
    private int x, y, width, height;
    private String color;
    
    public Rectangle(int x, int y, int width, int height, String color) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.color = color;
    }
    
    @Override
    public Shape clone() {
        return new Rectangle(x, y, width, height, color);
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing " + color + " rectangle at (" + 
                         x + "," + y + ") with size " + width + "x" + height);
    }
}

// Prototype Registry (原型注册表)
class ShapeCache {
    private static Map<String, Shape> shapeMap = new HashMap<>();
    
    public static Shape getShape(String shapeId) {
        Shape cachedShape = shapeMap.get(shapeId);
        return cachedShape.clone();
    }
    
    public static void loadCache() {
        Circle circle = new Circle(0, 0, 10, "Red");
        shapeMap.put("circle", circle);
        
        Rectangle rectangle = new Rectangle(0, 0, 20, 30, "Blue");
        shapeMap.put("rectangle", rectangle);
    }
}

// Usage (使用)
ShapeCache.loadCache();

Shape clonedCircle = ShapeCache.getShape("circle");
clonedCircle.draw();

Shape clonedRectangle = ShapeCache.getShape("rectangle");
clonedRectangle.draw();
```

**Deep Copy vs Shallow Copy (深拷贝vs浅拷贝):**

```java
class Person implements Cloneable {
    private String name;
    private Address address; // Reference type
    
    // Shallow copy (浅拷贝)
    @Override
    public Person clone() {
        try {
            return (Person) super.clone();
            // address是共享的引用
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
    
    // Deep copy (深拷贝)
    public Person deepClone() {
        try {
            Person cloned = (Person) super.clone();
            cloned.address = this.address.clone(); // 克隆嵌套对象
            return cloned;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
```

**Applicability (适用场景):**
- Object creation is expensive (对象创建成本高)
- Similar objects with minor differences (具有细微差异的相似对象)
- Avoid complex class hierarchies (避免复杂的类层次结构)
- Configuration objects (配置对象)

**Real-World Examples (实际应用示例):**

```java
// Java Object.clone()
ArrayList<String> original = new ArrayList<>();
ArrayList<String> copy = (ArrayList<String>) original.clone();

// Cell in spreadsheet applications
// Game objects (characters, enemies, etc.)
// Document templates
```

## 4. Structural Patterns (结构型模式)

Structural patterns are concerned with how classes and objects are composed to form larger structures. They use inheritance to compose interfaces or implementations.

结构型模式关注如何组合类和对象以形成更大的结构。它们使用继承来组合接口或实现。

### 4.1 Adapter Pattern (适配器模式)

**Intent (意图):**
Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

将类的接口转换为客户端期望的另一个接口。适配器让原本由于接口不兼容而无法一起工作的类能够一起工作。

**Problem (问题):**
- Want to use an existing class with incompatible interface (想使用接口不兼容的现有类)
- Need to create a reusable class that cooperates with unrelated classes (需要创建一个与不相关类协作的可复用类)
- Need to use several existing subclasses (需要使用几个现有子类)

**Structure (结构):**

```
Class Adapter (类适配器 - 使用继承):
┌────────┐         ┌─────────┐         ┌─────────┐
│ Client │────────>│ Target  │         │ Adaptee │
└────────┘         └────△────┘         └────△────┘
                        │                   │
                        └───────┬───────────┘
                            ┌───┴────┐
                            │ Adapter│
                            └────────┘

Object Adapter (对象适配器 - 使用组合):
┌────────┐         ┌─────────┐
│ Client │────────>│ Target  │
└────────┘         └────△────┘
                        │
                   ┌────┴────┐       ┌─────────┐
                   │ Adapter │──────>│ Adaptee │
                   └─────────┘       └─────────┘
```

**Implementation (实现):**

```java
// Target interface (目标接口)
interface MediaPlayer {
    void play(String audioType, String fileName);
}

// Adaptee (需要适配的类)
class AdvancedMediaPlayer {
    public void playVlc(String fileName) {
        System.out.println("Playing vlc file: " + fileName);
    }
    
    public void playMp4(String fileName) {
        System.out.println("Playing mp4 file: " + fileName);
    }
}

// Adapter (适配器)
class MediaAdapter implements MediaPlayer {
    private AdvancedMediaPlayer advancedPlayer;
    
    public MediaAdapter(String audioType) {
        advancedPlayer = new AdvancedMediaPlayer();
    }
    
    @Override
    public void play(String audioType, String fileName) {
        if (audioType.equalsIgnoreCase("vlc")) {
            advancedPlayer.playVlc(fileName);
        } else if (audioType.equalsIgnoreCase("mp4")) {
            advancedPlayer.playMp4(fileName);
        }
    }
}

// Concrete Target (具体目标类)
class AudioPlayer implements MediaPlayer {
    private MediaAdapter mediaAdapter;
    
    @Override
    public void play(String audioType, String fileName) {
        // Built-in support for mp3
        if (audioType.equalsIgnoreCase("mp3")) {
            System.out.println("Playing mp3 file: " + fileName);
        }
        // Use adapter for other formats
        else if (audioType.equalsIgnoreCase("vlc") || 
                 audioType.equalsIgnoreCase("mp4")) {
            mediaAdapter = new MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        } else {
            System.out.println("Invalid media type: " + audioType);
        }
    }
}

// Usage (使用)
AudioPlayer player = new AudioPlayer();
player.play("mp3", "song.mp3");
player.play("mp4", "video.mp4");
player.play("vlc", "movie.vlc");
```

**Class Adapter vs Object Adapter (类适配器vs对象适配器):**

```java
// Class Adapter (使用继承)
class ClassAdapter extends Adaptee implements Target {
    @Override
    public void request() {
        specificRequest();
    }
}
// 优点：无需持有Adaptee引用，可覆盖Adaptee行为
// 缺点：Java不支持多继承，只能适配一个类

// Object Adapter (使用组合)
class ObjectAdapter implements Target {
    private Adaptee adaptee;
    
    public ObjectAdapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
    
    @Override
    public void request() {
        adaptee.specificRequest();
    }
}
// 优点：可以适配Adaptee及其子类，更灵活
// 缺点：需要额外对象，略微复杂
```

**Applicability (适用场景):**
- Legacy code integration (遗留代码集成)
- Third-party library integration (第三方库集成)
- Interface incompatibility (接口不兼容)
- Reusing existing classes (复用现有类)

**Real-World Examples (实际应用示例):**

```java
// Java I/O
Reader reader = new InputStreamReader(inputStream);

// Arrays.asList()
List<String> list = Arrays.asList(array);

// Collections
List<String> syncList = Collections.synchronizedList(list);
```

### 4.2 Decorator Pattern (装饰器模式)

**Intent (意图):**
Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

动态地给对象附加额外的职责。装饰器为扩展功能提供了比子类化更灵活的替代方案。

**Problem (问题):**
- Need to add responsibilities to individual objects dynamically (需要动态地为单个对象添加职责)
- Extension by subclassing is impractical (通过子类化扩展不切实际)
- Want to add/remove responsibilities at runtime (想在运行时添加/删除职责)

**Structure (结构):**

```
┌───────────┐
│ Component │
└─────△─────┘
      │
      ├──────────────────┐
      │                  │
┌─────┴──────────┐ ┌─────┴────────┐
│ConcreteComponent│ │   Decorator  │
└────────────────┘ └──────△───────┘
                          │
                  ┌───────┴────────┐
                  │                │
          ┌───────┴────────┐ ┌────┴──────────┐
          │ConcreteDecoratorA│ │ConcreteDecoratorB│
          └────────────────┘ └───────────────┘
```

**Implementation (实现):**

```java
// Component interface (组件接口)
interface Coffee {
    double getCost();
    String getDescription();
}

// Concrete Component (具体组件)
class SimpleCoffee implements Coffee {
    @Override
    public double getCost() {
        return 10.0;
    }
    
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
}

// Decorator (装饰器抽象类)
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }
    
    @Override
    public double getCost() {
        return decoratedCoffee.getCost();
    }
    
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription();
    }
}

// Concrete Decorators (具体装饰器)
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public double getCost() {
        return super.getCost() + 2.0;
    }
    
    @Override
    public String getDescription() {
        return super.getDescription() + ", Milk";
    }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public double getCost() {
        return super.getCost() + 1.0;
    }
    
    @Override
    public String getDescription() {
        return super.getDescription() + ", Sugar";
    }
}

class WhipDecorator extends CoffeeDecorator {
    public WhipDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public double getCost() {
        return super.getCost() + 3.0;
    }
    
    @Override
    public String getDescription() {
        return super.getDescription() + ", Whip";
    }
}

// Usage (使用)
Coffee coffee = new SimpleCoffee();
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
// Output: Simple Coffee $10.0

coffee = new MilkDecorator(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
// Output: Simple Coffee, Milk $12.0

coffee = new SugarDecorator(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
// Output: Simple Coffee, Milk, Sugar $13.0

coffee = new WhipDecorator(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
// Output: Simple Coffee, Milk, Sugar, Whip $16.0
```

**Decorator vs Inheritance (装饰器vs继承):**

```java
// Using Inheritance (使用继承) - 类爆炸
class SimpleCoffee { }
class CoffeeWithMilk extends SimpleCoffee { }
class CoffeeWithSugar extends SimpleCoffee { }
class CoffeeWithMilkAndSugar extends SimpleCoffee { }
// N种配料需要2^N个类

// Using Decorator (使用装饰器) - 灵活组合
Coffee coffee = new WhipDecorator(
                    new SugarDecorator(
                        new MilkDecorator(
                            new SimpleCoffee()
                        )
                    )
                );
// N种配料只需N+1个类
```

**Applicability (适用场景):**
- Add responsibilities dynamically (动态添加职责)
- Responsibilities can be withdrawn (职责可以撤销)
- Extension by subclassing is impractical (子类化扩展不切实际)
- Multiple orthogonal extensions (多个正交扩展)

**Real-World Examples (实际应用示例):**

```java
// Java I/O Streams
BufferedReader reader = new BufferedReader(
    new InputStreamReader(
        new FileInputStream("file.txt")
    )
);

// Servlet API
HttpServletRequest wrappedRequest = new HttpServletRequestWrapper(request);
```

### 4.3 Proxy Pattern (代理模式)

**Intent (意图):**
Provide a surrogate or placeholder for another object to control access to it.

为另一个对象提供代理或占位符以控制对它的访问。

**Problem (问题):**
- Need to control access to an object (需要控制对对象的访问)
- Want to add functionality before/after accessing object (想在访问对象前后添加功能)
- Object is expensive to create (对象创建成本高)
- Need lazy initialization (需要延迟初始化)

**Types of Proxies (代理类型):**

1. **Virtual Proxy (虚拟代理):** Lazy initialization of expensive objects (昂贵对象的延迟初始化)
2. **Protection Proxy (保护代理):** Access control (访问控制)
3. **Remote Proxy (远程代理):** Remote object representation (远程对象表示)
4. **Smart Proxy (智能代理):** Additional housekeeping (额外的内务处理)

**Structure (结构):**

```
┌────────┐         ┌─────────┐
│ Client │────────>│ Subject │
└────────┘         └────△────┘
                        │
              ┌─────────┴─────────┐
              │                   │
        ┌─────┴────┐        ┌─────┴────┐
        │   Proxy  │───────>│RealSubject│
        └──────────┘        └──────────┘
```

**Implementation (实现):**

```java
// Subject interface (主题接口)
interface Image {
    void display();
}

// Real Subject (真实主题)
class RealImage implements Image {
    private String filename;
    
    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();
    }
    
    private void loadFromDisk() {
        System.out.println("Loading image: " + filename);
        // 模拟耗时操作
    }
    
    @Override
    public void display() {
        System.out.println("Displaying image: " + filename);
    }
}

// Proxy (代理)
class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;
    
    public ProxyImage(String filename) {
        this.filename = filename;
    }
    
    @Override
    public void display() {
        // Lazy initialization (延迟初始化)
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}

// Usage (使用)
Image image1 = new ProxyImage("photo1.jpg");
Image image2 = new ProxyImage("photo2.jpg");

// Image loaded only when display() is called
image1.display(); // Loading... Displaying...
image1.display(); // Displaying... (不再加载)
```

**Protection Proxy Example (保护代理示例):**

```java
interface Document {
    void view();
    void edit();
}

class RealDocument implements Document {
    private String content;
    
    public void view() {
        System.out.println("Viewing document");
    }
    
    public void edit() {
        System.out.println("Editing document");
    }
}

class DocumentProxy implements Document {
    private RealDocument realDocument;
    private String userRole;
    
    public DocumentProxy(String userRole) {
        this.userRole = userRole;
        this.realDocument = new RealDocument();
    }
    
    @Override
    public void view() {
        realDocument.view();
    }
    
    @Override
    public void edit() {
        if ("ADMIN".equals(userRole) || "EDITOR".equals(userRole)) {
            realDocument.edit();
        } else {
            System.out.println("Access denied: insufficient permissions");
        }
    }
}
```

**Dynamic Proxy (动态代理):**

```java
// Java Dynamic Proxy
interface UserService {
    void saveUser(String username);
    String getUser(int id);
}

class UserServiceImpl implements UserService {
    public void saveUser(String username) {
        System.out.println("Saving user: " + username);
    }
    
    public String getUser(int id) {
        return "User" + id;
    }
}

// InvocationHandler
class LoggingHandler implements InvocationHandler {
    private Object target;
    
    public LoggingHandler(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) 
            throws Throwable {
        System.out.println("Before method: " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("After method: " + method.getName());
        return result;
    }
}

// Creating proxy
UserService service = new UserServiceImpl();
UserService proxy = (UserService) Proxy.newProxyInstance(
    service.getClass().getClassLoader(),
    service.getClass().getInterfaces(),
    new LoggingHandler(service)
);

proxy.saveUser("John");
// Output:
// Before method: saveUser
// Saving user: John
// After method: saveUser
```

**Proxy vs Decorator (代理vs装饰器对比):**

| Aspect          | Proxy                       | Decorator             | 方面     | 代理               | 装饰器       |
| --------------- | --------------------------- | --------------------- | -------- | ------------------ | ------------ |
| Intent          | Control access              | Add functionality     | 意图     | 控制访问           | 添加功能     |
| Object creation | Creates/manages real object | Wraps existing object | 对象创建 | 创建/管理真实对象  | 包装现有对象 |
| Interface       | Same as real object         | May differ            | 接口     | 与真实对象相同     | 可能不同     |
| Purpose         | Access control, lazy load   | Enhance behavior      | 目的     | 访问控制、延迟加载 | 增强行为     |

**Applicability (适用场景):**
- Lazy initialization (延迟初始化)
- Access control (访问控制)
- Logging and monitoring (日志和监控)
- Caching (缓存)
- Remote method invocation (远程方法调用)

**Real-World Examples (实际应用示例):**

```java
// Spring AOP
@Transactional
public void saveData() { }

// Hibernate lazy loading
@OneToMany(fetch = FetchType.LAZY)
private List<Order> orders;

// RMI (Remote Method Invocation)
Registry registry = LocateRegistry.getRegistry("host");
RemoteService stub = (RemoteService) registry.lookup("RemoteService");
```

## 5. Behavioral Patterns (行为型模式)

Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects. They describe not just patterns of objects or classes but also the patterns of communication between them.

行为型模式关注算法和对象之间的职责分配。它们不仅描述对象或类的模式，还描述它们之间的通信模式。

### 5.1 Strategy Pattern (策略模式)

**Intent (意图):**
Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

定义一系列算法，封装每一个，并使它们可互换。策略让算法独立于使用它的客户端而变化。

**Problem (问题):**
- Many related classes differ only in behavior (许多相关类仅在行为上不同)
- Need different variants of an algorithm (需要算法的不同变体)
- Algorithm uses data client shouldn't know about (算法使用客户端不应该知道的数据)
- Class has many conditional statements (类有许多条件语句)

**Structure (结构):**

```
┌─────────┐           ┌──────────┐
│ Context │──────────>│ Strategy │
└─────────┘           └─────△────┘
                            │
              ┌─────────────┼─────────────┐
              │             │             │
    ┌─────────┴────┐ ┌──────┴──────┐ ┌───┴─────────┐
    │ConcreteStrategyA│ │ConcreteStrategyB│ │ConcreteStrategyC│
    └──────────────┘ └─────────────┘ └─────────────┘
```

**Implementation (实现):**

```java
// Strategy interface (策略接口)
interface PaymentStrategy {
    void pay(double amount);
}

// Concrete Strategies (具体策略)
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;
    private String cvv;
    
    public CreditCardPayment(String cardNumber, String cvv) {
        this.cardNumber = cardNumber;
        this.cvv = cvv;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " using Credit Card");
    }
}

class PayPalPayment implements PaymentStrategy {
    private String email;
    
    public PayPalPayment(String email) {
        this.email = email;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " using PayPal");
    }
}

class BitcoinPayment implements PaymentStrategy {
    private String walletAddress;
    
    public BitcoinPayment(String walletAddress) {
        this.walletAddress = walletAddress;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println("Paid $" + amount + " using Bitcoin");
    }
}

// Context (上下文)
class ShoppingCart {
    private List<Item> items = new ArrayList<>();
    private PaymentStrategy paymentStrategy;
    
    public void addItem(Item item) {
        items.add(item);
    }
    
    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }
    
    public void checkout() {
        double total = items.stream()
                           .mapToDouble(Item::getPrice)
                           .sum();
        paymentStrategy.pay(total);
    }
}

// Usage (使用)
ShoppingCart cart = new ShoppingCart();
cart.addItem(new Item("Book", 29.99));
cart.addItem(new Item("Pen", 4.99));

// 选择支付策略
cart.setPaymentStrategy(new CreditCardPayment("1234-5678", "123"));
cart.checkout();

// 更改策略
cart.setPaymentStrategy(new PayPalPayment("user@email.com"));
cart.checkout();
```

**Without Strategy Pattern (不使用策略模式):**

```java
// Bad: Violates Open-Closed Principle (不好：违反开闭原则)
class ShoppingCart {
    public void checkout(String paymentMethod, double amount) {
        if (paymentMethod.equals("creditcard")) {
            // Credit card logic
        } else if (paymentMethod.equals("paypal")) {
            // PayPal logic
        } else if (paymentMethod.equals("bitcoin")) {
            // Bitcoin logic
        }
        // 添加新支付方式需要修改此方法
    }
}
```

**Applicability (适用场景):**
- Multiple related classes differ only in behavior (多个相关类仅在行为上不同)
- Need different variants of an algorithm (需要算法的不同变体)
- Algorithm contains data clients shouldn't access (算法包含客户端不应访问的数据)
- Avoid complex conditional statements (避免复杂的条件语句)

**Real-World Examples (实际应用示例):**

```java
// Java Collections sort with Comparator
Collections.sort(list, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});

// Java LayoutManager in GUI
JPanel panel = new JPanel();
panel.setLayout(new BorderLayout()); // 策略

// Spring Security Authentication
AuthenticationManager authManager = 
    new ProviderManager(authenticationProvider); // 策略
```

### 5.2 Observer Pattern (观察者模式)

**Intent (意图):**
Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

定义对象之间的一对多依赖关系，使得当一个对象改变状态时，所有依赖它的对象都会得到通知并自动更新。

**Also Known As (也称为):** Publish-Subscribe (发布-订阅)

**Problem (问题):**
- Need to maintain consistency between related objects (需要在相关对象之间保持一致性)
- Want to notify objects without tight coupling (想通知对象而不紧密耦合)
- Number of dependent objects is unknown (依赖对象的数量未知)

**Structure (结构):**

```
┌─────────┐           ┌──────────┐
│ Subject │──────────>│ Observer │
├─────────┤           └─────△────┘
│ +attach()│                │
│ +detach()│                │
│ +notify()│                │
└────△────┘         ┌──────┴──────┐
     │              │             │
┌────┴──────┐ ┌────┴────────┐ ┌──┴───────────┐
│ConcreteSubject│ │ConcreteObserverA│ │ConcreteObserverB│
└───────────┘ └─────────────┘ └──────────────┘
```

**Implementation (实现):**

```java
// Observer interface (观察者接口)
interface Observer {
    void update(String message);
}

// Concrete Observers (具体观察者)
class EmailNotifier implements Observer {
    private String email;
    
    public EmailNotifier(String email) {
        this.email = email;
    }
    
    @Override
    public void update(String message) {
        System.out.println("Email to " + email + ": " + message);
    }
}

class SMSNotifier implements Observer {
    private String phoneNumber;
    
    public SMSNotifier(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }
    
    @Override
    public void update(String message) {
        System.out.println("SMS to " + phoneNumber + ": " + message);
    }
}

// Subject (主题)
class NewsAgency {
    private List<Observer> observers = new ArrayList<>();
    private String news;
    
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    public void setNews(String news) {
        this.news = news;
        notifyObservers();
    }
    
    private void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(news);
        }
    }
}

// Usage (使用)
NewsAgency agency = new NewsAgency();

Observer emailObserver = new EmailNotifier("user@email.com");
Observer smsObserver = new SMSNotifier("+1234567890");

agency.attach(emailObserver);
agency.attach(smsObserver);

agency.setNews("Breaking News: Observer Pattern Explained!");
// Output:
// Email to user@email.com: Breaking News: Observer Pattern Explained!
// SMS to +1234567890: Breaking News: Observer Pattern Explained!

agency.detach(emailObserver);
agency.setNews("Another News");
// Output:
// SMS to +1234567890: Another News
```

**Java Built-in Support (Java内置支持):**

```java
import java.util.Observable;
import java.util.Observer;

// Subject (主题)
class WeatherStation extends Observable {
    private float temperature;
    
    public void setTemperature(float temperature) {
        this.temperature = temperature;
        setChanged();
        notifyObservers(temperature);
    }
}

// Observer (观察者)
class TemperatureDisplay implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        float temperature = (Float) arg;
        System.out.println("Temperature: " + temperature + "°C");
    }
}

// Usage (使用)
WeatherStation station = new WeatherStation();
TemperatureDisplay display = new TemperatureDisplay();

station.addObserver(display);
station.setTemperature(25.5f);
```

**Push vs Pull Model (推送vs拉取模型):**

```java
// Push Model (推送模型) - Subject推送数据
interface Observer {
    void update(String data);
}

class Subject {
    public void notifyObservers() {
        for (Observer obs : observers) {
            obs.update(data); // 推送数据
        }
    }
}

// Pull Model (拉取模型) - Observer拉取数据
interface Observer {
    void update(Subject subject);
}

class ConcreteObserver implements Observer {
    public void update(Subject subject) {
        String data = subject.getData(); // 拉取数据
        // 处理数据
    }
}
```

**Applicability (适用场景):**
- Change in one object requires changing others (一个对象的改变需要改变其他对象)
- Object should notify others without assumptions about who they are (对象应通知其他对象而不假设它们是谁)
- Event handling systems (事件处理系统)
- Model-View architecture (模型-视图架构)

**Real-World Examples (实际应用示例):**

```java
// Java Swing Event Listeners
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        // Handle event
    }
});

// JavaBeans PropertyChangeListener
bean.addPropertyChangeListener(new PropertyChangeListener() {
    public void propertyChange(PropertyChangeEvent evt) {
        // Handle property change
    }
});

// RxJava
Observable.just("Hello", "World")
    .subscribe(System.out::println);
```

### 5.3 Template Method Pattern (模板方法模式)

**Intent (意图):**
Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.

在操作中定义算法的骨架，将某些步骤延迟到子类。模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤。

**Problem (问题):**
- Two or more classes have similar algorithms with minor differences (两个或多个类具有细微差异的相似算法)
- Want to avoid code duplication (想避免代码重复)
- Want to control which steps can be overridden (想控制哪些步骤可以被覆盖)

**Structure (结构):**

```
┌───────────────────┐
│ AbstractClass     │
├───────────────────┤
│ +templateMethod() │ (final)
│ +primitiveOp1()   │ (abstract)
│ +primitiveOp2()   │ (abstract)
│ +hook()           │ (optional)
└────────△──────────┘
         │
    ┌────┴────┐
    │         │
┌───┴─────┐ ┌─┴────────┐
│ConcreteClassA│ │ConcreteClassB│
└──────────┘ └──────────┘
```

**Implementation (实现):**

```java
// Abstract Class (抽象类)
abstract class DataProcessor {
    // Template Method (模板方法) - final防止被覆盖
    public final void process() {
        readData();
        processData();
        if (hookValidate()) {
            saveData();
        }
        closeResources();
    }
    
    // Abstract methods (抽象方法) - 子类必须实现
    protected abstract void readData();
    protected abstract void processData();
    protected abstract void saveData();
    
    // Concrete method (具体方法) - 通用实现
    private void closeResources() {
        System.out.println("Closing resources");
    }
    
    // Hook method (钩子方法) - 子类可选择性覆盖
    protected boolean hookValidate() {
        return true;
    }
}

// Concrete Classes (具体类)
class CSVDataProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("Reading data from CSV file");
    }
    
    @Override
    protected void processData() {
        System.out.println("Processing CSV data");
    }
    
    @Override
    protected void saveData() {
        System.out.println("Saving to database");
    }
}

class XMLDataProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("Reading data from XML file");
    }
    
    @Override
    protected void processData() {
        System.out.println("Processing XML data");
    }
    
    @Override
    protected void saveData() {
        System.out.println("Saving to file system");
    }
    
    @Override
    protected boolean hookValidate() {
        System.out.println("Validating XML schema");
        return true;
    }
}

// Usage (使用)
DataProcessor csvProcessor = new CSVDataProcessor();
csvProcessor.process();

DataProcessor xmlProcessor = new XMLDataProcessor();
xmlProcessor.process();
```

**Hollywood Principle (好莱坞原则):**
"Don't call us, we'll call you" - The template method calls the operations, not the other way around.

"不要调用我们，我们会调用你" - 模板方法调用操作，而不是相反。

**Applicability (适用场景):**
- Implement invariant parts of algorithm once (一次性实现算法的不变部分)
- Control extension points (控制扩展点)
- Avoid code duplication (避免代码重复)
- Common behavior in subclasses (子类中的通用行为)

**Real-World Examples (实际应用示例):**

```java
// Java AbstractList
public abstract class AbstractList<E> implements List<E> {
    public boolean add(E e) { // Template method
        add(size(), e);
        return true;
    }
    
    abstract public E get(int index); // Primitive operation
}

// Java InputStream
public abstract class InputStream {
    public int read(byte b[], int off, int len) { // Template method
        // Common logic
        return read(); // Calls primitive operation
    }
    
    public abstract int read(); // Primitive operation
}

// Spring JdbcTemplate
jdbcTemplate.query(sql, new RowMapper<User>() {
    public User mapRow(ResultSet rs, int rowNum) {
        // Custom logic
    }
});
```

## 6. Pattern Combinations and Relationships (模式的组合应用和关系)

### 6.1 Pattern Relationships (模式之间的关系)

**Pattern Catalog Relationships (模式目录关系):**

```
Creational Patterns:
├─ Abstract Factory ──uses──> Factory Method
├─ Builder ──can use──> Composite (for complex products)
└─ Prototype ──can use──> Singleton (for registry)

Structural Patterns:
├─ Adapter ──can use──> Bridge
├─ Composite ──uses──> Iterator (to traverse)
├─ Decorator ──similar to──> Proxy
└─ Facade ──can use──> Singleton

Behavioral Patterns:
├─ Chain of Responsibility ──can use──> Composite
├─ Command ──can use──> Memento (for undo)
├─ Iterator ──used by──> Composite
├─ Mediator ──vs──> Observer (centralized vs distributed)
├─ Observer ──can use──> Singleton (for subject)
└─ Strategy ──can use──> Factory Method
```

### 6.2 Common Pattern Combinations (常见模式组合)

**1. Factory + Singleton (工厂+单例):**

```java
// Singleton factory
class ConnectionFactory {
    private static ConnectionFactory instance;
    
    private ConnectionFactory() {}
    
    public static ConnectionFactory getInstance() {
        if (instance == null) {
            synchronized (ConnectionFactory.class) {
                if (instance == null) {
                    instance = new ConnectionFactory();
                }
            }
        }
        return instance;
    }
    
    public Connection createConnection(String type) {
        // Factory method logic
    }
}
```

**2. Strategy + Factory (策略+工厂):**

```java
class PaymentStrategyFactory {
    public static PaymentStrategy createStrategy(String type) {
        switch(type) {
            case "credit": return new CreditCardPayment();
            case "paypal": return new PayPalPayment();
            default: throw new IllegalArgumentException();
        }
    }
}

class PaymentContext {
    private PaymentStrategy strategy;
    
    public void setPaymentType(String type) {
        this.strategy = PaymentStrategyFactory.createStrategy(type);
    }
}
```

**3. Observer + Mediator (观察者+中介者):**

```java
class ChatMediator {
    private List<User> users = new ArrayList<>();
    
    public void addUser(User user) {
        users.add(user);
    }
    
    public void sendMessage(String message, User user) {
        for (User u : users) {
            if (u != user) {
                u.receive(message); // Notify pattern
            }
        }
    }
}
```

**4. Decorator + Factory (装饰器+工厂):**

```java
class CoffeeFactory {
    public static Coffee createCoffee(String type) {
        Coffee coffee = new SimpleCoffee();
        
        if (type.contains("milk")) {
            coffee = new MilkDecorator(coffee);
        }
        if (type.contains("sugar")) {
            coffee = new SugarDecorator(coffee);
        }
        return coffee;
    }
}
```

### 6.3 MVC/MVP/MVVM Architectural Patterns (MVC/MVP/MVVM架构模式)

**MVC (Model-View-Controller):**

```
┌───────┐         ┌────────┐
│  View │────────>│ Controller│
└───△───┘         └────┬───┘
    │                  │
    │                  ▼
    │             ┌────────┐
    └─────────────│  Model │
                  └────────┘

Used Patterns:
- Observer (Model notifies View)
- Strategy (Controller as strategy)
- Composite (View hierarchy)
```

**MVP (Model-View-Presenter):**

```
┌───────┐         ┌───────────┐         ┌───────┐
│  View │<───────>│ Presenter │────────>│ Model │
└───────┘         └───────────┘         └───────┘

Used Patterns:
- Observer (View-Presenter communication)
- Facade (Presenter as facade to Model)
```

**MVVM (Model-View-ViewModel):**

```
┌───────┐         ┌───────────┐         ┌───────┐
│  View │<──bind──│ ViewModel │────────>│ Model │
└───────┘         └───────────┘         └───────┘

Used Patterns:
- Observer (Data binding)
- Command (User actions)
```

## 7. Pattern Selection and Anti-Patterns (模式选择与反模式)

### 7.1 How to Choose a Design Pattern (如何选择设计模式)

**Decision Framework (决策框架):**

```
1. Understand the Problem (理解问题)
   - What is the core issue? (核心问题是什么?)
   - What are the forces at play? (起作用的力量是什么?)
   
2. Consider Object Creation Issues (考虑对象创建问题)
   ├─ Need flexibility in what gets created? → Factory Method
   ├─ Need to create families of objects? → Abstract Factory  
   ├─ Complex construction process? → Builder
   ├─ Need only one instance? → Singleton
   └─ Clone existing objects? → Prototype
   
3. Consider Structural Issues (考虑结构问题)
   ├─ Interface incompatibility? → Adapter
   ├─ Want to add responsibilities dynamically? → Decorator
   ├─ Need to control access? → Proxy
   ├─ Simplify complex subsystem? → Facade
   └─ Tree structure operations? → Composite
   
4. Consider Behavioral Issues (考虑行为问题)
   ├─ Algorithm selection at runtime? → Strategy
   ├─ One-to-many dependencies? → Observer
   ├─ Define algorithm skeleton? → Template Method
   ├─ Sequential request handling? → Chain of Responsibility
   └─ Encapsulate requests? → Command
```

**Pattern Selection Checklist (模式选择检查表):**

- [ ] Does the pattern solve my specific problem? (模式是否解决我的特定问题?)
- [ ] Are the benefits worth the added complexity? (收益是否值得增加的复杂性?)
- [ ] Does my team understand the pattern? (我的团队是否理解该模式?)
- [ ] Is the pattern appropriate for the scale? (模式是否适合规模?)
- [ ] Can I use a simpler solution instead? (我能否使用更简单的解决方案?)

### 7.2 Refactoring to Patterns (重构到模式)

**Code Smells and Corresponding Patterns (代码异味和对应模式):**

| Code Smell           | Suggested Pattern        | 代码异味   | 建议模式         |
| -------------------- | ------------------------ | ---------- | ---------------- |
| Large Class          | Extract Class, Facade    | 过大的类   | 提取类、外观     |
| Long Method          | Template Method          | 过长的方法 | 模板方法         |
| Switch Statements    | Strategy, State, Command | Switch语句 | 策略、状态、命令 |
| Parallel Inheritance | Bridge                   | 平行继承   | 桥接             |
| Feature Envy         | Move Method, Visitor     | 特性羡慕   | 移动方法、访问者 |
| Data Class           | Encapsulate Field        | 数据类     | 封装字段         |
| Temporary Field      | Introduce Null Object    | 临时字段   | 引入空对象       |

**Refactoring Example (重构示例):**

```java
// Before: Switch statement smell (之前: Switch语句异味)
class OrderProcessor {
    public void process(Order order) {
        switch(order.getType()) {
            case "ONLINE":
                // Process online order
                break;
            case "PHONE":
                // Process phone order
                break;
            case "MAIL":
                // Process mail order
                break;
        }
    }
}

// After: Strategy Pattern (之后: 策略模式)
interface OrderProcessingStrategy {
    void process(Order order);
}

class OnlineOrderStrategy implements OrderProcessingStrategy {
    public void process(Order order) {
        // Process online order
    }
}

class OrderProcessor {
    private Map<String, OrderProcessingStrategy> strategies;
    
    public void process(Order order) {
        OrderProcessingStrategy strategy = strategies.get(order.getType());
        strategy.process(order);
    }
}
```

### 7.3 Anti-Patterns (反模式)

**Common Anti-Patterns (常见反模式):**

**1. God Object (上帝对象):**
```java
// Anti-pattern: One class does everything
class SystemManager {
    public void handleUser() { }
    public void processOrder() { }
    public void manageInventory() { }
    public void generateReport() { }
    // ... 100+ methods
}

// Solution: Single Responsibility Principle + Facade
class UserManager { }
class OrderProcessor { }
class InventoryManager { }
class ReportGenerator { }
class SystemFacade {
    private UserManager userManager;
    private OrderProcessor orderProcessor;
    // Delegates to specialized classes
}
```

**2. Singleton Overuse (单例滥用):**
```java
// Anti-pattern: Everything is a Singleton
class Logger extends Singleton { }
class Database extends Singleton { }
class ConfigManager extends Singleton { }
// Creates global state, hard to test

// Solution: Dependency Injection
class Service {
    private Logger logger;
    private Database database;
    
    public Service(Logger logger, Database database) {
        this.logger = logger;
        this.database = database;
    }
}
```

**3. Anemic Domain Model (贫血领域模型):**
```java
// Anti-pattern: Objects with no behavior
class User {
    private String name;
    private String email;
    // Only getters and setters
}

class UserService {
    public void register(User user) {
        // All logic here
    }
}

// Solution: Rich Domain Model
class User {
    private String name;
    private String email;
    
    public void register() {
        validate();
        hashPassword();
        // Business logic in domain object
    }
    
    private void validate() { }
    private void hashPassword() { }
}
```

**4. Golden Hammer (金锤子):**
```java
// Anti-pattern: Using one pattern for everything
// "I know Observer, so everything is Observable"

// Solution: Use appropriate pattern for each problem
// - Not every class needs to be Observable
// - Consider simpler solutions first
// - Pattern should solve actual problem
```

## Summary and Conclusion (总结与结论)

### Key Takeaways (关键要点)

**1. Design Patterns are Solutions, Not Rules (设计模式是解决方案，不是规则):**
- Apply when appropriate, not blindly (适当时应用，而不是盲目)
- Understand the problem before choosing pattern (在选择模式之前理解问题)
- Simpler solutions often better than complex patterns (简单解决方案通常优于复杂模式)

**2. Master Principles Before Patterns (先掌握原则再掌握模式):**
- SOLID principles are foundational (SOLID原则是基础)
- Patterns embody these principles (模式体现这些原则)
- Good design follows principles naturally (好的设计自然遵循原则)

**3. Patterns Work Together (模式协同工作):**
- Real systems use multiple patterns (真实系统使用多个模式)
- Understand pattern relationships (理解模式关系)
- MVC/MVP/MVVM combine several patterns (MVC/MVP/MVVM结合多个模式)

**4. Context Matters (上下文很重要):**
- Same problem, different contexts, different patterns (相同问题，不同上下文，不同模式)
- Consider team expertise (考虑团队专业知识)
- Balance complexity vs. benefits (平衡复杂性与收益)

**5. Continuous Learning (持续学习):**
- GoF patterns are just the beginning (GoF模式只是开始)
- Enterprise patterns (企业模式)
- Concurrency patterns (并发模式)
- Cloud patterns (云模式)

### Best Practices (最佳实践)

**When to Use Patterns (何时使用模式):**
✓ Recurring design problems (重复出现的设计问题)
✓ Need for flexibility and extensibility (需要灵活性和可扩展性)
✓ Well-understood problem domain (充分理解的问题领域)
✓ Team familiar with patterns (团队熟悉模式)

**When NOT to Use Patterns (何时不使用模式):**
✗ Simple problems (简单问题)
✗ Premature optimization (过早优化)
✗ Pattern for pattern's sake (为了模式而使用模式)
✗ Over-engineering (过度工程)

### Pattern Learning Path (模式学习路径)

```
Level 1: Foundation (基础)
├─ Understand OOP principles
├─ Learn SOLID principles  
└─ Study basic patterns: Singleton, Factory, Strategy

Level 2: Intermediate (中级)
├─ Master all GoF patterns
├─ Understand pattern relationships
└─ Practice refactoring to patterns

Level 3: Advanced (高级)
├─ Enterprise patterns (Martin Fowler)
├─ Architectural patterns
├─ Domain-Driven Design patterns
└─ Concurrency patterns

Level 4: Expert (专家)
├─ Pattern languages
├─ Create custom patterns
├─ Anti-pattern recognition
└─ Pattern mining from code
```

### Final Thoughts (最终思考)

Design patterns are a powerful tool in a developer's toolkit, but they are not a silver bullet. The key to effective use of design patterns lies in:

设计模式是开发人员工具包中的强大工具，但它们不是银弹。有效使用设计模式的关键在于：

- **Understanding the problem thoroughly** (彻底理解问题)
- **Knowing when to apply patterns and when not to** (知道何时应用模式和何时不应用)
- **Balancing flexibility with simplicity** (平衡灵活性与简单性)
- **Communicating design decisions effectively** (有效沟通设计决策)
- **Continuously learning and adapting** (持续学习和适应)

Remember: Good software design is about solving real problems elegantly, not about using as many patterns as possible.

记住：好的软件设计是关于优雅地解决实际问题，而不是使用尽可能多的模式。

---

## References and Further Reading (参考文献和延伸阅读)

**Books (书籍):**

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). *Design Patterns: Elements of Reusable Object-Oriented Software*. Addison-Wesley.
   《设计模式：可复用面向对象软件的基础》

2. Freeman, E., & Freeman, E. (2004). *Head First Design Patterns*. O'Reilly.
   《Head First设计模式》

3. Fowler, M. (2002). *Patterns of Enterprise Application Architecture*. Addison-Wesley.
   《企业应用架构模式》

4. Kerievsky, J. (2004). *Refactoring to Patterns*. Addison-Wesley.
   《重构到模式》

5. Martin, R. C. (2017). *Clean Architecture*. Prentice Hall.
   《架构整洁之道》

**Online Resources (在线资源):**

1. Refactoring.Guru - Design Patterns
   https://refactoring.guru/design-patterns

2. Source Making - Design Patterns
   https://sourcemaking.com/design_patterns

3. Java Design Patterns
   https://java-design-patterns.com/

4. Design Patterns in TypeScript
   https://www.patterns.dev/